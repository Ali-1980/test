//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Created based on libimobiledevice mobilesync API
//  Provides selective backup functionality using mobilesync protocol
//
//  Final Version - 2025.01.27
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// å¼•å…¥ libimobiledevice ç›¸å…³å¤´æ–‡ä»¶
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// å¸¸é‡å®šä¹‰
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// åŸºäºå®é™…iOSåŒæ­¥ç±»çš„æ•°æ®ç±»å‹æ˜ å°„
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        // åŸºäºå®é™…çš„iOSåŒæ­¥æœåŠ¡ç±»æ ‡è¯†ç¬¦
        map = @{
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.WebBookmarks",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper"
        };
    });
    return map;
}

// è·å–å·²çŸ¥çš„åŒæ­¥ç±»åˆ—è¡¨ - ç”¨äºæ£€æµ‹æ”¯æŒçš„æ•°æ®ç±»å‹
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.WebBookmarks",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - SyncDataItem å®ç°

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
            self.name, self.identifier, @(self.recordCount)];
}

@end

#pragma mark - BackupOptionTask å†…éƒ¨æ¥å£

@interface BackupOptionTask () {
    // libimobiledevice C API æŒ‡é’ˆ
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // æ“ä½œçŠ¶æ€
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // åŒæ­¥ä¸Šä¸‹æ–‡
    dispatch_queue_t _operationQueue;
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;
    
    // å½“å‰æ“ä½œå‚æ•°
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // å†…éƒ¨çŠ¶æ€
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
}

// ç§æœ‰æ–¹æ³•å£°æ˜
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// çœŸå®æ•°æ®å¤„ç†æ–¹æ³•
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// æ•°æ®è·å–æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// åŒæ­¥æ“ä½œæ–¹æ³•
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// éªŒè¯å’Œé”™è¯¯å¤„ç†
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;

// å·¥å…·æ–¹æ³•
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;

// æ·»åŠ çŠ¶æ€ä¿æŠ¤
@property (nonatomic, assign) BOOL isDeallocation;
@property (nonatomic, strong) NSLock *connectionLock;
@property (nonatomic, strong) NSMutableSet *activeOperations;

@end

#pragma mark - BackupOptionTask å®ç°

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;

#pragma mark - å•ä¾‹å’Œåˆå§‹åŒ–

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

// åˆå§‹åŒ–æ–¹æ³•
- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        _isDeallocation = NO; // æ–°å¢
        
        // çº¿ç¨‹å®‰å…¨é”
        _connectionLock = [[NSLock alloc] init];
        _activeOperations = [NSMutableSet set];
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        
        // è®¾ç½®é»˜è®¤æ•°æ®å­˜å‚¨è·¯å¾„
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        
        [self logMessage:[NSString stringWithFormat:@"BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}

- (void)dealloc {
    
    [self logMessage:@"BackupOptionTask deallocating and cleaning up resources"];
    // è®¾ç½®é‡Šæ”¾æ ‡å¿—
    _isDeallocation = YES;
    
    // å–æ¶ˆæ‰€æœ‰è¿›è¡Œä¸­çš„æ“ä½œ
    _cancelRequested = YES;
    
    // ç­‰å¾…æ´»åŠ¨æ“ä½œå®Œæˆ
    [self waitForActiveOperationsToComplete];
    
    // å®‰å…¨æ–­å¼€è®¾å¤‡è¿æ¥
    [self safeDisconnectDevice];
    
    // æ¸…ç†ç¼“å­˜
    [_syncAnchors removeAllObjects];
    [_dataCache removeAllObjects];
    [_activeOperations removeAllObjects];
    
    [self logMessage:@"BackupOptionTask deallocation completed"];
}

#pragma mark - è®¾å¤‡è¿æ¥å’ŒæŸ¥è¯¢

// æ–°å¢ï¼šç­‰å¾…æ´»åŠ¨æ“ä½œå®Œæˆ
- (void)waitForActiveOperationsToComplete {
    NSTimeInterval timeout = 5.0; // 5ç§’è¶…æ—¶
    NSDate *startTime = [NSDate date];
    
    while (_activeOperations.count > 0 && [[NSDate date] timeIntervalSinceDate:startTime] < timeout) {
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
    }
    
    if (_activeOperations.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"Warning: %lu operations did not complete within timeout",
                         (unsigned long)_activeOperations.count]];
    }
}



- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
    
    if (!deviceUDID || deviceUDID.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Device UDID cannot be empty"];
        }
        return NO;
    }
    
    // å¦‚æœå·²ç»è¿æ¥åˆ°åŒä¸€è®¾å¤‡ï¼Œç›´æ¥è¿”å›æˆåŠŸ
    if ([_deviceUDID isEqualToString:deviceUDID] && _device && _lockdown && _mobilesync) {
        [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@", deviceUDID]];
        return YES;
    }
    
    // å…ˆæ–­å¼€ç°æœ‰è¿æ¥
    [self disconnectDevice];
    
    _deviceUDID = [deviceUDID copy];
    return [self connectToDeviceInternal:deviceUDID error:error];
}

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨é‡Šæ”¾
    if (_isDeallocation) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Object is being deallocated"];
        }
        return NO;
    }
    
    [_connectionLock lock]; // çº¿ç¨‹å®‰å…¨ä¿æŠ¤
    
    @try {
        [self setInternalStatus:SyncTaskStatusConnecting];
        
        // 1. å®‰å…¨è¿æ¥è®¾å¤‡
        idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
        if (ret != IDEVICE_E_SUCCESS) {
            NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
            }
            return NO;
        }
        
        [self logMessage:@"Device connection established"];
        
        // 2. åˆ›å»ºlockdownå®¢æˆ·ç«¯ - æ·»åŠ NULLæ£€æŸ¥
        if (_device == NULL) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"Device handle is NULL"];
            }
            return NO;
        }
        
        lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
        if (ldret != LOCKDOWN_E_SUCCESS) {
            NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
            }
            return NO;
        }
        
        [self logMessage:@"Lockdown connection established"];
        
        // 3. å¯åŠ¨mobilesyncæœåŠ¡
        if (![self startMobileSyncService:error]) {
            return NO;
        }
        
        [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@", deviceUDID]];
        [self setInternalStatus:SyncTaskStatusIdle];
        return YES;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception in connectToDeviceInternal: %@", exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:[NSString stringWithFormat:@"Connection exception: %@", exception.reason]];
        }
        return NO;
    } @finally {
        [_connectionLock unlock];
    }
}

// åœ¨ startMobileSyncService æ–¹æ³•ä¸­æ·»åŠ é‡è¯•é€»è¾‘
- (BOOL)startMobileSyncService:(NSError **)error {
    int maxRetries = 3;
    int retryDelay = 2; // ç§’
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            if (err == MOBILESYNC_E_SUCCESS) {
                return YES;  // æˆåŠŸ
            }
            
            [self logMessage:[NSString stringWithFormat:@"MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
        }
        
        // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"Retrying in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                         description:@"Failed to create mobilesync client after multiple attempts"];
    }
    return NO;
}

- (void)disconnectDevice {
    [self safeDisconnectDevice];
}

// ä¿®å¤å®‰å…¨æ–­å¼€è¿æ¥æ–¹æ³•
- (void)safeDisconnectDevice {
    [_connectionLock lock];
    
    @try {
        [self logMessage:@"Safe disconnecting device"];
        
        // æŒ‰æ­£ç¡®é¡ºåºé‡Šæ”¾èµ„æº
        if (_mobilesync) {
            @try {
                mobilesync_finish(_mobilesync);
                mobilesync_client_free(_mobilesync);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing mobilesync: %@", e.reason]];
            }
            _mobilesync = NULL;
        }
        
        if (_afc) {
            @try {
                afc_client_free(_afc);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing afc: %@", e.reason]];
            }
            _afc = NULL;
        }
        
        if (_np) {
            @try {
                np_client_free(_np);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing np: %@", e.reason]];
            }
            _np = NULL;
        }
        
        if (_lockdown) {
            @try {
                lockdownd_client_free(_lockdown);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing lockdown: %@", e.reason]];
            }
            _lockdown = NULL;
        }
        
        if (_device) {
            @try {
                idevice_free(_device);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing device: %@", e.reason]];
            }
            _device = NULL;
        }
        
        [self setInternalStatus:SyncTaskStatusIdle];
        
    } @finally {
        [_connectionLock unlock];
    }
}

- (BOOL)isConnected {
    return (_device != NULL && _lockdown != NULL && _mobilesync != NULL);
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    @try {
        // ä½¿ç”¨æ­£ç¡®çš„APIåˆ›å»ºanchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // å‡†å¤‡æ­£ç¡®çš„å‚æ•°
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // æ­£ç¡®è°ƒç”¨mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // å¦‚æœæˆåŠŸå¯åŠ¨ï¼Œéœ€è¦ç»“æŸä¼šè¯
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

// ä¿®å¤getSupportedDataTypesæ–¹æ³•
- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    // æ£€æŸ¥é‡Šæ”¾çŠ¶æ€
    if (_isDeallocation) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Object is being deallocated"];
        }
        return BackupDataTypeNone;
    }
    
    // åˆ›å»ºæ“ä½œIDç”¨äºè¿½è¸ª
    NSString *operationId = [[NSUUID UUID] UUIDString];
    [_activeOperations addObject:operationId];
    
    @try {
        // é‡ç½®MobileSyncçŠ¶æ€ - æ·»åŠ å®‰å…¨æ£€æŸ¥
        [_connectionLock lock];
        
        if (_mobilesync && !_isDeallocation) {
            @try {
                mobilesync_finish(_mobilesync);
                mobilesync_client_free(_mobilesync);
                _mobilesync = NULL;
                [NSThread sleepForTimeInterval:0.5];
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception resetting mobilesync: %@", e.reason]];
            }
        }
        
        [_connectionLock unlock];
        
        // æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
        if (_isDeallocation || _cancelRequested) {
            return BackupDataTypeNone;
        }
        
        // é‡æ–°å¯åŠ¨MobileSyncæœåŠ¡
        if (![self startMobileSyncService:error]) {
            return BackupDataTypeNone;
        }
        
        [self logMessage:@"Getting supported data types with enhanced stability"];
        
        if (![self isConnected]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"Not connected to device"];
            }
            return BackupDataTypeNone;
        }
        
        BackupDataType supportedTypes = BackupDataTypeNone;
        
        // ä½¿ç”¨ç¼“å­˜æœºåˆ¶
        static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
        static NSString *cachedDeviceUDID = nil;
        static NSDate *cacheTime = nil;
        
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ5åˆ†é’Ÿå†…ä¸”åŒä¸€è®¾å¤‡ï¼‰
        if (cachedSupportedTypes != BackupDataTypeNone &&
            [cachedDeviceUDID isEqualToString:_deviceUDID] &&
            cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
            
            [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                             (unsigned long)cachedSupportedTypes]];
            return cachedSupportedTypes;
        }
        
        // ç¡®ä¿è¿æ¥ç¨³å®šæ€§
        if (![self ensureStableConnection:error]) {
            return BackupDataTypeNone;
        }
        
        NSArray *allDataTypes = @[
            @(BackupDataTypeContacts),
            @(BackupDataTypeCalendars),
            @(BackupDataTypeBookmarks),
            @(BackupDataTypeNotes),
            @(BackupDataTypeReminders),
            @(BackupDataTypeApplications),
            @(BackupDataTypeConfiguration),
            @(BackupDataTypeKeychain),
            @(BackupDataTypeVoiceMemos),
            @(BackupDataTypeWallpaper)
        ];
        
        NSUInteger successCount = 0;
        NSUInteger totalCount = allDataTypes.count;
        
        for (NSNumber *dataTypeNum in allDataTypes) {
            // æ£€æŸ¥å–æ¶ˆçŠ¶æ€
            if (_isDeallocation || _cancelRequested) {
                break;
            }
            
            BackupDataType dataType = [dataTypeNum unsignedIntegerValue];
            BOOL isSupported = [self isDataTypeSupportedSafe:dataType];
            
            if (isSupported) {
                supportedTypes |= dataType;
                successCount++;
                [self logMessage:[NSString stringWithFormat:@"âœ… Supported data type: %@",
                                 [BackupOptionTask stringForDataType:dataType]]];
            }
            
            // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
            if (dataTypeNum != allDataTypes.lastObject && !_isDeallocation) {
                [NSThread sleepForTimeInterval:0.1];
            }
        }
        
        // æ›´æ–°ç¼“å­˜
        if (successCount > 0 && !_isDeallocation) {
            cachedSupportedTypes = supportedTypes;
            cachedDeviceUDID = [_deviceUDID copy];
            cacheTime = [NSDate date];
        }
        
        [self logMessage:[NSString stringWithFormat:@"ğŸ“Š Final result: %lu/%lu data types supported",
                         (unsigned long)successCount, (unsigned long)totalCount]];
        
        return supportedTypes;
        
    } @finally {
        // ç§»é™¤æ“ä½œè¿½è¸ª
        [_activeOperations removeObject:operationId];
    }
}

// æ–°å¢ï¼šå®‰å…¨çš„æ•°æ®ç±»å‹æ”¯æŒæ£€æŸ¥
- (BOOL)isDataTypeSupportedSafe:(BackupDataType)dataType {
    if (_isDeallocation || _cancelRequested) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    [_connectionLock lock];
    
    @try {
        // æ£€æŸ¥MobileSyncè¿æ¥
        if (!_mobilesync) {
            [self logMessage:@"MobileSyncæœªè¿æ¥ï¼Œè·³è¿‡æ£€æµ‹"];
            return NO;
        }
        
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // ç«‹å³ç»“æŸä¼šè¯ï¼Œé¿å…çŠ¶æ€æ®‹ç•™
        if (supported && _mobilesync) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        if (anchors) {
            mobilesync_anchors_free(anchors);
        }
        
        // ä¼‘æ¯é¿å…è®¾å¤‡è¿‡è½½
        if (!_isDeallocation) {
            [NSThread sleepForTimeInterval:0.2];
        }
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"æ£€æµ‹å¼‚å¸¸: %@", exception.reason]];
        return NO;
    } @finally {
        [_connectionLock unlock];
    }
}

// âœ… æ–°å¢ï¼šç¨³å®šçš„è¿æ¥ç¡®ä¿æ–¹æ³•
- (BOOL)ensureStableConnection:(NSError **)error {
    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    if (![self isConnected]) {
        [self logMessage:@"Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // âœ… éªŒè¯è¿æ¥è´¨é‡ï¼šå°è¯•ç®€å•çš„lockdownæ“ä½œ
    if (_lockdown) {
        char *device_name = NULL;
        lockdownd_error_t ldret = lockdownd_get_device_name(_lockdown, &device_name);
        
        if (ldret == LOCKDOWN_E_SUCCESS && device_name) {
            free(device_name);
            [self logMessage:@"Connection quality verified"];
            return YES;
        } else {
            [self logMessage:[NSString stringWithFormat:@"Connection quality check failed: %d", ldret]];
            
            // è¿æ¥è´¨é‡ä¸å¥½ï¼Œå°è¯•é‡è¿
            [self disconnectDevice];
            [NSThread sleepForTimeInterval:0.5];
            return [self connectToDeviceInternal:_deviceUDID error:error];
        }
    }
    
    return YES;
}


// âœ… å¢å¼ºçš„æ•°æ®è·å–æ–¹æ³•
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"å¢å¼ºæ–¹æ³•è·å– %@ çš„çœŸå®æ•°æ®", typeName);
    
    // âœ… è¿æ¥çŠ¶æ€æ£€æŸ¥
    if (![self isConnected]) {
        NSLog(@"âŒ è®¾å¤‡æœªè¿æ¥ï¼Œæ— æ³•è·å– %@ æ•°æ®", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // âœ… å¤šæ¬¡å°è¯•è·å–æ•°æ®
    int maxAttempts = 3;
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
        if (attempt > 0) {
            NSLog(@"é‡è¯•è·å– %@ æ•°æ® (ç¬¬ %d æ¬¡å°è¯•)", typeName, attempt + 1);
            [NSThread sleepForTimeInterval:0.5];
        }
        
        items = [self getDataItemsForType:dataType error:&error];
        
        if (items && items.count > 0) {
            NSLog(@"âœ… ç¬¬ %d æ¬¡å°è¯•æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                  attempt + 1, typeName, (unsigned long)items.count);
            break;
        }
        
        if (error) {
            NSLog(@"âŒ ç¬¬ %d æ¬¡å°è¯•è·å– %@ æ•°æ®å¤±è´¥: %@",
                  attempt + 1, typeName, error.localizedDescription);
            error = nil; // æ¸…é™¤é”™è¯¯ä»¥ä¾¿ä¸‹æ¬¡å°è¯•
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"âŒ %@ æœ€ç»ˆæ— æ³•è·å–åˆ°æ•°æ®", typeName);
    return nil;
}




#pragma mark - æ•°æ®æŸ¥è¯¢

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // æ£€æŸ¥ç¼“å­˜
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // ä½¿ç”¨çœŸå®çš„æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // ç¼“å­˜ç»“æœ
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - çœŸå®æ•°æ®è·å–å®ç°

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"ğŸ”§ ä½¿ç”¨ä¿®å¤ç‰ˆè·å– %@ æ•°æ®", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // æ·»åŠ è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // âœ… å…³é”®ä¿®å¤ï¼šæ¯æ¬¡æ•°æ®è·å–å‰éƒ½é‡æ–°å»ºç«‹ MobileSync è¿æ¥
        [self logMessage:@"ğŸ”„ é‡æ–°å»ºç«‹ MobileSync è¿æ¥ä»¥ç¡®ä¿æ•°æ®è·å–ç¨³å®šæ€§"];
        
        // å¼ºåˆ¶æ–­å¼€å¹¶é‡å»º MobileSync è¿æ¥
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // çŸ­æš‚ç­‰å¾…ï¼Œè®©è®¾å¤‡é‡ç½®çŠ¶æ€
        [NSThread sleepForTimeInterval:0.5];
        
        // é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"âŒ é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡å¤±è´¥: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"âœ… MobileSync è¿æ¥å·²é‡æ–°å»ºç«‹"];
        
        // âœ… å…³é”®ä¿®å¤2ï¼šä½¿ç”¨ä¸æ£€æµ‹æ—¶ç›¸åŒçš„å‚æ•°
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"âŒ åˆ›å»ºanchorså¤±è´¥"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // âœ… å…³é”®ä¿®å¤3ï¼šä½¿ç”¨æ£€æµ‹æ—¶å®Œå…¨ç›¸åŒçš„å‚æ•°
        uint64_t data_class_version = 106;  // ä¸æ£€æµ‹æ—¶ä¿æŒä¸€è‡´
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"ğŸ”§ ä½¿ç”¨å¹²å‡€è¿æ¥å¯åŠ¨åŒæ­¥ä¼šè¯: %@", syncClass]];
        
        // âœ… å…³é”®ä¿®å¤4ï¼šå¯åŠ¨åŒæ­¥ä¼šè¯
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"âœ… %@ åŒæ­¥ä¼šè¯å¯åŠ¨æˆåŠŸï¼ˆå¹²å‡€è¿æ¥ï¼‰", syncClass]];
            
            // âœ… ä½¿ç”¨æ›´ç¨³å®šçš„æ•°æ®è·å–æ–¹æ³•
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"âœ… æˆåŠŸè¯·æ±‚ %@ çš„æ‰€æœ‰è®°å½•", syncClass]];
                
                // âœ… æ”¹è¿›çš„æ•°æ®æ¥æ”¶é€»è¾‘ - å¤„ç†è¶…æ—¶å’Œå¤šæ‰¹æ¬¡æ•°æ®
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // å‡å°‘æœ€å¤§æ‰¹æ¬¡æ•°é‡
                int timeoutCount = 0;
                int maxTimeouts = 2; // å…è®¸çš„æœ€å¤§è¶…æ—¶æ¬¡æ•°
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"ğŸ“¦ mobilesync_receive_changes è¿”å›çŠ¶æ€: %d (æ‰¹æ¬¡ %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // é‡ç½®è¶…æ—¶è®¡æ•°å™¨
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"ğŸ“¦ å¤„ç† %@ ç¬¬ %d æ‰¹æ•°æ®",
                                            syncClass, batchCount]];
                            
                            // ğŸ” è¯¦ç»†åˆ†ææ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"ğŸ“Š æ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // ğŸ”§ æ”¹è¿›çš„æ•°æ®å¤„ç†ï¼šæ”¯æŒå¤šç§æ•°æ®ç±»å‹
                            NSArray<SyncDataItem *> *batchItems = [self processReceivedDataEnhanced:entities
                                                                                            dataType:dataType
                                                                                           syncClass:syncClass
                                                                                          batchIndex:batchCount];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"âœ… ä»ç¬¬ %d æ‰¹è·å–åˆ° %lu é¡¹æ•°æ®",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ ç¬¬ %d æ‰¹æ•°æ®ä¸ºç©ºæˆ–å¤„ç†å¤±è´¥", batchCount]];
                            }
                            
                            // æ¸…ç†resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"ğŸ“­ ç¬¬ %d æ‰¹ %@ è¿”å›ç©ºæ•°æ®", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // ğŸ”§ æ”¹è¿›çš„è¶…æ—¶å¤„ç†
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"â° %@ æ¥æ”¶è¶…æ—¶ (ç¬¬ %d æ¬¡ï¼Œå…± %d æ¬¡)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ è¶…æ—¶æ¬¡æ•°è¾¾åˆ°ä¸Šé™ï¼Œåœæ­¢æ¥æ”¶", syncClass]];
                            break;
                        }
                        
                        // å¦‚æœå·²ç»è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸çš„ç»“æŸä¿¡å·
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ å·²è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸ç»“æŸ", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"âŒ æ¥æ”¶ %@ æ•°æ®æ—¶å‡ºé”™: %d",
                                        syncClass, receive_err]];
                        
                        // ğŸ”§ å¢å¼ºçš„é”™è¯¯å¤„ç†
                        [self handleReceiveError:receive_err forSyncClass:syncClass];
                        break;
                    }
                    
                    // é˜²æ­¢æ— é™å¾ªç¯
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ è¾¾åˆ°æœ€å¤§æ‰¹æ¬¡é™åˆ¶(%d)ï¼Œåœæ­¢æ¥æ”¶",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // å¦‚æœæ ‡è®°ä¸ºæœ€åä¸€æ¡è®°å½•ï¼Œç›´æ¥é€€å‡º
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"ğŸ %@ æ¥æ”¶åˆ°æœ€åè®°å½•æ ‡è®°ï¼Œæ­£å¸¸ç»“æŸ", syncClass]];
                        break;
                    }
                    
                    // æ·»åŠ å°å»¶è¿Ÿï¼Œé¿å…è¿‡åº¦è¯·æ±‚
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // ä½¿ç”¨å†…éƒ¨é€»è¾‘æ§åˆ¶å¾ªç¯
                
                [self logMessage:[NSString stringWithFormat:@"ğŸ“Š %@ æ•°æ®æ¥æ”¶å®Œæˆ: %d æ‰¹æ¬¡, %lu é¡¹",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"âŒ %@ get_all_recordså¤±è´¥: %d",
                                syncClass, get_all_err]];
                [self handleSyncError:get_all_err forDataType:dataType operation:@"get_all_records"];
                
                // ğŸ”§ ä¸ºæŸäº›é”™è¯¯æä¾›æ›´å¥½çš„é”™è¯¯ä¿¡æ¯
                if (error) {
                    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:get_all_err];
                    *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                     description:errorDesc];
                }
            }
            
            // âœ… ç¡®ä¿ä¼šè¯æ­£ç¡®ç»“æŸ
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"âœ… %@ åŒæ­¥ä¼šè¯å·²ç»“æŸ", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"âŒ %@ mobilesync_startå¤±è´¥ï¼ˆå¹²å‡€è¿æ¥åï¼‰: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"é”™è¯¯è¯¦æƒ…: %s", error_description]];
            }
            
            // âœ… å…³é”®ä¿®å¤5ï¼šå¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œè¯´æ˜æ˜¯çœŸæ­£çš„ä¸å…¼å®¹
            [self handleStartSyncError:start_err forSyncClass:syncClass error:error];
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // âœ… å³ä½¿æ²¡æœ‰è·å–åˆ°æ•°æ®ä¹Ÿä¸ç®—é”™è¯¯
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ²¡æœ‰å¯ç”¨æ•°æ®ï¼ˆä½¿ç”¨å¹²å‡€è¿æ¥åç¡®è®¤ï¼‰", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"ğŸ“Š %@ æœ€ç»ˆè·å–åˆ° %lu é¡¹çœŸå®æ•°æ®ï¼ˆå¹²å‡€è¿æ¥ï¼‰",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ æ•°æ®è·å–å¼‚å¸¸: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}


- (NSArray<SyncDataItem *> *)processReceivedDataEnhanced:(plist_t)entities
                                                dataType:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                              batchIndex:(int)batchIndex {
    
    if (!entities) {
        [self logMessage:[NSString stringWithFormat:@"ç¬¬ %d æ‰¹ %@ æ•°æ®ä¸ºç©º", batchIndex, syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(entities);
    
    // ğŸ”§ å¤„ç†ä¸åŒçš„æ•°æ®ç±»å‹
    switch (type) {
        case PLIST_ARRAY: {
            // æ ‡å‡†æ•°ç»„å¤„ç†
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ å¤„ç† %@ æ•°ç»„æ•°æ®", syncClass]];
            return [self processRealDataForType:dataType dataArray:entities syncClass:syncClass];
        }
        
        case PLIST_BOOLEAN: {
            // å¸ƒå°”å€¼å¯èƒ½è¡¨ç¤ºåŒæ­¥çŠ¶æ€æˆ–ç©ºæ•°æ®
            uint8_t bool_val = 0;
            plist_get_bool_val(entities, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ è¿”å›å¸ƒå°”å€¼: %s",
                             syncClass, bool_val ? "true" : "false"]];
            
            if (bool_val) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ åŒæ­¥æˆåŠŸä½†æ— æ•°æ®é¡¹", syncClass]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ åŒæ­¥å¤±è´¥æˆ–ä¸æ”¯æŒ", syncClass]];
            }
            return @[];
        }
        
        case PLIST_DICT: {
            // å­—å…¸å¯èƒ½åŒ…å«é”™è¯¯ä¿¡æ¯æˆ–çŠ¶æ€
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ è¿”å›å­—å…¸æ•°æ®ï¼Œå°è¯•è§£æ", syncClass]];
            
            // å…ˆæ£€æŸ¥å­—å…¸ä¸­çš„å†…å®¹
            uint32_t dict_size = plist_dict_get_size(entities);
            [self logMessage:[NSString stringWithFormat:@"ğŸ“Š å­—å…¸åŒ…å« %u ä¸ªé”®å€¼å¯¹", dict_size]];
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«é”™è¯¯ä¿¡æ¯
            plist_t error_node = plist_dict_get_item(entities, "Error");
            if (error_node) {
                char *error_msg = NULL;
                if (plist_get_node_type(error_node) == PLIST_STRING) {
                    plist_get_string_val(error_node, &error_msg);
                    if (error_msg) {
                        [self logMessage:[NSString stringWithFormat:@"âŒ %@ é”™è¯¯: %s", syncClass, error_msg]];
                        free(error_msg);
                    }
                }
                return @[];
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«çŠ¶æ€ä¿¡æ¯
            plist_t status_node = plist_dict_get_item(entities, "Status");
            if (status_node && plist_get_node_type(status_node) == PLIST_STRING) {
                char *status_msg = NULL;
                plist_get_string_val(status_node, &status_msg);
                if (status_msg) {
                    [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ çŠ¶æ€: %s", syncClass, status_msg]];
                    free(status_msg);
                }
            }
            
            // å¦‚æœå­—å…¸ä¸ºç©ºæˆ–åŒ…å«æœ‰ç”¨æ•°æ®ï¼Œå°è¯•å¤„ç†ä¸ºå•ä¸ªé¡¹ç›®
            if (dict_size > 0) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ å°è¯•å°† %@ å­—å…¸ä½œä¸ºæ•°æ®é¡¹å¤„ç†", syncClass]];
                SyncDataItem *item = [self createSyncItemFromPlist:entities dataType:dataType index:0];
                if (item) {
                    [self logMessage:[NSString stringWithFormat:@"âœ… æˆåŠŸåˆ›å»º %@ æ•°æ®é¡¹: %@", syncClass, item.name ?: @"æœªå‘½å"]];
                    return @[item];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"âŒ æ— æ³•ä» %@ å­—å…¸åˆ›å»ºæ•°æ®é¡¹", syncClass]];
                }
            }
            
            return @[];
        }
        
        case PLIST_STRING: {
            // å­—ç¬¦ä¸²å¯èƒ½æ˜¯é”™è¯¯æ¶ˆæ¯
            char *str_val = NULL;
            plist_get_string_val(entities, &str_val);
            if (str_val) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ è¿”å›å­—ç¬¦ä¸²: %s", syncClass, str_val]];
                free(str_val);
            }
            return @[];
        }
        
        case PLIST_UINT: {
            // æ•°å­—å¯èƒ½æ˜¯çŠ¶æ€ç 
            uint64_t uint_val = 0;
            plist_get_uint_val(entities, &uint_val);
            [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ è¿”å›æ•°å­—: %llu", syncClass, uint_val]];
            return @[];
        }
        
        default: {
            [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ è¿”å›æœªçŸ¥æ•°æ®ç±»å‹ %@ (%d)",
                             syncClass, [self stringForPlistType:type], type]];
            return @[];
        }
    }
}

// ğŸ”§ å¢å¼ºçš„é”™è¯¯å¤„ç† - æ”¹è¿›è¶…æ—¶å¤„ç†
- (void)handleReceiveError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass {
    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
    
    switch (error) {
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:[NSString stringWithFormat:@"â° %@ æ•°æ®æ¥æ”¶è¶…æ—¶ï¼Œè¿™å¯èƒ½æ˜¯æ­£å¸¸çš„ç»“æŸä¿¡å·", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:[NSString stringWithFormat:@"ğŸ”Œ %@ è¿æ¥ä¸­æ–­ï¼Œè®¾å¤‡å¯èƒ½æ–­å¼€è¿æ¥", syncClass]];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ•°æ®æ ¼å¼é”™è¯¯ï¼Œplistè§£æå¤±è´¥", syncClass]];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ æ¥æ”¶é”™è¯¯: %@", syncClass, errorDesc]];
            break;
    }
}

- (void)handleStartSyncError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass error:(NSError **)outError {
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ åœ¨å¹²å‡€è¿æ¥åä»ç„¶å‚æ•°æ— æ•ˆï¼Œè¯¥è®¾å¤‡ç¡®å®ä¸æ”¯æŒæ­¤æ•°æ®ç±»å‹çš„æ•°æ®è·å–", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"ğŸ’¡ è¿æ¥é”™è¯¯ï¼Œè®¾å¤‡å¯èƒ½å·²æ–­å¼€"];
            if (outError) {
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                    description:@"Device connection lost during sync"];
            }
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ å¯åŠ¨åŒæ­¥å¤±è´¥ï¼Œé”™è¯¯ç : %d", syncClass, error]];
            if (outError) {
                NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                    description:errorDesc];
            }
            break;
    }
    
    [self handleSyncError:error forDataType:0 operation:@"start_sync"];
}


// ğŸ”§ è·å–MobileSyncé”™è¯¯çš„æè¿°
- (NSString *)getErrorDescriptionForMobileSyncError:(mobilesync_error_t)error {
    switch (error) {
        case MOBILESYNC_E_SUCCESS:
            return @"Success";
        case MOBILESYNC_E_INVALID_ARG:
            return @"Invalid argument - check sync class name and parameters";
        case MOBILESYNC_E_PLIST_ERROR:
            return @"Plist parsing error - data format issue";
        case MOBILESYNC_E_MUX_ERROR:
            return @"Connection error - device may have disconnected";
        case MOBILESYNC_E_SSL_ERROR:
            return @"SSL error - secure connection failed";
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            return @"Receive timeout - device not responding";
        case MOBILESYNC_E_BAD_VERSION:
            return @"Version mismatch - sync protocol version not supported";
        default:
            return [NSString stringWithFormat:@"Unknown sync error: %d", error];
    }
}

// âœ… æ–°å¢ï¼šæ”¹è¿›çš„æ•°æ®å¤„ç†æ–¹æ³•ï¼Œæ›´å¥½åœ°å¤„ç†ç©ºæ•°æ®æƒ…å†µ
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ•°æ®ä¸ºç©ºï¼Œåˆ›å»ºç©ºæ•°æ®å­—å…¸", typeName]];
        
        // âœ… å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿåˆ›å»ºä¸€ä¸ªæœ‰æ•ˆçš„å­—å…¸
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ æ”¯æŒä½†å½“å‰æ— æ•°æ®", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

// âœ… æ–°å¢ï¼šæ”¹è¿›çš„å¢å¼ºæ•°æ®æ‰«ææ–¹æ³•
- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== ğŸ”§ å¼€å§‹ä¿®å¤ç‰ˆè®¾å¤‡çœŸå®æ•°æ®æ‰«æ ===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // âœ… é¦–å…ˆè·å–æ”¯æŒçš„æ•°æ®ç±»å‹
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"âŒ è·å–æ”¯æŒçš„æ•°æ®ç±»å‹å¤±è´¥: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"âŒ è®¾å¤‡ä¸æ”¯æŒä»»ä½•æ•°æ®ç±»å‹çš„é€‰æ‹©æ€§åŒæ­¥");
        return @{};
    }
    
    NSLog(@"âœ… è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // é€ä¸ªå¤„ç†æ”¯æŒçš„æ•°æ®ç±»å‹
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // åªå¤„ç†è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹
        if (!(supportedTypes & dataType)) {
            NSLog(@"â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: %@", typeName);
            continue;
        }
        
        NSLog(@"ğŸ” æ­£åœ¨è·å– %@ çš„çœŸå®æ•°æ®...", typeName);
        
        // âœ… ä½¿ç”¨æ”¹è¿›çš„æ•°æ®è·å–æ–¹æ³•
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"ğŸ“‹ %@ æ”¯æŒä½†æ— æ•°æ®: %@ é¡¹", typeName, itemCount);
            } else {
                NSLog(@"âœ… %@ è·å–æˆåŠŸ: %@ é¡¹", typeName, itemCount);
            }
        } else {
            NSLog(@"âŒ %@ è·å–å¤±è´¥æˆ–æ— å“åº”", typeName);
        }
        
        // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== ğŸ”§ ä¿®å¤ç‰ˆæ•°æ®æ‰«æå®Œæˆï¼Œå…±å¤„ç† %lu ç§æ•°æ®ç±»å‹ ===",
          (unsigned long)realData.count);
    return [realData copy];
}

#pragma mark - çœŸå®æ•°æ®å¤„ç†æ–¹æ³•

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¤„ç†éæ•°ç»„ç±»å‹çš„æƒ…å†µ
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ è¿”å›éæ•°ç»„æ•°æ®ï¼Œå¯èƒ½è¡¨ç¤ºç©ºæ•°æ®é›†", syncClass]];
        
        // å¦‚æœæ˜¯å¸ƒå°”ç±»å‹ï¼Œå¯èƒ½è¡¨ç¤ºåŒæ­¥çŠ¶æ€
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥çŠ¶æ€: %s",
                             syncClass, bool_val ? "æˆåŠŸ" : "å¤±è´¥"]];
        }
        
        return @[]; // è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯å¤±è´¥
    }
    
    // ç»§ç»­å¤„ç†æ•°ç»„æ•°æ®...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}


- (BOOL)checkDeviceCompatibility:(NSError **)error {
    if (![self isConnected]) {
        return NO;
    }
    
    // è·å–è®¾å¤‡ä¿¡æ¯
    char *device_name = NULL;
    plist_t product_version_plist = NULL;
    
    // è·å–è®¾å¤‡åç§°
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"è®¾å¤‡åç§°: %s", device_name]];
        free(device_name);
    }
    
    // è·å–iOSç‰ˆæœ¬
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &product_version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && product_version_plist) {
        char *product_version = NULL;
        plist_get_string_val(product_version_plist, &product_version);
        
        if (product_version) {
            [self logMessage:[NSString stringWithFormat:@"iOSç‰ˆæœ¬: %s", product_version]];
            
            // æ£€æŸ¥iOSç‰ˆæœ¬å…¼å®¹æ€§
            NSString *versionStr = [NSString stringWithUTF8String:product_version];
            NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
            
            if (versionComponents.count > 0) {
                NSInteger majorVersion = [versionComponents[0] integerValue];
                
                if (majorVersion < 9) {
                    [self logMessage:@"âš ï¸ iOSç‰ˆæœ¬è¿‡ä½ï¼Œå¯èƒ½ä¸æ”¯æŒé€‰æ‹©æ€§åŒæ­¥"];
                } else if (majorVersion >= 15) {
                    [self logMessage:@"ğŸ’¡ iOS 15+è®¾å¤‡ï¼Œå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†"];
                }
            }
            
            free(product_version);
        }
        
        plist_free(product_version_plist);
    }
    
    return YES;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // æå–é€šç”¨å­—æ®µ
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // æ ¹æ®æ•°æ®ç±»å‹æå–ç‰¹å®šå­—æ®µ
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // å¦‚æœæ²¡æœ‰æ ‡è¯†ç¬¦ï¼Œä½¿ç”¨ç´¢å¼•
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // å¦‚æœæ²¡æœ‰åç§°ï¼Œä½¿ç”¨é»˜è®¤åç§°
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // æå–è®°å½•ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // æå–ä¿®æ”¹æ—¶é—´
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // ä¼°ç®—æ•°æ®å¤§å°
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // é»˜è®¤å¤§å°
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å§“åå­—æ®µ
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // ç”µè¯å·ç 
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // é‚®ç®±åœ°å€
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æ—¥å†æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å¼€å§‹æ—¶é—´
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // ç»“æŸæ—¶é—´
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // ä¹¦ç­¾æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å¤‡å¿˜å½•æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å†…å®¹
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // å¤§æ¦‚ä¼°ç®—
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æé†’äº‹é¡¹æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å®ŒæˆçŠ¶æ€
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // ä¼˜å…ˆçº§
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å°è¯•å„ç§å¯èƒ½çš„åç§°å­—æ®µ
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // æ·»åŠ ä¸€äº›é€šç”¨å…ƒæ•°æ®
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

#pragma mark - é€‰æ‹©æ€§åŒæ­¥æ“ä½œ

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // å¼‚æ­¥æ‰§è¡ŒåŒæ­¥æ“ä½œ
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // åˆ†è§£æ•°æ®ç±»å‹ä¸ºå•ç‹¬çš„ç±»å‹
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // æŒ‰æ•°æ®ç±»å‹åˆ†ç»„
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // å¯¹æ¯ç§æ•°æ®ç±»å‹æ‰§è¡ŒåŒæ­¥
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // è¿™é‡Œå¯ä»¥å®ç°æ›´ç»†ç²’åº¦çš„é¡¹ç›®åŒæ­¥é€»è¾‘
        // ç›®å‰å…ˆä½¿ç”¨æ•°æ®ç±»å‹çº§åˆ«çš„åŒæ­¥
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // åˆ›å»ºå¤‡ä»½ç›®å½•
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - æ“ä½œæ§åˆ¶

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - åŒæ­¥æ“ä½œå®ç°

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // æ ¹æ®æ–¹å‘æ‰§è¡Œä¸åŒçš„æ“ä½œ
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // åŒå‘åŒæ­¥æš‚æ—¶ä¸å®ç°
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // è·å–æ•°æ®é¡¹
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // åˆ›å»ºæ•°æ®ç±»å‹ç›®å½•
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // ä¿å­˜æ•°æ®é¡¹ä¿¡æ¯
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // ä¿å­˜å¤‡ä»½å…ƒæ•°æ®
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - æ•°æ®ç±»å‹å·¥å…·æ–¹æ³•

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æœ¬åœ°åŒ–æ”¯æŒ
    // ç›®å‰è¿”å›è‹±æ–‡ç‰ˆæœ¬
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
}

#pragma mark - ä¾¿æ·æ–¹æ³•

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // è®¾ç½®å®Œæˆå›è°ƒæ¥æ•è·ç»“æœ
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - æ•°æ®éªŒè¯å’Œæ¢å¤

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // å°è¯•è¯»å–æ–‡ä»¶ä»¥éªŒè¯æ ¼å¼
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // å‚æ•°éªŒè¯
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // ç¡®ä¿æ˜¯ç›®å½•è€Œä¸æ˜¯æ–‡ä»¶
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // è·å–åŸºæœ¬ä¿¡æ¯ - æ·»åŠ é”™è¯¯å¤„ç†
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // è®¾ç½®é»˜è®¤å€¼
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // æ‰«ææ•°æ®ç±»å‹
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œé¿å…å†…å­˜ç´¯ç§¯
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // æ£€æŸ¥items.plistæ˜¯å¦å­˜åœ¨
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // å°è¯•è¯»å–itemsæ•°æ®
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // è®¡ç®—è¯¥æ•°æ®ç±»å‹çš„å¤§å°
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // è®¾ç½®æ±‡æ€»ä¿¡æ¯
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // æ·»åŠ å¤‡ä»½ç»Ÿè®¡ä¿¡æ¯
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - éªŒè¯å’Œé”™è¯¯å¤„ç†

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¢å¼ºçš„ç±»å‹æ£€æŸ¥å’Œæ—¥å¿—
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // å¦‚æœä¸æ˜¯æ•°ç»„ï¼Œå°è¯•å¤„ç†å…¶ä»–å¯èƒ½çš„ç±»å‹
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // å¯èƒ½è¡¨ç¤ºæ²¡æœ‰æ•°æ®æˆ–æ“ä½œå¤±è´¥
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // å¦‚æœæ˜¯trueï¼Œå¯èƒ½è¡¨ç¤ºæˆåŠŸä½†æ— æ•°æ®
        }
        
        [self logMessage:[NSString stringWithFormat:@"âš ï¸ Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

#pragma mark - æ–°å¢çš„è¾…åŠ©æ–¹æ³•

// ğŸ”§ è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥ - ä¿®å¤ç‰ˆæœ¬
- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"ğŸ“± è®¾å¤‡æœªè¿æ¥æˆ–lockdownæœªåˆå§‹åŒ–"];
        return;
    }
    
    // ä¿®å¤1ï¼šæ­£ç¡®è·å–è®¾å¤‡åç§°
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è®¾å¤‡åç§°: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è·å–è®¾å¤‡åç§°å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤2ï¼šæ­£ç¡®è·å–iOSç‰ˆæœ¬
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ“± iOSç‰ˆæœ¬: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"âš ï¸ iOSç‰ˆæœ¬è¿‡ä½ï¼Œå¯èƒ½ä¸æ”¯æŒé€‰æ‹©æ€§åŒæ­¥"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"ğŸ’¡ iOS 15+è®¾å¤‡ï¼Œæ•°æ®æ ¼å¼å¯èƒ½æœ‰å˜åŒ–"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ iOS %ld è®¾å¤‡ï¼Œå…¼å®¹æ€§è‰¯å¥½", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è·å–iOSç‰ˆæœ¬å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤3ï¼šæ­£ç¡®è·å–è®¾å¤‡å‹å·
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ“± è®¾å¤‡å‹å·: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è·å–è®¾å¤‡å‹å·å¤±è´¥: %d", ret]];
    }
}

// ğŸ”§ Plistç±»å‹è½¬æ¢ä¸ºå¯è¯»å­—ç¬¦ä¸²
- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}


- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // æ ¹æ®é”™è¯¯ç±»å‹é‡‡å–ä¸åŒçš„å¤„ç†ç­–ç•¥
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // å°è¯•é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æ”¯æŒæ­¤æ•°æ®ç±»å‹
    return [self isDataTypeSupported:dataType];
}

#pragma mark - è°ƒè¯•å’Œè¯Šæ–­å·¥å…·

- (void)diagnoseDeviceSyncCapabilities {
    [self logMessage:@"=== Device Sync Capabilities Diagnosis ==="];
    
    if (![self isConnected]) {
        [self logMessage:@"âŒ Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"ğŸ“± Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"âœ…" : @"âŒ";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"ğŸ“Š Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
    [self logMessage:@"=== End Diagnosis ==="];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount)
            };
        }
    }
    
    return info;
}

#pragma mark - ç§æœ‰æ–¹æ³•å®ç°

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - å·¥å…·æ–¹æ³•

- (void)logMessage:(NSString *)message {
    NSString *timestamp = [self getCurrentTimestamp];
    NSString *logMessage = [NSString stringWithFormat:@"[%@] [BackupOptionTask] %@", timestamp, message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}



// âœ… æ ¼å¼åŒ–æ–‡ä»¶å¤§å°æ–¹æ³• - å¦‚æœä¸å­˜åœ¨çš„è¯
- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}



// getDataItemsSimplified æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"è·å–ç®€åŒ–æ•°æ®é¡¹ - ç±»å‹: %@, åŒæ­¥ç±»: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // éªŒè¯å‚æ•°
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"åŒæ­¥ç±»å‚æ•°ä¸èƒ½ä¸ºç©º"];
        }
        return @[];
    }
    
    // ç¡®ä¿è®¾å¤‡è¿æ¥
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"è®¾å¤‡æœªè¿æ¥"];
        }
        return @[];
    }
    
    // âœ… å…³é”®ä¿®å¤ï¼šç§»é™¤é‡å¤çš„æ”¯æŒæ£€æŸ¥
    // ä¸Šå±‚ä»£ç å·²ç»é€šè¿‡ getSupportedDataTypes éªŒè¯è¿‡æ”¯æŒæ€§ï¼Œé¿å…é‡å¤æ£€æŸ¥å¯¼è‡´çŠ¶æ€å†²çª
    [self logMessage:[NSString stringWithFormat:@"è·³è¿‡é‡å¤æ”¯æŒæ£€æŸ¥ï¼Œç›´æ¥è·å– %@ æ•°æ®", syncClass]];
    
    // ç›´æ¥è°ƒç”¨æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"âœ… æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ•°æ®ä¸ºç©ºæˆ–è·å–å¤±è´¥", syncClass]];
    }
    
    return items ?: @[];
}

@end




//
//  DeviceBackupRestore.m
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import "DeviceBackupRestore.h"
#import "DefaultBackupViewController.h"
#import "BackupProgressViewController.h"
#import "EncryptedSettingsViewController.h"
#import "RestoreProgressViewController.h"
#import "DeviceManager.h" // å¼•å…¥è®¾å¤‡ç®¡ç†æ¨¡å—
#import "DatalogsSettings.h"//æ—¥å¿—ä¿å­˜è·¯å¾„å…¨å±€
#import "LanguageManager.h" //è¯­è¨€
#import "CurrentHistoryController.h" //å†å²æ“ä½œè®°å½•
#import "SidebarViewController.h"
#import "LogUtility.h" // è‡ªå®šä¹‰æ—¥å¿—å‡½æ•°LogWithTimestampï¼Œè‡ªåŠ¨æ·»åŠ æ—¶é—´æˆ³
#import "LogManager.h" //å…¨å±€æ—¥å¿—åŒºåŸŸ
#import "UserManager.h" //ç™»å½•
#import "DataBaseManager.h" //æ•°æ®å‚¨å­˜ç®¡ç†
#import "BackupTask.h"
#import "BackupOptionTask.h"

@interface DeviceBackupRestore () <NSTableViewDataSource, NSTableViewDelegate>

// å­è§†å›¾æ§åˆ¶å™¨
@property (strong) DefaultBackupViewController *defaultBackupViewController;
@property (strong) BackupProgressViewController *backupProgressViewController;
@property (strong) EncryptedSettingsViewController *encryptedSettingsViewController;
@property (strong) RestoreProgressViewController *restoreProgressViewController;
@property (strong) NSViewController *currentViewController;

// è¿›åº¦å±æ€§çš„ç§æœ‰è®¾ç½®å™¨
@property (nonatomic, readwrite) double backupProgress;
@property (nonatomic, readwrite) double restoreProgress;
@property (nonatomic, readwrite, getter=isBackupInProgress) BOOL backupInProgress;
@property (nonatomic, readwrite, getter=isRestoreInProgress) BOOL restoreInProgress;

// å¤‡ä»½ç›¸å…³é…ç½®
@property (nonatomic, strong) NSString *backupLocationPath;
@property (nonatomic, assign) BOOL backupIsEncrypted;

// å¤‡ä»½æ•°æ®
@property (nonatomic, strong) NSMutableArray *backupItems;

// âœ… æ–°å¢ï¼šé€‰æ‹©æ€§å¤‡ä»½ç›¸å…³å±æ€§
@property (nonatomic, strong) BackupOptionTask *backupOptionTask;
@property (nonatomic, strong) NSWindow *selectiveBackupWindow;
@property (nonatomic, strong) NSMutableArray<NSButton *> *dataTypeCheckboxes;
@property (nonatomic, assign) BackupDataType selectedDataTypes;
@property (nonatomic, strong) NSMutableArray<SyncDataItem *> *availableDataItems;


@property (nonatomic, assign) BackupDataType supportedDataTypes;

// âœ… é€‰æ‹©æ€§å¤‡ä»½UIæ§ä»¶
@property (nonatomic, strong) NSButton *selectiveBackupButton;
@property (nonatomic, strong) NSProgressIndicator *selectiveBackupProgress;
@property (nonatomic, strong) NSTextField *selectiveBackupStatusLabel;

// âœ… æ–°å¢ï¼šä¿å­˜é€‰æ‹©æ€§å¤‡ä»½å‰çš„è®¾å¤‡ä¿¡æ¯
@property (nonatomic, strong) NSString *savedDeviceIDForSelectiveBackup;
@property (nonatomic, strong) NSDictionary *savedDeviceInfoForSelectiveBackup;


// é€‰æ‹©æ€§æ¢å¤ç›¸å…³å±æ€§
@property (nonatomic, strong) NSWindow *selectiveRestoreWindow;
@property (nonatomic, strong) NSTabView *restoreTabView;
@property (nonatomic, strong) NSTableView *backupListTableView;
@property (nonatomic, strong) NSTableView *dataTypeTableView;
@property (nonatomic, strong) NSMutableArray *availableBackups;
@property (nonatomic, strong) NSMutableArray *restoreableDataTypes;
@property (nonatomic, strong) NSDictionary *selectedBackupInfo;
@property (nonatomic, strong) NSProgressIndicator *restoreProgressBar;
@property (nonatomic, strong) NSTextField *restoreStatusLabel;
@property (nonatomic, assign) BackupDataType selectedRestoreDataTypes;
@property (nonatomic, strong) NSMutableDictionary *deviceScannedData;

@end

@implementation DeviceBackupRestore


#pragma mark - å•ä¾‹å®ç°

+ (instancetype)sharedInstance {
    static DeviceBackupRestore *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}


#pragma mark - åˆå§‹åŒ–æ–¹æ³•

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"DeviceBackupRestore: viewDidLoad");
    
    // åˆå§‹åŒ–å½“å‰å¤‡ä»½æ–‡ä»¶åˆ—è¡¨
    self.currentBackupFiles = [NSMutableArray array];
        
    // åˆå§‹åŒ– NSPopUpButton
    [self populateDevicePopUpButton];

    //å½“å‰è®¾å¤‡åˆ—è¡¨ä¿¡æ¯
    [self getCurrentConnectedDevicesFromHistorylist];
    
    // åˆå§‹åŒ–æ•°æ®
    self.backupItems = [NSMutableArray array];

    NSLog(@"DeviceBackupRestore: å·²åŠ è½½æ ·æœ¬å¤‡ä»½é¡¹ç›®: %luä¸ª", (unsigned long)self.backupItems.count);
    
    // åˆå§‹åŒ–å±æ€§
    self.backupProgress = 0.0;
    self.restoreProgress = 0.0;
    self.backupInProgress = NO;
    self.restoreInProgress = NO;
    
    // åˆå§‹åŒ–å¤‡ä»½è®¾ç½®
    self.backupLocationPath = NSHomeDirectory();
    self.backupIsEncrypted = NO;
    NSLog(@"DeviceBackupRestore: é»˜è®¤å¤‡ä»½ä½ç½®: %@", self.backupLocationPath);
    
    // åˆå§‹åŒ–è§†å›¾æ§åˆ¶å™¨
    [self initializeViewControllers];
    
    // æ˜¾ç¤ºé»˜è®¤è§†å›¾
    [self displayContentController:self.defaultBackupViewController];
    
    self.collectedLogs = [[NSMutableString alloc] init]; // åˆå§‹åŒ–æ—¥å¿—ç¼“å­˜
    
    // âœ… æ–°å¢ï¼šåˆå§‹åŒ–é€‰æ‹©æ€§å¤‡ä»½åŠŸèƒ½
    [self initializeSelectiveBackupFeatures];
    
    NSLog(@"DeviceBackupRestore: å·²æ˜¾ç¤ºé»˜è®¤å¤‡ä»½è§†å›¾");
}

- (void)viewDidAppear {
    [super viewDidAppear];
    NSLog(@"DeviceBackupRestore: viewDidAppear");
}


#pragma mark - å¡«å…… NSPopUpButton è¡¨å¤´å½“å‰è¿æ¥çš„è®¾å¤‡åˆ—è¡¨
- (void)populateDevicePopUpButton {
    NSLog(@"[DEBUG] å¼€å§‹æ‰§è¡Œ populateDevicePopUpButton æ–¹æ³•");
    
    NSLog(@"[DEBUG] FlasherTabsController çš„ deviceUDID: %@, deviceECID: %@", self.deviceUDID, self.deviceECID);
    
    NSDictionary *allDevicesData = [self getCurrentConnectedDevicesFromHistorylist];
    if (!allDevicesData) {
        NSLog(@"[ERROR] æ— æ³•æå–è®¾å¤‡ä¿¡æ¯ï¼Œå› ä¸º Plist æ–‡ä»¶è¯»å–å¤±è´¥ã€‚");
        return;
    }
    
    // æ¸…ç©ºå½“å‰çš„èœå•é¡¹
    [self.devicePopUpButton removeAllItems];
    
    // æ·»åŠ ä¸€ä¸ªé»˜è®¤çš„é€‰é¡¹
    NSString *pleaseSelectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseSelectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Select Device"];
    [self.devicePopUpButton addItemWithTitle:pleaseSelectDeviceTitle];
    
    BOOL hasAvailableDevices = NO;
    
    // ç¡®ä¿ NSPopUpButton å·²å¸ƒå±€å®Œæˆï¼Œä»¥è·å–æ­£ç¡®çš„å®½åº¦
    [self.devicePopUpButton layoutSubtreeIfNeeded];
    
    // è·å– NSPopUpButton çš„å®½åº¦
    CGFloat popupWidth = self.devicePopUpButton.bounds.size.width;
    
    // è®¾å®šåˆ¶è¡¨ç¬¦åœ¨å®½åº¦çš„85%ï¼Œç•™å‡º15%çš„è¾¹è·
    CGFloat tabLocation = popupWidth * 0.90;
    
    // åˆ›å»ºæ®µè½æ ·å¼å¹¶è®¾ç½®åˆ¶è¡¨ç¬¦ä½ç½®
    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    NSTextTab *rightTab = [[NSTextTab alloc] initWithType:NSRightTabStopType location:tabLocation];
    [paragraphStyle setTabStops:@[rightTab]];
    [paragraphStyle setDefaultTabInterval:tabLocation];
    
    // è®¾ç½®å­—ä½“å¤§å°
    CGFloat fontSize = 12.0;
    
    // éå†æ‰€æœ‰è®¾å¤‡æ•°æ®
    for (NSString *key in allDevicesData) {
        NSDictionary *device = allDevicesData[key];
        
        // è·å–è®¾å¤‡è¿æ¥çŠ¶æ€å’Œæ¨¡å¼
        BOOL isConnected = [device[@"IsConnected"] boolValue];
        NSString *deviceMode = device[@"Mode"];
        
        // æ’é™¤æœªè¿æ¥çš„è®¾å¤‡æˆ–æ¨¡å¼ä¸º "-" çš„è®¾å¤‡
        if (!isConnected || [deviceMode isEqualToString:@"-"]) {
            NSLog(@"[INFO] æ’é™¤è®¾å¤‡ - OfficialName: %@, IsConnected: %@, Mode: %@",
                  device[@"OfficialName"] ?: @"Unknown Name",
                  isConnected ? @"YES" : @"NO",
                  deviceMode ?: @"Unknown Mode");
            continue; // è·³è¿‡å½“å‰å¾ªç¯ï¼Œå¤„ç†ä¸‹ä¸€ä¸ªè®¾å¤‡
        }
        
        NSString *officialName = device[@"OfficialName"] ?: @"Unknown Name";
        NSString *udid = device[@"UDID"];
        NSString *ecid = device[@"ECID"] ?: @"Unknown ECID";
        NSString *type = device[@"TYPE"];
        
        NSString *idString;
        NSString *uniqueKey;
        
        if (udid && udid.length > 0) {
            idString = [NSString stringWithFormat:@"UDID: %@", [udid stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
            uniqueKey = udid;
        } else if (ecid && ecid.length > 0) {
            idString = [NSString stringWithFormat:@"ECID: %@", [ecid stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
            uniqueKey = ecid;
        } else {
            idString = @"Unknown ID";
            uniqueKey = key; // ä½¿ç”¨ plist ä¸­çš„ key ä½œä¸ºå¤‡ç”¨
        }
        
        // è·å–æœ¬åœ°åŒ–åçš„ mode
        NSString *localizedMode = [self getLocalizedDeviceModeForDevice:device];
        
        // ä½¿ç”¨åˆ¶è¡¨ç¬¦åˆ†éš”å·¦ä¾§å’Œå³ä¾§å†…å®¹ï¼Œä½¿ç”¨æœ¬åœ°åŒ–åçš„ mode
        // ç»“æ„: å·¦ä¾§ä¿¡æ¯ \t å³ä¾§ä¿¡æ¯
        NSString *rawString = [NSString stringWithFormat:@"  %@  -  %@ \t  %@", localizedMode, officialName, type];
        
        // åˆ›å»ºå±æ€§å­—ç¬¦ä¸²
        NSDictionary *attributes = @{
            NSParagraphStyleAttributeName: paragraphStyle,
            NSFontAttributeName: [NSFont systemFontOfSize:fontSize]
        };
        NSAttributedString *attrTitle = [[NSAttributedString alloc] initWithString:rawString attributes:attributes];
        
        // åˆ›å»º NSMenuItem å¹¶è®¾ç½® attributedTitle
        NSMenuItem *item = [[NSMenuItem alloc] initWithTitle:rawString action:nil keyEquivalent:@""];
        item.attributedTitle = attrTitle;
        item.representedObject = uniqueKey;
               
        // æ£€æŸ¥å½“å‰è®¾å¤‡æ˜¯å¦ä¸ºé€‰ä¸­è®¾å¤‡
        BOOL isSelected = ([uniqueKey isEqualToString:self.deviceUDID] || [uniqueKey isEqualToString:self.deviceECID]);
        if (isSelected) {
            [self.devicePopUpButton selectItem:item];
            self.currentDeviceType = type; // è®¾ç½®å½“å‰ deviceType
            self.currentDeviceMode = deviceMode;
            NSLog(@"[DEBUG] å·²é€‰ä¸­è®¾å¤‡ä¿¡æ¯: %@  Type: %@  Mode: %@",self.deviceOfficialName, self.currentDeviceType, self.currentDeviceMode);
            
            [self lockDeviceWithInfo:uniqueKey officialName:self.deviceOfficialName type:self.currentDeviceType mode:self.currentDeviceMode];
            NSLog(@"[DEBUG] å·²é€‰ä¸­è®¾å¤‡å¹¶é”å®š: %@  Type: %@  Mode: %@",self.deviceOfficialName, self.currentDeviceType, self.currentDeviceMode);
        }
               
        // æ·»åŠ åˆ° NSPopUpButton
        [self.devicePopUpButton.menu addItem:item];
        
        hasAvailableDevices = YES;
    }
    
    // å¦‚æœæ²¡æœ‰å¯ç”¨è®¾å¤‡ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
    if (!hasAvailableDevices) {
        NSString *pleaseConnectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseConnectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Connect Device"];
        [self.devicePopUpButton addItemWithTitle:pleaseConnectDeviceTitle];
    }
    

    // è‡ªåŠ¨é€‰ä¸­å¯¹åº”çš„è®¾å¤‡é¡¹ï¼ˆæ ¹æ® deviceUDID æˆ– deviceECIDï¼‰
    [self AutoSelectDeviceInPopUpButton];
    
    NSLog(@"[DEBUG] populateDevicePopUpButton æ–¹æ³•æ‰§è¡Œå®Œæˆ");
}

#pragma mark - æ‰‹åŠ¨é€‰æ‹©åè·å–å½“å‰é€‰æ‹©çš„è®¾å¤‡ä¿¡æ¯
- (IBAction)devicePopUpButtonChanged:(id)sender {
    // è·å–å½“å‰é€‰ä¸­çš„ NSMenuItem
    NSMenuItem *selectedItem = [self.devicePopUpButton selectedItem];
    
    // ä» selectedItem ä¸­è·å–å¯¹åº”çš„è®¾å¤‡å”¯ä¸€æ ‡è¯†ç¬¦
    NSString *selectedDeviceID = selectedItem.representedObject;
    
    // é€šè¿‡å”¯ä¸€æ ‡è¯†ç¬¦æ‰¾åˆ°è®¾å¤‡çš„è¯¦ç»†ä¿¡æ¯ï¼ˆæ¯”å¦‚ä»ç¼“å­˜çš„æ•°æ®ä¸­æŸ¥æ‰¾ï¼‰
    NSDictionary *selectedDeviceInfo = [self getDeviceInfoByID:selectedDeviceID];
    
    // æ‰“å°è®¾å¤‡ä¿¡æ¯æˆ–æ‰§è¡Œç›¸å…³æ“ä½œ
    NSLog(@"[INFO] æ‰‹åŠ¨é€‰ä¸­è®¾å¤‡çš„è¯¦ç»†ä¿¡æ¯ï¼š%@ é€‰ä¸­çš„ID %@ ", selectedDeviceInfo, selectedDeviceID);

    NSString *deviceOfficialName = selectedDeviceInfo[@"OfficialName"] ?: @"Unknown Name";
    NSString *deviceUDID = selectedDeviceInfo[@"UDID"];
    NSString *deviceECID = selectedDeviceInfo[@"ECID"] ?: @"Unknown ECID";
    NSString *deviceTYPE = selectedDeviceInfo[@"TYPE"];
    NSString *devicePairStatus = selectedDeviceInfo[@"IsPair"];
    //NSString *deviceModel = selectedDeviceInfo[@"MODEL"];
    NSString *deviceMode = selectedDeviceInfo[@"Mode"];
    
    
    NSLog(@"[INFO] æ‰‹åŠ¨é€‰ä¸­è®¾å¤‡çš„åç§°ï¼š%@ æ¨¡å¼ï¼š%@ ç±»å‹ï¼š%@ åŒ¹é…ï¼š%@", deviceOfficialName, deviceMode, deviceTYPE, devicePairStatus);
    
    NSString *idString;
    NSString *uniqueKey;
    
    if (deviceUDID && deviceUDID.length > 0) {
        idString = [NSString stringWithFormat:@"UDID: %@", [deviceUDID stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
        uniqueKey = deviceUDID;
    } else if (deviceECID && deviceECID.length > 0) {
        idString = [NSString stringWithFormat:@"ECID: %@", [deviceECID stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
        uniqueKey = deviceECID;
    } else {
        idString = @"Unknown ID";
        uniqueKey = selectedDeviceID; // ä½¿ç”¨ plist ä¸­çš„ key ä½œä¸ºå¤‡ç”¨
    }
    
    
    if (deviceTYPE) {
        // æ›´æ–°å½“å‰è®¾å¤‡çš„ deviceType
        self.currentDeviceType = deviceTYPE;
        NSLog(@"å½“å‰è®¾å¤‡çš„ deviceType: %@", self.currentDeviceType);

        // åœ¨é€‰æ‹©æ–°è®¾å¤‡ä¹‹å‰å–æ¶ˆæ‰€æœ‰ä¸‹è½½ä»»åŠ¡
      //  [self cancelAllDownloadTasks];

        
        // é”å®šå¹¶æŒä¹…åŒ–è®¾å¤‡ä¿¡æ¯
        [self lockDeviceWithInfo:uniqueKey officialName:deviceOfficialName type:deviceTYPE mode:deviceMode];
        
        
        // âœ… ä¿®æ”¹ï¼šç›´æ¥ä¼ é€’è®¾å¤‡ä¿¡æ¯ç»™å¤‡ä»½è§†å›¾æ§åˆ¶å™¨
        if (self.backupProgressViewController) {
            NSLog(@"DeviceBackupRestore: ç›´æ¥ä¼ é€’è®¾å¤‡ä¿¡æ¯ç»™å¤‡ä»½è§†å›¾æ§åˆ¶å™¨");
            
            // åˆ›å»ºè®¾å¤‡ä¿¡æ¯å­—å…¸
            NSDictionary *deviceInfoToPass = @{
                @"uniqueKey": uniqueKey,
                @"officialName": deviceOfficialName,
                @"type": deviceTYPE,
                @"mode": deviceMode,
                @"udid": deviceUDID ?: @"",
                @"ecid": deviceECID ?: @""
            };
            
            // ç›´æ¥è°ƒç”¨åŠ è½½æ–¹æ³•
            [self.backupProgressViewController loadBackupDataForDevice:uniqueKey deviceInfo:deviceInfoToPass];
        } else {
            NSLog(@"DeviceBackupRestore: å¤‡ä»½è§†å›¾æ§åˆ¶å™¨ä¸ºç©º");
        }
        
        // ç¤ºä¾‹æ“ä½œï¼šæ˜¾ç¤ºè®¾å¤‡ä¿¡æ¯
        NSString *logdeviceOfficialName = [[LanguageManager sharedManager] localizedStringForKeys:@"CurrentDeviceSwitchedto" inModule:@"Flasher" defaultValue:@"The device has been switched to: %@, %@\n"];
        
        // åœ¨ logdeviceOfficialName å‰é¢è¿½åŠ  [warning]
        logdeviceOfficialName = [NSString stringWithFormat:@"[WAR] %@", logdeviceOfficialName];
       
        NSString *choosedDeviceMessage = [NSString stringWithFormat:logdeviceOfficialName, deviceOfficialName, deviceTYPE];
        
        [self showLogsWithMessage:choosedDeviceMessage];//è®¾å¤‡åˆ‡æ¢æ—¥å¿—

    } else {
        NSLog(@"[ERROR] æ— æ³•æ ¹æ® uniqueKey è·å–è®¾å¤‡ä¿¡æ¯: %@", uniqueKey);
    }
    
    //åˆ¤æ–­æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
    NSLog(@"æ‰‹åŠ¨é€‰æ‹©åå½“å‰è®¾å¤‡æ¨¡å¼: %@", deviceMode);

    if ([deviceMode isEqualToString:@"Normal"]) {
        [self.backupProgressViewController checkAndLoadExistingBackupData];
    }
    
    // æ ¹æ®è®¾å¤‡ç±»å‹åˆ¤æ–­ å¦‚æœæ˜¯Watch / Mac ç±»å‹ åˆ™ä½œç›¸å…³åˆ¤æ–­
    if ([deviceTYPE.lowercaseString containsString:@"watch"]) {
        
        /*
        // å¦‚æœè®¾å¤‡ç±»å‹ä¸º "watch"ï¼Œç¦ç”¨ autoOfficialFirmwareCheckbox
        if (self.autoOfficialFirmwareCheckbox.state == NSControlStateValueOn) {
            // å¦‚æœå¤é€‰æ¡†å·²ç»é€‰ä¸­ï¼Œå–æ¶ˆé€‰æ‹©
            self.autoOfficialFirmwareCheckbox.state = NSControlStateValueOff;
        }
        self.autoOfficialFirmwareCheckbox.enabled = NO;
        [self.autoOfficialFirmwareCheckbox setNeedsDisplay:YES]; // å¼ºåˆ¶åˆ·æ–°*/
    } else {
        /*
        // å¦‚æœè®¾å¤‡ç±»å‹ä¸æ˜¯ "watch"ï¼Œå¯ç”¨ autoOfficialFirmwareCheckbox
        self.autoOfficialFirmwareCheckbox.enabled = YES;
        [self.autoOfficialFirmwareCheckbox setNeedsDisplay:YES]; // å¼ºåˆ¶åˆ·æ–°*/
    }
}

- (NSDictionary *)getDeviceInfoByID:(NSString *)deviceID {
    // ç¤ºä¾‹ï¼šä»å½“å‰å·²åŠ è½½çš„è®¾å¤‡åˆ—è¡¨ä¸­æ‰¾åˆ°è®¾å¤‡è¯¦æƒ…
    NSDictionary *allDevicesData = [self getCurrentConnectedDevicesFromHistorylist];
    return allDevicesData[deviceID];
}

#pragma mark - è·å–/ è¯»å–å½“å‰è®¾å¤‡çš„æ–‡ä»¶
- (NSDictionary *)getCurrentConnectedDevicesFromHistorylist {
    NSLog(@"[DEBUG] åŠ è½½ CurrentDevices.plist");
    NSString *mfcDataPath = [DatalogsSettings mfcDataDirectory];
    NSString *cachesDirectory = [mfcDataPath stringByAppendingPathComponent:@"Caches"];
    NSString *plistPath = [cachesDirectory stringByAppendingPathComponent:@"CurrentDevices.plist"];
   
    // æ£€æŸ¥ Plist æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) {
        NSLog(@"[ERROR] Plist æ–‡ä»¶ä¸å­˜åœ¨: %@", plistPath);
        return nil;
    }
    
    // è¯»å– Plist æ–‡ä»¶å†…å®¹
    NSDictionary *allDevicesData = [NSDictionary dictionaryWithContentsOfFile:plistPath];
    if (!allDevicesData) {
        NSLog(@"[ERROR] æ— æ³•è¯»å– Plist æ–‡ä»¶å†…å®¹: %@", plistPath);
        return nil;
    }
    
    return allDevicesData;
}

#pragma mark -  è·å–å½“å‰è®¾å¤‡çš„æ¨¡å¼ï¼Œå¹¶è¿”å›æœ¬åœ°åŒ–åçš„å­—ç¬¦ä¸²
- (NSString *)getLocalizedDeviceModeForDevice:(NSDictionary *)device {
    LanguageManager *languageManager = [LanguageManager sharedManager];
    
    // å®šä¹‰è®¾å¤‡æ¨¡å¼åˆ°æœ¬åœ°åŒ–é”®çš„æ˜ å°„
    NSDictionary<NSString *, NSString *> *modeLocalizationKeys = @{
        @"Normal" : @"isNormalModeTitle",
        @"Recovery" : @"isRecoveryModeTitle",
        @"DFU" : @"isDFUModeTitle",
        @"WiFi" : @"isWiFiModeTitle",
        @"WTF" : @"isWTFModeTitle"
    };
    
    // è·å–è®¾å¤‡çš„åŸå§‹æ¨¡å¼
    NSString *originalMode = device[@"Mode"];
    
    // è·å–å¯¹åº”çš„æœ¬åœ°åŒ–é”®
    NSString *localizationKey = modeLocalizationKeys[originalMode];
    
    // å¦‚æœæ‰¾åˆ°å¯¹åº”çš„æœ¬åœ°åŒ–é”®ï¼Œåˆ™è¿›è¡Œæœ¬åœ°åŒ–
    if (localizationKey) {
        NSString *localizedMode = [languageManager localizedStringForKeys:localizationKey inModule:@"DeviceModes" defaultValue:originalMode];
        
        // æ£€æŸ¥æœ¬åœ°åŒ–æ˜¯å¦æˆåŠŸï¼ˆå³ localizedMode ä¸ç­‰äº defaultValueï¼‰
        if ([localizedMode isEqualToString:originalMode]) {
            NSLog(@"[DEBUG] æ¨¡å¼ç›¸åŒï¼Œæ— é¡»è¿›è¡Œæœ¬åœ°åŒ–. æœ¬åœ°åŒ–æ¨¡å¼: %@ï¼Œä½¿ç”¨è®¾å¤‡åŸå§‹æ¨¡å¼: %@", localizedMode, originalMode);
        }
        
        return localizedMode;
    } else {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„æœ¬åœ°åŒ–é”®ï¼Œè¿”å›åŸå§‹æ¨¡å¼å¹¶è®°å½•æ—¥å¿—
        NSLog(@"[DEBUG] æœªçŸ¥æ¨¡å¼ï¼Œæœ¬åœ°åŒ–å¤±è´¥ï¼Œä½¿ç”¨è®¾å¤‡åŸå§‹æ¨¡å¼: %@", originalMode);
        return originalMode;
    }
}


#pragma mark -é”å®šè®¾å¤‡å¹¶æŒä¹…åŒ–è®¾å¤‡ä¿¡æ¯ åŒæ­¥æ›´æ–°
- (void)lockDeviceWithInfo:(NSString *)uniqueKey officialName:(NSString *)officialName type:(NSString *)type mode:(NSString *)mode {
    // æ›´æ–°é”å®šçš„è®¾å¤‡ä¿¡æ¯
    self.lockedDeviceID = uniqueKey;
    self.deviceType = type;
    self.deviceMode = mode;

    // åˆ›å»ºè®¾å¤‡ä¿¡æ¯å­—å…¸
    NSDictionary *lockedDeviceInfo = @{
        @"uniqueKey": uniqueKey,
        @"officialName": officialName ?: @"",
        @"type": type ?: @"",
        @"mode": mode ?: @""
    };

    // æŒä¹…åŒ–é”å®šçš„è®¾å¤‡ä¿¡æ¯
    [self setLockedDeviceInfo:lockedDeviceInfo];
    
    // è®°å½•é”å®šè®¾å¤‡çš„å…¶ä»–ä¿¡æ¯ï¼Œå¦‚ officialName å’Œ type ç­‰
    NSLog(@"[INFO] è®¾å¤‡å·²é”å®š - uniqueKey: %@, officialName: %@, type: %@, æ¨¡å¼: %@", uniqueKey, officialName, type, mode);

    // éªŒè¯è®¾å¤‡ä¿¡æ¯åŒæ­¥
    NSDictionary *syncedDeviceInfo = [self getLockedDeviceInfo];
    NSLog(@"[INFO] é”å®šè®¾å¤‡åŒæ­¥ä¿¡æ¯ - %@", syncedDeviceInfo);
}


#pragma mark - ä»å†…å­˜è·å–é”å®šçš„è®¾å¤‡ID
- (NSString *)getLockedDeviceID {
    return self.lockedDeviceID;
}

#pragma mark - è®¾å¤‡é”å®šä¿¡æ¯å­˜å…¥å†…å­˜
- (void)setLockedDeviceID:(NSString *)lockedDeviceID {
    _lockedDeviceID = lockedDeviceID;
}

#pragma mark - ä»å†…å­˜è·å–å·²é”å®šçš„è®¾å¤‡ä¿¡æ¯
- (NSDictionary *)getLockedDeviceInfo {
    return self.LockedDeviceInfo;
}

#pragma mark - è®¾å¤‡é”å®šä¿¡æ¯å­˜å…¥å†…å­˜ï¼ˆå­—å…¸ï¼‰
- (void)setLockedDeviceInfo:(NSDictionary *)LockedDeviceInfo {
    _LockedDeviceInfo = LockedDeviceInfo;
}


#pragma mark -  è¾…åŠ©æ–¹æ³•ï¼šæ ¹æ® deviceUDID æˆ– deviceECID è‡ªåŠ¨é€‰ä¸­å¯¹åº”çš„è®¾å¤‡é¡¹
- (void)AutoSelectDeviceInPopUpButton {
    BOOL found = NO;
    NSString *selectedDeviceID = nil;
    
    // åœ¨æ‰§è¡Œå›ºä»¶æ“ä½œä¹‹å‰ç§»é™¤ deviceListDidChange ç›‘å¬
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"DeviceListChangedNotification" object:nil];
    
    // ä¼˜å…ˆæ ¹æ® deviceUDID è¿›è¡ŒåŒ¹é…
    if (self.deviceUDID && self.deviceUDID.length > 0) {
        for (NSMenuItem *item in self.devicePopUpButton.menu.itemArray) {
            if ([item.representedObject isEqualToString:self.deviceUDID]) {
                [self.devicePopUpButton selectItem:item];
                selectedDeviceID = self.deviceUDID; //è‡ªåŠ¨é€‰ä¸­çš„
                found = YES;
                break;
            }
        }
    }

    // å¦‚æœæœªæ‰¾åˆ°åŒ¹é…çš„ deviceUDIDï¼Œå°è¯•æ ¹æ® deviceECID è¿›è¡ŒåŒ¹é…
    if (!found && self.deviceECID && self.deviceECID.length > 0) {
        for (NSMenuItem *item in self.devicePopUpButton.menu.itemArray) {
            if ([item.representedObject isEqualToString:self.deviceECID]) {
                [self.devicePopUpButton selectItem:item];
                selectedDeviceID = self.deviceECID; //è‡ªåŠ¨é€‰ä¸­çš„
                found = YES;
                break;
            }
        }
    }
    

    if (found) {
        self.lockedDeviceID = selectedDeviceID;  // é”å®šè®¾å¤‡
        //[self setLockedDeviceID];
        
        [self setLockedDeviceID:selectedDeviceID]; // æŒä¹…åŒ–è®¾å¤‡ä¿¡æ¯
        
        //åˆ¤æ–­æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
        NSLog(@"è‡ªåŠ¨é€‰ä¸­ååˆ¤æ–­æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€: %@" , self.currentDeviceMode);
        BOOL isLoggedIn = [UserManager sharedManager].isUserLoggedIn;
        if ([self.currentDeviceMode isEqualToString:@"Normal"] && isLoggedIn) {
          //  self.eraseDevice.enabled = YES; //æ“¦é™¤å†…å®¹
         //   self.triggerPairButton.enabled = YES;
           // self.triggerUnPairButton.enabled = YES;
        }else{
          //  self.eraseDevice.enabled = NO; //æ“¦é™¤å†…å®¹
          //  self.triggerPairButton.enabled = NO;
          //  self.triggerUnPairButton.enabled = NO;
        }
        
        // å›ºä»¶æ“ä½œå®Œæˆåå¼€å§‹å®šæ—¶æ¯ 3 ç§’ç›‘å¬ä¸€æ¬¡
       // [self startDeviceListMonitoring];
        
    } else {
        // æœªæ‰¾åˆ°åŒ¹é…è®¾å¤‡ï¼Œè§£é™¤é”å®š
        self.lockedDeviceID = nil;
        [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"LockedDeviceID"];
    }
}

#pragma mark - åˆ·æ–°æ—¥å¿—æ˜¾ç¤º

- (void)showLogsWithMessage:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        // ç”Ÿæˆæ—¶é—´æˆ³
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
        NSString *timestamp = [dateFormatter stringFromDate:[NSDate date]];

        // æ‰‹åŠ¨ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ—¥å¿—
        NSString *formattedLog = [NSString stringWithFormat:@"[%@] %@", timestamp, message];

        // è·å–æ—¥å¿—æ˜¾ç¤ºçš„ NSTextView
        NSTextView *textView = (NSTextView *)[LogManager sharedManager].logScrollView.documentView;
        if (textView) {
            // âœ… ç›´æ¥è°ƒç”¨ AppendLogToTextView è¿½åŠ æ—¥å¿—ï¼ˆä»ç„¶æ˜¯åŸå§‹ messageï¼‰
            AppendLogToTextView(textView, message);

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            NSRange endRange = NSMakeRange(textView.string.length, 0);
            [textView scrollRangeToVisible:endRange];

            // âœ… å­˜å…¥ collectedLogsï¼Œä½†åŠ ä¸Šæ—¶é—´æˆ³ï¼Œç¡®ä¿æœ€ç»ˆæ—¥å¿—æ–‡ä»¶æœ‰å®Œæ•´æ ¼å¼
            [self.collectedLogs appendFormat:@"%@\n", formattedLog];
        } else {
            NSLog(@"[ERROR] Failed to access NSTextView.");
        }
    });
}

#pragma mark - åˆå§‹åŒ–è§†å›¾æ§åˆ¶å™¨

- (void)initializeViewControllers {
    NSLog(@"DeviceBackupRestore: åˆå§‹åŒ–è§†å›¾æ§åˆ¶å™¨");
    
    // ä»Storyboardå®ä¾‹åŒ–å­è§†å›¾æ§åˆ¶å™¨
    self.defaultBackupViewController = [self.storyboard instantiateControllerWithIdentifier:@"DefaultBackupViewController"];
    NSLog(@"DeviceBackupRestore: å·²å®ä¾‹åŒ–DefaultBackupViewController");
    
    self.backupProgressViewController = [self.storyboard instantiateControllerWithIdentifier:@"BackupProgressViewController"];
    NSLog(@"DeviceBackupRestore: å·²å®ä¾‹åŒ–BackupProgressViewController");
    
    self.encryptedSettingsViewController = [self.storyboard instantiateControllerWithIdentifier:@"EncryptedSettingsViewController"];
    NSLog(@"DeviceBackupRestore: å·²å®ä¾‹åŒ–EncryptedSettingsViewController");
    
    self.restoreProgressViewController = [self.storyboard instantiateControllerWithIdentifier:@"RestoreProgressViewController"];
    NSLog(@"DeviceBackupRestore: å·²å®ä¾‹åŒ–RestoreProgressViewController");
    
    // è®¾ç½®é»˜è®¤å¤‡ä»½è§†å›¾çš„æ•°æ®æº
    self.defaultBackupViewController.backupItems = self.backupItems;
    
    // å°†è‡ªå·±è®¾ç½®ä¸ºå„ä¸ªå­è§†å›¾æ§åˆ¶å™¨çš„ä»£ç†
    self.backupProgressViewController.delegate = (id<BackupProgressDelegate>)self;
    self.encryptedSettingsViewController.delegate = (id<EncryptedSettingsDelegate>)self;
    self.restoreProgressViewController.delegate = (id<RestoreProgressDelegate>)self;
}

#pragma mark - è§†å›¾åˆ‡æ¢ç®¡ç†

- (void)displayContentController:(NSViewController *)content {
    NSLog(@"DeviceBackupRestore: åˆ‡æ¢åˆ°è§†å›¾æ§åˆ¶å™¨: %@", NSStringFromClass([content class]));
    
    // æ£€æŸ¥æ–°å†…å®¹æ˜¯å¦ä¸ºç©º
    if (!content) {
        NSLog(@"DeviceBackupRestore: é”™è¯¯ - å°è¯•æ˜¾ç¤ºç©ºçš„è§†å›¾æ§åˆ¶å™¨");
        return;
    }
    
    // æ£€æŸ¥ contentView æ˜¯å¦å­˜åœ¨
    if (!self.contentView) {
        NSLog(@"DeviceBackupRestore: é”™è¯¯ - contentView ä¸ºç©ºï¼Œæ— æ³•æ·»åŠ å­è§†å›¾");
        return;
    }
    
    // ç§»é™¤å½“å‰è§†å›¾æ§åˆ¶å™¨
    if (self.currentViewController) {
        // å…ˆä»è§†å›¾å±‚çº§ä¸­ç§»é™¤è§†å›¾
        [self.currentViewController.view removeFromSuperview];
        
        // ç›´æ¥ä»çˆ¶è§†å›¾æ§åˆ¶å™¨ä¸­ç§»é™¤
        [self.currentViewController removeFromParentViewController];
        
        NSLog(@"DeviceBackupRestore: å·²ç§»é™¤å½“å‰è§†å›¾æ§åˆ¶å™¨: %@", NSStringFromClass([self.currentViewController class]));
    }
    
    // æ·»åŠ æ–°çš„è§†å›¾æ§åˆ¶å™¨
    [self addChildViewController:content];
    
    // æ·»åŠ è§†å›¾
    NSView *contentView = content.view;
    [self.contentView addSubview:contentView];
    contentView.frame = self.contentView.bounds;
    contentView.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable;
    
    // æ›´æ–°å½“å‰è§†å›¾æ§åˆ¶å™¨å¼•ç”¨
    self.currentViewController = content;
    NSLog(@"DeviceBackupRestore: å·²æ·»åŠ æ–°è§†å›¾æ§åˆ¶å™¨: %@", NSStringFromClass([content class]));
}



#pragma mark - æŒ‰é’®åŠ¨ä½œæ–¹æ³•
- (IBAction)showBackupManageView:(id)sender {
    NSLog(@"DeviceBackupRestore: ç‚¹å‡»äº†å¤‡ä»½ç®¡ç†æŒ‰é’®");
    [self displayContentController:self.defaultBackupViewController];
    [self updateButtonStates:self.backupManageButton];
}


- (IBAction)showBackupView:(id)sender {
    NSLog(@"DeviceBackupRestore: ç‚¹å‡»äº†ç«‹å³å¤‡ä»½æŒ‰é’®");
    [self displayContentController:self.backupProgressViewController];
    [self updateButtonStates:self.startBackupButton];
    
    // âœ… åœ¨åˆ‡æ¢åˆ°å¤‡ä»½è§†å›¾æ—¶ä¹Ÿä¼ é€’å½“å‰è®¾å¤‡ä¿¡æ¯
    if (self.lockedDeviceID && self.lockedDeviceID.length > 0) {
        NSLog(@"DeviceBackupRestore: ä¼ é€’å½“å‰è®¾å¤‡ä¿¡æ¯åˆ°å¤‡ä»½è§†å›¾");
        [self.backupProgressViewController loadBackupDataForDevice:self.lockedDeviceID deviceInfo:self.LockedDeviceInfo];
    }
    
    // è·å–å½“å‰é”å®šçš„è®¾å¤‡IDï¼ˆUDID æˆ– ECIDï¼‰
    NSString *lockedDeviceID = self.lockedDeviceID;
    if (!lockedDeviceID) {
        lockedDeviceID = [self getLockedDeviceID];
        NSLog(@"å°è¯•ä»UserDefaultsè·å–é”å®šçš„è®¾å¤‡ID: %@", lockedDeviceID);
    }
    NSLog(@"å½“å‰è·å–åˆ°é”å®šçš„è®¾å¤‡ID: %@", lockedDeviceID);
    
    // è‡ªåŠ¨å¼€å§‹å¤‡ä»½
    [self triggerStartBackup:nil];
}

- (IBAction)showEncryptedSettingsView:(id)sender {
    NSLog(@"DeviceBackupRestore: ç‚¹å‡»äº†å¤‡ä»½åŠ å¯†æŒ‰é’®");
    [self displayContentController:self.encryptedSettingsViewController];
    [self updateButtonStates:self.encryptedBackupButton];
    
    // æ›´æ–°åŠ å¯†è®¾ç½®è§†å›¾ä¸­çš„çŠ¶æ€
    [self.encryptedSettingsViewController updateEncryptionStatus:self.backupIsEncrypted];
}

- (IBAction)showRestoreView:(id)sender {
    NSLog(@"DeviceBackupRestore: ç‚¹å‡»äº†æ¢å¤å¤‡ä»½æŒ‰é’®");
    [self displayContentController:self.restoreProgressViewController];
    [self updateButtonStates:self.restoreButton];
    
    // æ›´æ–°æ¢å¤è§†å›¾çš„å¤‡ä»½åˆ—è¡¨
    [self.restoreProgressViewController setBackupItems:self.backupItems];
}

- (void)updateButtonStates:(NSButton *)activeButton {
    if (!activeButton) {
        NSLog(@"DeviceBackupRestore: è­¦å‘Š - å°è¯•æ›´æ–°æŒ‰é’®çŠ¶æ€ï¼Œä½†æ´»åŠ¨æŒ‰é’®ä¸ºç©º");
        return;
    }
    
    NSLog(@"DeviceBackupRestore: æ›´æ–°æŒ‰é’®çŠ¶æ€ï¼Œå½“å‰æ´»åŠ¨æŒ‰é’®: %@", activeButton.title);
    
    // å…¨é¢è¿›è¡Œç©ºæŒ‡é’ˆæ£€æŸ¥
    if ([self.backupManageButton isKindOfClass:[NSButton class]]) {
        [self.backupManageButton setState:(activeButton == self.backupManageButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: è­¦å‘Š - backupManageButton ç±»å‹é”™è¯¯æˆ–ä¸ºç©º");
    }
    
    if ([self.startBackupButton isKindOfClass:[NSButton class]]) {
        [self.startBackupButton setState:(activeButton == self.startBackupButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: è­¦å‘Š - startBackupButton ç±»å‹é”™è¯¯æˆ–ä¸ºç©º");
    }
    
    if ([self.encryptedBackupButton isKindOfClass:[NSButton class]]) {
        [self.encryptedBackupButton setState:(activeButton == self.encryptedBackupButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: è­¦å‘Š - encryptedBackupButton ç±»å‹é”™è¯¯æˆ–ä¸ºç©º");
    }
    
    if ([self.restoreButton isKindOfClass:[NSButton class]]) {
        [self.restoreButton setState:(activeButton == self.restoreButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: è­¦å‘Š - restoreButton ç±»å‹é”™è¯¯æˆ–ä¸ºç©º");
    }
}

#pragma mark - å…¬å¼€æ–¹æ³•

// å¤‡ä»½è°ƒç”¨æ–¹æ³•
- (IBAction)triggerStartBackup:(NSButton *)sender {
    sender.enabled = NO; // ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
    
    NSString *deviceUDID = self.lockedDeviceID;
    
    if (!deviceUDID || deviceUDID.length == 0) {
        NSString *pleaseSelectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseSelectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Select Device"];
        pleaseSelectDeviceTitle = [NSString stringWithFormat:@"[WAR] %@", pleaseSelectDeviceTitle];
        [self showLogsWithMessage:pleaseSelectDeviceTitle];
        sender.enabled = YES;
        return;
    }

    [self showLogsWithMessage:[NSString stringWithFormat:@"å°†è¦å¤‡ä»½çš„è®¾å¤‡: %@ æ¨¡å¼: %@", self.lockedDeviceID, self.deviceMode]];
    
    // æ¸…ç©ºå½“å‰å¤‡ä»½æ–‡ä»¶åˆ—è¡¨
    [self.currentBackupFiles removeAllObjects];
    
    // é‡ç½®å¤‡ä»½è¿›åº¦è§†å›¾æ§åˆ¶å™¨çš„çŠ¶æ€
    if (self.backupProgressViewController) {
        [self.backupProgressViewController startBackupWithInitialLog:@"å‡†å¤‡å¼€å§‹å¤‡ä»½...\n"];
        [self.backupProgressViewController updateProgress:0.0];
    }
    
    // è®°å½•æ“ä½œæ—¥å¿—
    NSString *logRecord = [[LanguageManager sharedManager] localizedStringForKeys:@"HandleBackupDevice"
                                                                       inModule:@"OperationRecods"
                                                                  defaultValue:@"Handle Backup Device"];
    [[DataBaseManager sharedInstance] addOperationRecord:logRecord forDeviceECID:deviceUDID UDID:deviceUDID];
    
    if (![self.deviceMode isEqualToString:@"Normal"]) {
        NSString *logMessage = @"[WAR] è®¾å¤‡æ¨¡å¼éæ­£å¸¸ï¼Œæ— æ³•æ‰§è¡Œå¤‡ä»½";
        [self showLogsWithMessage:logMessage];
        sender.enabled = YES;
        self.isWorking = NO;
        return;
    }
    
    // âœ… åˆ›å»ºå¸¦æ—¶é—´æˆ³çš„å¤‡ä»½ç›®å½•
    NSString *timestampedBackupPath = [self createTimestampedBackupDirectoryForDevice:deviceUDID];
    if (!timestampedBackupPath) {
        NSString *errorMessage = @"[ERR] æ— æ³•åˆ›å»ºå¤‡ä»½ç›®å½•";
        [self showLogsWithMessage:errorMessage];
        sender.enabled = YES;
        self.isWorking = NO;
        return;
    }
    
    [self showLogsWithMessage:[NSString stringWithFormat:@"å¤‡ä»½ç›®å½•å·²åˆ›å»º: %@", [timestampedBackupPath lastPathComponent]]];
    
    // å¼ºå¼•ç”¨ä¿ç•™è‡ªå·±ï¼Œé˜²æ­¢è¢«é‡Šæ”¾
    __strong typeof(self) strongSelf = self;
    
    // è·å–BackupTaskå®ä¾‹å¹¶è®¾ç½®æ—¥å¿—å›è°ƒ
    BackupTask *backupTask = [BackupTask sharedInstance];
    
    // è®¾ç½®æ—¥å¿—å›è°ƒ - å…³é”®ä¿®æ”¹
    backupTask.logCallback = ^(NSString *logMessage) {
        dispatch_async(dispatch_get_main_queue(), ^{
            // æ ¼å¼åŒ–æ—¥å¿—æ¶ˆæ¯å¹¶æ˜¾ç¤º
            NSString *formattedMessage = [NSString stringWithFormat:@"%@", logMessage];
            [strongSelf showLogsWithMessage:formattedMessage];
            
            // è§£ææ–‡ä»¶ä¿¡æ¯å¹¶æ·»åŠ åˆ°åˆ—è¡¨
            [strongSelf parseAndAddBackupFileInfo:logMessage];
        });
    };
    
    // é¢„å…ˆæ£€æŸ¥è®¾å¤‡è¿æ¥æ€§
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // åˆæ­¥æµ‹è¯•è®¾å¤‡è¿æ¥æ€§
        idevice_t testDevice = NULL;
        idevice_error_t ierr = idevice_new(&testDevice, [deviceUDID UTF8String]);
        
        if (ierr != IDEVICE_E_SUCCESS) {
            NSString *errorMsg = [NSString stringWithFormat:@"è®¾å¤‡è¿æ¥æµ‹è¯•å¤±è´¥ï¼Œé”™è¯¯ç : %d", ierr];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@", errorMsg]];
                sender.enabled = YES;
                strongSelf.isWorking = NO;
            });
            
            if (testDevice) {
                idevice_free(testDevice);
            }
            return;
        }
        
        if (testDevice) {
            idevice_free(testDevice);
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [strongSelf showLogsWithMessage:@"è®¾å¤‡è¿æ¥æµ‹è¯•æˆåŠŸï¼Œå¼€å§‹æ‰§è¡Œå¤‡ä»½ä»»åŠ¡"];
        });
        
        // ä½¿ç”¨æ–°çš„æ–¹æ³•ï¼šä¼ é€’è‡ªå®šä¹‰å¤‡ä»½è·¯å¾„
        [backupTask startBackupForDevice:deviceUDID
                       customBackupPath:timestampedBackupPath  // ä¼ é€’æ—¶é—´æˆ³å¤‡ä»½è·¯å¾„
                               progress:^(double progress, NSString *message) {
            // è¿›åº¦æ›´æ–°é€»è¾‘ä¿æŒä¸å˜
            dispatch_async(dispatch_get_main_queue(), ^{
                // æ›´æ–°å¤‡ä»½è¿›åº¦è§†å›¾æ§åˆ¶å™¨çš„è¿›åº¦
                if (strongSelf.backupProgressViewController) {
                    [strongSelf.backupProgressViewController updateProgress:progress * 100];
                }
                
                // å®šæœŸæ˜¾ç¤ºè¿›åº¦ä¿¡æ¯åˆ°æ—¥å¿—
                static double lastLoggedProgress = -1;
                if (progress - lastLoggedProgress >= 0.10 || progress >= 1.0) { // æ¯10%æ˜¾ç¤ºä¸€æ¬¡
                    NSString *progressMessage = [NSString stringWithFormat:@"%@", message];
                    [strongSelf showLogsWithMessage:progressMessage];
                    lastLoggedProgress = progress;
                }
            });
        }
        completion:^(BOOL success, NSError *error) {
            dispatch_async(dispatch_get_main_queue(), ^{
                sender.enabled = YES;
                strongSelf.isWorking = NO;
                
                if (success) {
                    
                    // âœ… è®¡ç®—å½“å‰å¤‡ä»½çš„å®é™…å¤§å°
                    uint64_t currentBackupSize = [strongSelf calculateDirectorySize:timestampedBackupPath];
                    NSString *currentBackupSizeFormatted = [strongSelf formatSize:currentBackupSize];
                    
                    
                    // æ›´æ–°è¿›åº¦ä¸ºå®ŒæˆçŠ¶æ€
                    if (strongSelf.backupProgressViewController) {
                        [strongSelf.backupProgressViewController updateProgress:100.0];
                        // âœ… å¤‡ä»½å®Œæˆååˆ·æ–°å½“å‰è®¾å¤‡çš„å¤‡ä»½åˆ—è¡¨
                        [strongSelf.backupProgressViewController checkAndLoadExistingBackupData];
                    }
                    
                    NSString *logDeviceBackupCompletedMessage = [[LanguageManager sharedManager] localizedStringForKeys:@"DeviceBackupCompleted"
                                                                                   inModule:@"Backup"
                                                                              defaultValue:@"Device Backup completed successfully"];
                    
                    // âœ… æ˜¾ç¤ºå½“å‰å¤‡ä»½çš„å¤§å°è€Œä¸æ˜¯æ€»å¤§å°
                    [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[SUC] %@ - å¤‡ä»½è·¯å¾„: %@, å¤‡ä»½å¤§å°: %@",
                                                   logDeviceBackupCompletedMessage,
                                                   [timestampedBackupPath lastPathComponent],
                                                   currentBackupSizeFormatted]];
                    
                    
                    // âœ… å»¶è¿Ÿåˆ·æ–°å¤‡ä»½åˆ—è¡¨ï¼Œç¡®ä¿æ–‡ä»¶ç³»ç»Ÿæ“ä½œå®Œæˆ
                    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                        [strongSelf refreshBackupListAfterCompletion:timestampedBackupPath];
                    });
                    
                } else {
                    // æ›´æ–°è¿›åº¦ä¸ºå¤±è´¥çŠ¶æ€
                    if (strongSelf.backupProgressViewController) {
                        [strongSelf.backupProgressViewController updateProgress:50.0];
                    }
                    
                    NSString *errorMessage = error ? error.localizedDescription : @"æœªçŸ¥é”™è¯¯";
                    NSString *logDeviceBackupFailedMessage = [NSString stringWithFormat:@"è®¾å¤‡å¤‡ä»½å¤±è´¥: %@", errorMessage];
                    [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@", logDeviceBackupFailedMessage]];
                }
                
                // æ¸…é™¤æ—¥å¿—å›è°ƒï¼Œé¿å…å†…å­˜æ³„æ¼
                backupTask.logCallback = nil;
            });
        }];
    });
}

#pragma mark - å¤‡ä»½å®Œæˆååˆ·æ–°
// è®¡ç®—ç›®å½•å¤§å°çš„è¾…åŠ©æ–¹æ³•
- (unsigned long long)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    unsigned long long totalSize = 0;
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedLongLongValue];
        }
    }
    return totalSize;
}

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°çš„è¾…åŠ©æ–¹æ³•
- (NSString *)formatSize:(uint64_t)size {
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)size];
}

- (void)refreshBackupListAfterCompletion:(NSString *)newBackupPath {
    NSLog(@"DeviceBackupRestore: å¤‡ä»½å®Œæˆï¼Œåˆ·æ–°è¡¨æ ¼æ•°æ®");
    if (self.backupProgressViewController) {
        // è·å–å½“å‰è®¾å¤‡ä¿¡æ¯
        NSString *currentDeviceID = self.lockedDeviceID;
        NSDictionary *deviceInfo = self.LockedDeviceInfo;
        
        if (currentDeviceID && currentDeviceID.length > 0) {
            NSLog(@"DeviceBackupRestore: ä¸ºè®¾å¤‡ %@ åˆ·æ–°å¤‡ä»½åˆ—è¡¨", currentDeviceID);
            
            // é‡æ–°åŠ è½½å½“å‰è®¾å¤‡çš„å¤‡ä»½æ•°æ®
            [self.backupProgressViewController loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
            
            // æ˜¾ç¤ºåˆ·æ–°æˆåŠŸæ¶ˆæ¯
            NSString *refreshMessage = [NSString stringWithFormat:@"å¤‡ä»½åˆ—è¡¨å·²åˆ·æ–°ï¼Œæ–°å¤‡ä»½: %@", [newBackupPath lastPathComponent]];
            [self showLogsWithMessage:refreshMessage];
            
            // âœ… å¯é€‰ï¼šæ»šåŠ¨åˆ°æœ€æ–°çš„å¤‡ä»½é¡¹ï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                [self.backupProgressViewController scrollToNewestBackup];
            });
        } else {
            NSLog(@"DeviceBackupRestore: æ— æ³•åˆ·æ–° - å½“å‰è®¾å¤‡IDä¸ºç©º");
            [self showLogsWithMessage:@"[WAR] æ— æ³•åˆ·æ–°å¤‡ä»½åˆ—è¡¨ - è®¾å¤‡ä¿¡æ¯ç¼ºå¤±"];
        }
    }
}

#pragma mark - æ—¶é—´æˆ³å¤‡ä»½ç›®å½•åˆ›å»º

// ä¸ºè®¾å¤‡åˆ›å»ºå¸¦æ—¶é—´æˆ³çš„å¤‡ä»½ç›®å½•
- (NSString *)createTimestampedBackupDirectoryForDevice:(NSString *)deviceUDID {
    NSLog(@"DeviceBackupRestore: ä¸ºè®¾å¤‡ %@ åˆ›å»ºæ—¶é—´æˆ³å¤‡ä»½ç›®å½•", deviceUDID);
    
    // è·å–åŸºç¡€å¤‡ä»½è·¯å¾„
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    
    // åˆ›å»ºè®¾å¤‡ä¸“ç”¨ç›®å½•è·¯å¾„
    NSString *deviceBackupPath = [defaultBackupPath stringByAppendingPathComponent:deviceUDID];
    
    // ç”Ÿæˆæ—¶é—´æˆ³å­—ç¬¦ä¸²
    NSString *timestampString = [self generateBackupTimestamp];
    
    // åˆ›å»ºå®Œæ•´çš„å¤‡ä»½ç›®å½•è·¯å¾„ï¼š/BackupPath/[DeviceUDID]/[TimeStamp]/
    NSString *timestampedBackupPath = [deviceBackupPath stringByAppendingPathComponent:timestampString];
    
    NSLog(@"DeviceBackupRestore: æ—¶é—´æˆ³å¤‡ä»½è·¯å¾„: %@", timestampedBackupPath);
    
    // åˆ›å»ºç›®å½•
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    
    BOOL success = [fileManager createDirectoryAtPath:timestampedBackupPath
                           withIntermediateDirectories:YES
                                            attributes:nil
                                                 error:&error];
    
    if (!success) {
        NSLog(@"DeviceBackupRestore: åˆ›å»ºå¤‡ä»½ç›®å½•å¤±è´¥: %@", error.localizedDescription);
        [self showLogsWithMessage:[NSString stringWithFormat:@"[ERR] åˆ›å»ºå¤‡ä»½ç›®å½•å¤±è´¥: %@", error.localizedDescription]];
        return nil;
    }
    
    NSLog(@"DeviceBackupRestore: æˆåŠŸåˆ›å»ºå¤‡ä»½ç›®å½•: %@", timestampedBackupPath);
    return timestampedBackupPath;
}

// ç”Ÿæˆå¤‡ä»½æ—¶é—´æˆ³å­—ç¬¦ä¸²
- (NSString *)generateBackupTimestamp {
    NSDate *now = [NSDate date];
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    
    // è®¾ç½®æ—¶åŒºä¸ºæœ¬åœ°æ—¶åŒº
    [formatter setTimeZone:[NSTimeZone localTimeZone]];
    
    // åˆ›å»ºå¹´æœˆæ—¥éƒ¨åˆ† (YYYYMMDD)
    [formatter setDateFormat:@"yyyyMMdd"];
    NSString *datePart = [formatter stringFromDate:now];
    
    // åˆ›å»ºæ—¶åˆ†éƒ¨åˆ† (HHMM)
    [formatter setDateFormat:@"HHmm"];
    NSString *timePart = [formatter stringFromDate:now];
    
    // ç¡®å®šAM/PM
    [formatter setDateFormat:@"a"];
    NSString *ampmPart = [formatter stringFromDate:now];
    
    // è½¬æ¢AM/PMä¸ºè‹±æ–‡ï¼ˆé˜²æ­¢æœ¬åœ°åŒ–é—®é¢˜ï¼‰
    if ([ampmPart containsString:@"ä¸Šåˆ"] || [ampmPart containsString:@"AM"]) {
        ampmPart = @"AM";
    } else {
        ampmPart = @"PM";
    }
    
    // ç»„åˆæˆæœ€ç»ˆçš„æ—¶é—´æˆ³å­—ç¬¦ä¸²
    NSString *timestamp = [NSString stringWithFormat:@"%@%@%@", datePart, timePart, ampmPart];
    
    NSLog(@"DeviceBackupRestore: ç”Ÿæˆå¤‡ä»½æ—¶é—´æˆ³: %@", timestamp);
    return timestamp;
}

// ä¿®æ”¹è§£æå¤‡ä»½æ–‡ä»¶ä¿¡æ¯çš„æ–¹æ³•ï¼Œä½¿ç”¨æ–°çš„æ—¶é—´æˆ³ç›®å½•
- (void)parseAndAddBackupFileInfo:(NSString *)logMessage {
    // è§£æä¸åŒç±»å‹çš„æ–‡ä»¶ä¿¡æ¯
    if ([logMessage containsString:@"Receiving file"] || [logMessage containsString:@"Sending file"]) {
        NSString *fileName = [self extractFileNameFromMessage:logMessage];
        NSString *fileSize = [self extractFileSizeFromMessage:logMessage];
                
        // âœ… ä½¿ç”¨å½“å‰å¤‡ä»½ä¼šè¯çš„è·¯å¾„è€Œä¸æ˜¯é»˜è®¤è·¯å¾„
        NSString *currentBackupPath = [self getCurrentBackupSessionPath];
        NSString *isEncrypted = [logMessage containsString:@"Encrypted"] ? @"Yes" : @"No";
        NSString *isImported = [logMessage containsString:@"Backuptype"] ? @"Import" : @"-";
        
        if (fileName && fileName.length > 0) {
            NSDictionary *fileInfo = @{
                @"fileName": fileName,
                @"backuplocation": currentBackupPath ?: [DatalogsSettings defaultBackupPath],
                @"backupfilesize": fileSize ?: @"-",
                @"backupencryptionstatus": isEncrypted ?: @"-",
                @"backuptype": isImported ?: @"-",
                @"backupdate": [NSDate date]
            };
            
            [self.currentBackupFiles addObject:fileInfo];
            
            // é™åˆ¶åˆ—è¡¨é•¿åº¦ï¼Œé¿å…è¿‡å¤šæ¡ç›®å½±å“æ€§èƒ½
            if (self.currentBackupFiles.count > 1000) {
                [self.currentBackupFiles removeObjectsInRange:NSMakeRange(0, 100)];
            }
            
            // é€šçŸ¥å¤‡ä»½è¿›åº¦è§†å›¾æ§åˆ¶å™¨æ›´æ–°æ–‡ä»¶åˆ—è¡¨
            if (self.backupProgressViewController) {
                [self.backupProgressViewController updateBackupFilesList:self.currentBackupFiles];
            }
        }
    }
}

// è·å–å½“å‰å¤‡ä»½ä¼šè¯çš„è·¯å¾„ï¼ˆå¦‚æœéœ€è¦è·Ÿè¸ªå½“å‰å¤‡ä»½è·¯å¾„ï¼‰
- (NSString *)getCurrentBackupSessionPath {
    // è¿™é‡Œå¯ä»¥ä¿å­˜å½“å‰å¤‡ä»½ä¼šè¯çš„è·¯å¾„ï¼Œå¦‚æœéœ€è¦çš„è¯
    // ç›®å‰è¿”å›é»˜è®¤è·¯å¾„ï¼Œå¯ä»¥æ ¹æ®éœ€è¦è¿›è¡Œæ‰©å±•
    return nil; // è¿”å›nilä½¿ç”¨é»˜è®¤è·¯å¾„
}



- (NSString *)extractFileNameFromMessage:(NSString *)message {
    // æå–æ–‡ä»¶åçš„æ­£åˆ™è¡¨è¾¾å¼
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"(?:Receiving|Sending) file (.+?)(?:\\s|$)"
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    
    if (error) {
        return nil;
    }
    
    NSTextCheckingResult *match = [regex firstMatchInString:message
                                                    options:0
                                                      range:NSMakeRange(0, message.length)];
    
    if (match && match.numberOfRanges > 1) {
        NSString *fullPath = [message substringWithRange:[match rangeAtIndex:1]];
        // åªè¿”å›æ–‡ä»¶åï¼Œä¸åŒ…å«è·¯å¾„
        return [fullPath lastPathComponent];
    }
    
    return nil;
}

- (NSString *)extractFileSizeFromMessage:(NSString *)message {
    // æå–æ–‡ä»¶å¤§å°ä¿¡æ¯
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"(\\d+(?:\\.\\d+)?\\s*(?:KB|MB|GB|B))"
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    
    if (error) {
        return nil;
    }
    
    NSTextCheckingResult *match = [regex firstMatchInString:message
                                                    options:0
                                                      range:NSMakeRange(0, message.length)];
    
    if (match) {
        return [message substringWithRange:match.range];
    }
    
    return nil;
}

- (void)clearBackupFilesList {
    [self.currentBackupFiles removeAllObjects];
    if (self.backupProgressViewController) {
        [self.backupProgressViewController updateBackupFilesList:self.currentBackupFiles];
    }
}


- (void)startBackup {
    NSLog(@"DeviceBackupRestore: å¼€å§‹å¤‡ä»½");
    if (self.isBackupInProgress) {
        NSLog(@"DeviceBackupRestore: å¤‡ä»½å·²åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥è¯·æ±‚");
        return;
    }
    
    self.backupInProgress = YES;
    self.backupProgress = 0.0;
    
    // é€šçŸ¥å¤‡ä»½è¿›åº¦è§†å›¾æ§åˆ¶å™¨å¼€å§‹å¤‡ä»½
    [self.backupProgressViewController startBackupWithInitialLog:@"å¼€å§‹å¤‡ä»½...\n"];
}

#pragma mark - BackupProgressDelegate
- (void)cancelBackup {
    NSLog(@"DeviceBackupRestore: å–æ¶ˆå¤‡ä»½");
    if (!self.isBackupInProgress) {
        NSLog(@"DeviceBackupRestore: å½“å‰æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å¤‡ä»½ï¼Œå¿½ç•¥è¯·æ±‚");
        return;
    }
    
    self.backupInProgress = NO;
    [self.backupProgressViewController appendLog:@"å¤‡ä»½å·²å–æ¶ˆ\n"];
    NSLog(@"DeviceBackupRestore: å¤‡ä»½å·²å–æ¶ˆ");
}

- (void)startRestore {
    NSLog(@"DeviceBackupRestore: å¼€å§‹æ¢å¤");
    if (self.isRestoreInProgress) {
        NSLog(@"DeviceBackupRestore: æ¢å¤å·²åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥è¯·æ±‚");
        return;
    }
    
    self.restoreInProgress = YES;
    self.restoreProgress = 0.0;
    
    // é€šçŸ¥æ¢å¤è¿›åº¦è§†å›¾æ§åˆ¶å™¨å¼€å§‹æ¢å¤
    [self.restoreProgressViewController startRestoreWithInitialLog:@"å¼€å§‹æ¢å¤...\n"];
    
    // æ¨¡æ‹Ÿæ¢å¤è¿›åº¦
    [self simulateRestoreProcess];
}

- (void)cancelRestore {
    NSLog(@"DeviceBackupRestore: å–æ¶ˆæ¢å¤");
    if (!self.isRestoreInProgress) {
        NSLog(@"DeviceBackupRestore: å½“å‰æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„æ¢å¤ï¼Œå¿½ç•¥è¯·æ±‚");
        return;
    }
    
    self.restoreInProgress = NO;
    [self.restoreProgressViewController appendLog:@"æ¢å¤å·²å–æ¶ˆ\n"];
    NSLog(@"DeviceBackupRestore: æ¢å¤å·²å–æ¶ˆ");
}

- (void)setBackupLocation:(NSString *)location {
    NSLog(@"DeviceBackupRestore: è®¾ç½®å¤‡ä»½ä½ç½®: %@", location);
    self.backupLocationPath = location;
}

- (NSString *)currentBackupLocation {
    NSLog(@"DeviceBackupRestore: è·å–å½“å‰å¤‡ä»½ä½ç½®: %@", self.backupLocationPath);
    return self.backupLocationPath;
}

- (void)setBackupEncryption:(BOOL)encrypted {
    NSLog(@"DeviceBackupRestore: è®¾ç½®å¤‡ä»½åŠ å¯†çŠ¶æ€: %@", encrypted ? @"å·²åŠ å¯†" : @"æœªåŠ å¯†");
    self.backupIsEncrypted = encrypted;
}

- (BOOL)isBackupEncrypted {
    NSLog(@"DeviceBackupRestore: è·å–å¤‡ä»½åŠ å¯†çŠ¶æ€: %@", self.backupIsEncrypted ? @"å·²åŠ å¯†" : @"æœªåŠ å¯†");
    return self.backupIsEncrypted;
}

#pragma mark - åŠ å¯†è®¾ç½®

- (void)changePassword:(NSString *)currentPassword newPassword:(NSString *)newPassword {
    NSLog(@"DeviceBackupRestore: ä¿®æ”¹å¯†ç ");
    
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œåº”è¯¥æ‰§è¡Œå®é™…çš„å¯†ç éªŒè¯å’Œä¿®æ”¹
    self.backupIsEncrypted = YES;
    NSLog(@"DeviceBackupRestore: å¯†ç å·²æ›´æ–°");
    
    // æ˜¾ç¤ºæˆåŠŸæç¤º
    [self showAlert:@"å¯†ç å·²æ›´æ–°" informativeText:@"è®¾å¤‡å¤‡ä»½å¯†ç å·²æˆåŠŸæ›´æ–°"];
}

- (void)deletePassword:(NSString *)currentPassword {
    NSLog(@"DeviceBackupRestore: åˆ é™¤å¯†ç ");
    
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œåº”è¯¥æ‰§è¡Œå®é™…çš„å¯†ç éªŒè¯å’Œåˆ é™¤
    self.backupIsEncrypted = NO;
    NSLog(@"DeviceBackupRestore: å¯†ç å·²åˆ é™¤");
    
    // æ˜¾ç¤ºæˆåŠŸæç¤º
    [self showAlert:@"å¯†ç å·²åˆ é™¤" informativeText:@"è®¾å¤‡å¤‡ä»½å¯†ç å·²æˆåŠŸåˆ é™¤"];
}

#pragma mark - å¸®åŠ©æ–¹æ³•

- (void)showAlert:(NSString *)title informativeText:(NSString *)text {
    NSLog(@"DeviceBackupRestore: æ˜¾ç¤ºè­¦å‘Š: %@ - %@", title, text);
    NSAlert *alert = [[NSAlert alloc] init];
    [alert setMessageText:title];
    [alert setInformativeText:text];
    [alert addButtonWithTitle:@"ç¡®å®š"];
    [alert beginSheetModalForWindow:self.view.window completionHandler:nil];
}


// æ¨¡æ‹Ÿæ¢å¤è¿‡ç¨‹
- (void)simulateRestoreProcess {
    NSLog(@"DeviceBackupRestore: å¼€å§‹æ¨¡æ‹Ÿæ¢å¤è¿‡ç¨‹");
    __block double progress = 0.0;
    __block NSInteger step = 0;
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 0.2 * NSEC_PER_SEC, 0.05 * NSEC_PER_SEC);
    
    dispatch_source_set_event_handler(timer, ^{
        if (!self.isRestoreInProgress || progress >= 100.0) {
            NSLog(@"DeviceBackupRestore: æ¢å¤è¿›ç¨‹å°†ç»ˆæ­¢ï¼ŒçŠ¶æ€: isRestoreInProgress=%d, progress=%.1f",
                  self.isRestoreInProgress, progress);
            dispatch_source_cancel(timer);
            
            if (progress >= 100.0) {
                NSLog(@"DeviceBackupRestore: æ¢å¤å®Œæˆ");
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self.restoreProgressViewController appendLog:@"æ¢å¤å®Œæˆ!\n"];
                    self.restoreInProgress = NO;
                });
            }
            return;
        }
        
        progress += 2.0;
        step++;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self.restoreProgress = progress;
            [self.restoreProgressViewController updateProgress:progress];
            
            // æ¯5æ­¥æ·»åŠ ä¸€æ¡æ—¥å¿—
            if (step % 5 == 0) {
                NSString *logMessage = [NSString stringWithFormat:@"æ¢å¤è¿›åº¦: %.1f%%...\n", progress];
                NSLog(@"DeviceBackupRestore: %@", logMessage);
                [self.restoreProgressViewController appendLog:logMessage];
            }
        });
    });
    
    dispatch_resume(timer);
    NSLog(@"DeviceBackupRestore: æ¢å¤è¿›ç¨‹è®¡æ—¶å™¨å·²å¯åŠ¨");
}



#pragma mark - ç»Ÿä¸€æƒé™ç®¡ç†
- (BOOL)validateForAction {
    if (!self.deviceUDID) {
        //NSLog(@"è®¾å¤‡ UDID æ— æ•ˆæˆ–ä¸ºç©º");
        // å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºä¸€ä¸ªæç¤ºæ¡†ç»™ç”¨æˆ·
        return NO;
    }
    
    UserManager *userManager = [UserManager sharedManager];
    if (!userManager.isUserLoggedIn) {
       // NSLog(@"æ²¡æœ‰ç™»å½•");
        // å‘é€é€šçŸ¥ä»¥è§¦å‘ç™»å½•æµç¨‹
        [[NSNotificationCenter defaultCenter] postNotificationName:@"ShowLoginNotification" object:nil];
        return NO;
    }
    
    return YES;
}



#pragma mark - âœ… é€‰æ‹©æ€§å¤‡ä»½åŠŸèƒ½åˆå§‹åŒ–
- (void)initializeSelectiveBackupFeatures {
    NSLog(@"DeviceBackupRestore: åˆå§‹åŒ–é€‰æ‹©æ€§å¤‡ä»½åŠŸèƒ½");
    
    // åˆå§‹åŒ–BackupOptionTaskå®ä¾‹
    self.backupOptionTask = [[BackupOptionTask alloc] init];
    
    // åˆå§‹åŒ–æ•°æ®
    self.selectedDataTypes = BackupDataTypeNone;
    self.availableDataItems = [NSMutableArray array];
    self.dataTypeCheckboxes = [NSMutableArray array];
    
    // è®¾ç½®BackupOptionTaskçš„å›è°ƒ
    [self setupBackupOptionTaskCallbacks];
    
    NSLog(@"DeviceBackupRestore: é€‰æ‹©æ€§å¤‡ä»½åŠŸèƒ½åˆå§‹åŒ–å®Œæˆ");
}

- (void)setupBackupOptionTaskCallbacks {
    // è®¾ç½®è¿›åº¦å›è°ƒ
    __weak typeof(self) weakSelf = self;
    
    self.backupOptionTask.progressCallback = ^(float progress, NSString *operation, NSUInteger current, NSUInteger total) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf updateSelectiveBackupProgress:progress operation:operation current:current total:total];
            }
        });
    };
    
    // è®¾ç½®çŠ¶æ€å›è°ƒ
    self.backupOptionTask.statusCallback = ^(SyncTaskStatus status, NSString *description) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf updateSelectiveBackupStatus:status description:description];
            }
        });
    };
    
    // è®¾ç½®å®Œæˆå›è°ƒ
    self.backupOptionTask.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *error) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf handleSelectiveBackupCompletion:success completedTypes:completedTypes error:error];
            }
        });
    };
    
    // è®¾ç½®æ—¥å¿—å›è°ƒ
    self.backupOptionTask.logCallback = ^(NSString *logMessage) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf showLogsWithMessage:logMessage];
            }
        });
    };
}



#pragma mark - âœ… é€‰æ‹©æ€§å¤‡ä»½ä¸»è¦æ–¹æ³•

- (IBAction)showSelectiveBackupOptions:(id)sender {
    NSLog(@"DeviceBackupRestore: ğŸ”§ å¯åŠ¨ä¿®å¤ç‰ˆé€‰æ‹©æ€§å¤‡ä»½");
        
    // âœ… å…³é”®ä¿®å¤ï¼šé‡ç½®è¿æ¥çŠ¶æ€
    [self.backupOptionTask disconnectDevice];
    [NSThread sleepForTimeInterval:1.0];
    
    // é‡æ–°è¿æ¥
    NSError *error = nil;
    BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
    
    if (!connected) {
        [self showAlert:@"è¿æ¥å¤±è´¥" informativeText:error.localizedDescription];
        return;
    }
    
    [self showLogsWithMessage:@"âœ… è®¾å¤‡é‡è¿æˆåŠŸï¼Œå¼€å§‹æ£€æµ‹æ•°æ®ç±»å‹"];
    
    // è¿æ¥åˆ°è®¾å¤‡å¹¶è·å–æ”¯æŒçš„æ•°æ®ç±»å‹
    [self connectToDeviceAndShowOptions];
}

- (void)connectToDeviceAndShowOptions {
    [self showLogsWithMessage:@"æ­£åœ¨è¿æ¥è®¾å¤‡ä»¥è·å–æ”¯æŒçš„æ•°æ®ç±»å‹..."];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (connected) {
                [self showLogsWithMessage:@"è®¾å¤‡è¿æ¥æˆåŠŸï¼Œæ­£åœ¨è·å–æ”¯æŒçš„æ•°æ®ç±»å‹..."];
                [self fetchSupportedDataTypesAndShowWindow];
            } else {
                NSString *errorMsg = [NSString stringWithFormat:@"[ERR] è®¾å¤‡è¿æ¥å¤±è´¥: %@",
                                    error.localizedDescription ?: @"æœªçŸ¥é”™è¯¯"];
                [self showLogsWithMessage:errorMsg];
                [self showAlert:@"è¿æ¥å¤±è´¥" informativeText:error.localizedDescription ?: @"æ— æ³•è¿æ¥åˆ°è®¾å¤‡"];
            }
        });
    });
}

#pragma mark - âœ… æ•°æ®ç±»å‹ä¿¡æ¯å®šä¹‰
- (NSDictionary *)getDataTypeDisplayInfo {
    static NSDictionary *displayInfo = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        displayInfo = @{
            @(BackupDataTypeContacts): @{
                @"name": @"é€šè®¯å½•",
                @"icon": @"person.crop.circle.fill",
                @"description": @"è”ç³»äººä¿¡æ¯å’Œé€šè¯è®°å½•",
                @"color": [NSColor systemBlueColor]
            },
            @(BackupDataTypeCalendars): @{
                @"name": @"æ—¥å†",
                @"icon": @"calendar",
                @"description": @"æ—¥ç¨‹å®‰æ’å’Œäº‹ä»¶æé†’",
                @"color": [NSColor systemRedColor]
            },
            @(BackupDataTypeBookmarks): @{
                @"name": @"ä¹¦ç­¾",
                @"icon": @"book.closed.fill",
                @"description": @"Safariæµè§ˆå™¨ä¹¦ç­¾",
                @"color": [NSColor systemOrangeColor]
            },
            @(BackupDataTypeNotes): @{
                @"name": @"å¤‡å¿˜å½•",
                @"icon": @"note.text",
                @"description": @"å¤‡å¿˜å½•å’Œç¬”è®°å†…å®¹",
                @"color": [NSColor systemYellowColor]
            },
            @(BackupDataTypeReminders): @{
                @"name": @"æé†’äº‹é¡¹",
                @"icon": @"bell.fill",
                @"description": @"å¾…åŠäº‹é¡¹å’Œæé†’",
                @"color": [NSColor systemOrangeColor]
            },
            @(BackupDataTypeApplications): @{
                @"name": @"åº”ç”¨",
                @"icon": @"app.badge.fill",
                @"description": @"åº”ç”¨ç¨‹åºå’Œæ•°æ®",
                @"color": [NSColor systemBlueColor]
            },
            @(BackupDataTypeVoiceMemos): @{
                @"name": @"è¯­éŸ³å¤‡å¿˜å½•",
                @"icon": @"mic.circle.fill",
                @"description": @"å½•éŸ³æ–‡ä»¶",
                @"color": [NSColor systemGrayColor]
            },
            @(BackupDataTypeKeychain): @{
                @"name": @"é’¥åŒ™ä¸²",
                @"icon": @"key.fill",
                @"description": @"å¯†ç å’Œè¯ä¹¦",
                @"color": [NSColor systemGrayColor]
            },
            @(BackupDataTypeWallpaper): @{
                @"name": @"å£çº¸",
                @"icon": @"photo.fill",
                @"description": @"ç³»ç»Ÿå£çº¸è®¾ç½®",
                @"color": [NSColor systemPurpleColor]
            },
            @(BackupDataTypeConfiguration): @{
                @"name": @"è®¾ç½®",
                @"icon": @"gear",
                @"description": @"ç³»ç»Ÿé…ç½®å’Œåå¥½è®¾ç½®",
                @"color": [NSColor systemGrayColor]
            }
        };
    });
    return displayInfo;
}


#pragma mark - âœ… ä¿®å¤çš„è®¾å¤‡æ‰«ææ–¹æ³• - å¼ºåˆ¶è·å–çœŸå®æ•°æ®

- (void)fetchSupportedDataTypesAndShowWindow {
    [self showLogsWithMessage:@"æ­£åœ¨ä»è®¾å¤‡è·å–çœŸå®æ•°æ®ç±»å‹..."];
    
    __weak typeof(self) weakSelf = self;
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        __strong typeof(weakSelf) strongSelf = weakSelf;
        if (!strongSelf) return;
        
        // âœ… æ­¥éª¤1ï¼šç¡®ä¿è®¾å¤‡è¿æ¥å’Œåˆå§‹åŒ–
        if (![strongSelf ensureDeviceConnectionAndInitialization]) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [strongSelf showAlert:@"è®¾å¤‡è¿æ¥å¤±è´¥" informativeText:@"æ— æ³•å»ºç«‹ä¸è®¾å¤‡çš„è¿æ¥ï¼Œè¯·æ£€æŸ¥è®¾å¤‡çŠ¶æ€"];
            });
            return;
        }
        
        // âœ… æ­¥éª¤2ï¼šæ‰§è¡ŒçœŸå®æ•°æ®æ‰«æ
        NSDictionary *realDataResults = [strongSelf scanRealDeviceData];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [strongSelf handleRealDataScanResults:realDataResults];
        });
    });
}

// âœ… ç¡®ä¿è®¾å¤‡è¿æ¥å’Œæ­£ç¡®åˆå§‹åŒ–
- (BOOL)ensureDeviceConnectionAndInitialization {
    NSLog(@"=== ç¡®ä¿è®¾å¤‡è¿æ¥å’Œåˆå§‹åŒ– ===");
    
    // 1. æ£€æŸ¥åŸºæœ¬æ¡ä»¶
    if (!self.lockedDeviceID || self.lockedDeviceID.length == 0) {
        NSLog(@"âŒ è®¾å¤‡IDä¸ºç©º");
        return NO;
    }
    
    // 2. é‡æ–°åˆå§‹åŒ–BackupOptionTaskï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (!self.backupOptionTask) {
        NSLog(@"åˆ›å»ºæ–°çš„BackupOptionTaskå®ä¾‹");
        self.backupOptionTask = [[BackupOptionTask alloc] init];
        [self setupBackupOptionTaskCallbacks];
    }
    
    // 3. å¼ºåˆ¶æ–­å¼€ç°æœ‰è¿æ¥
    [self.backupOptionTask disconnectDevice];
    [NSThread sleepForTimeInterval:0.5];
    
    // 4. é‡æ–°è¿æ¥è®¾å¤‡
    NSError *error = nil;
    BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
    
    if (!connected) {
        NSLog(@"âŒ è®¾å¤‡è¿æ¥å¤±è´¥: %@", error.localizedDescription);
        return NO;
    }
    
    NSLog(@"âœ… è®¾å¤‡è¿æ¥æˆåŠŸ");
    
    // 5. éªŒè¯è¿æ¥çŠ¶æ€
    if (![self.backupOptionTask isConnected]) {
        NSLog(@"âŒ è¿æ¥éªŒè¯å¤±è´¥");
        return NO;
    }
    
    // 6. æ‰§è¡Œè®¾å¤‡è¯Šæ–­ä»¥åˆå§‹åŒ–å†…éƒ¨çŠ¶æ€
    [self.backupOptionTask diagnoseDeviceSyncCapabilities];
    
    NSLog(@"âœ… è®¾å¤‡è¿æ¥å’Œåˆå§‹åŒ–å®Œæˆ");
    return YES;
}

// âœ… æ‰«æè®¾å¤‡ä¸­çš„çœŸå®æ•°æ®
- (NSDictionary *)scanRealDeviceData {
    // ä½¿ç”¨å¢å¼ºçš„æ‰«ææ–¹æ³•
    return [self.backupOptionTask scanRealDeviceDataEnhanced];
}

#pragma mark - ğŸ› ï¸ è°ƒè¯•å’Œæ—¥å¿—å¢å¼º

- (void)performDetailedDiagnosticsEnhanced {
    NSLog(@"=== æ‰§è¡Œå¢å¼ºçš„è®¾å¤‡è¯Šæ–­ ===");
    [self showLogsWithMessage:@"ğŸ” æ­£åœ¨æ‰§è¡Œå¢å¼ºçš„è®¾å¤‡è¯Šæ–­..."];
    
    // 1. åŸºç¡€è¿æ¥çŠ¶æ€
    BOOL isConnected = [self.backupOptionTask isConnected];
    NSString *connectionMsg = [NSString stringWithFormat:@"è®¾å¤‡è¿æ¥çŠ¶æ€: %@",
                              isConnected ? @"âœ… å·²è¿æ¥" : @"âŒ æœªè¿æ¥"];
    [self showLogsWithMessage:connectionMsg];
    
    if (!isConnected) {
        [self showLogsWithMessage:@"âŒ è®¾å¤‡æœªè¿æ¥ï¼Œåœæ­¢è¯Šæ–­"];
        return;
    }
    
    // 2. è®¾å¤‡ä¿¡æ¯
    [self showLogsWithMessage:[NSString stringWithFormat:@"ç›®æ ‡è®¾å¤‡: %@", self.lockedDeviceID]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"è®¾å¤‡æ¨¡å¼: %@", self.deviceMode]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"è®¾å¤‡ç±»å‹: %@", self.deviceType]];
    
    // 3. ä½¿ç”¨ä¿®å¤åçš„æ–¹æ³•è·å–æ”¯æŒçš„æ•°æ®ç±»å‹
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BackupDataType supportedTypes = [self.backupOptionTask getSupportedDataTypes:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (error) {
                [self showLogsWithMessage:[NSString stringWithFormat:@"âŒ è·å–æ”¯æŒç±»å‹å¤±è´¥: %@",
                                         error.localizedDescription]];
            } else {
                [self showLogsWithMessage:[NSString stringWithFormat:@"âœ… è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : %lu",
                                         (unsigned long)supportedTypes]];
                
                if (supportedTypes != BackupDataTypeNone) {
                    [self showLogsWithMessage:@"ğŸ“± æ”¯æŒçš„æ•°æ®ç±»å‹è¯¦æƒ…:"];
                    
                    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
                    for (NSNumber *typeNumber in allDataTypes) {
                        BackupDataType dataType = [typeNumber unsignedIntegerValue];
                        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
                        
                        if (supportedTypes & dataType) {
                            [self showLogsWithMessage:[NSString stringWithFormat:@"  âœ… %@", typeName]];
                        }
                    }
                } else {
                    [self showLogsWithMessage:@"âŒ è®¾å¤‡ä¸æ”¯æŒä»»ä½•é€‰æ‹©æ€§å¤‡ä»½æ•°æ®ç±»å‹"];
                    [self showLogsWithMessage:@"ğŸ’¡ å»ºè®®ä½¿ç”¨å®Œæ•´å¤‡ä»½åŠŸèƒ½"];
                }
            }
            
            [self showLogsWithMessage:@"ğŸ” å¢å¼ºè®¾å¤‡è¯Šæ–­å®Œæˆ"];
        });
    });
}

// âœ… è·å–ç‰¹å®šæ•°æ®ç±»å‹çš„çœŸå®æ•°æ®
- (NSDictionary *)getRealDataForType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"è·å– %@ çš„çœŸå®æ•°æ®", typeName);
    
    // æ–¹æ³•1ï¼šç›´æ¥è°ƒç”¨getDataItemsForType
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = [self.backupOptionTask getDataItemsForType:dataType error:&error];
    
    if (error) {
        NSLog(@"âŒ ç›´æ¥è·å– %@ æ•°æ®å‡ºé”™: %@", typeName, error.localizedDescription);
    }
    
    if (items && items.count > 0) {
        NSLog(@"âœ… ç›´æ¥æ–¹æ³•æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹", typeName, (unsigned long)items.count);
        return [self createDataDictionary:items forType:dataType];
    }
    
    // æ–¹æ³•2ï¼šé€šè¿‡ç»Ÿè®¡ä¿¡æ¯æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
    NSDictionary *stats = [self.backupOptionTask getDataTypeStatistics:dataType error:&error];
    if (stats) {
        NSNumber *itemCount = stats[@"itemCount"];
        NSLog(@"ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º %@ æœ‰ %@ é¡¹æ•°æ®", typeName, itemCount);
        
        if ([itemCount integerValue] > 0) {
            // ç»Ÿè®¡æ˜¾ç¤ºæœ‰æ•°æ®ï¼Œä½†getDataItemsForTypeè¿”å›ç©ºï¼Œå¯èƒ½æ˜¯ç¼“å­˜é—®é¢˜
            [self clearSpecificDataTypeCache:dataType];
            
            // é‡æ–°å°è¯•è·å–
            items = [self.backupOptionTask getDataItemsForType:dataType error:&error];
            if (items && items.count > 0) {
                NSLog(@"âœ… æ¸…é™¤ç¼“å­˜åæˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹", typeName, (unsigned long)items.count);
                return [self createDataDictionary:items forType:dataType];
            }
        }
    }
    
    // æ–¹æ³•3ï¼šä½¿ç”¨å¼‚æ­¥æ–¹æ³•å°è¯•è·å–
    return [self tryAsyncDataRetrieval:dataType];
}


// âœ… åˆ›å»ºæ•°æ®å­—å…¸
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    if (!items || items.count == 0) {
        return nil;
    }
    
    NSUInteger totalSize = 0;
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,  // æ ‡è®°è¿™æ˜¯çœŸå®æ•°æ®
        @"lastScanned": [NSDate date]
    };
}

// âœ… æ¸…é™¤ç‰¹å®šæ•°æ®ç±»å‹çš„ç¼“å­˜
- (void)clearSpecificDataTypeCache:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"æ¸…é™¤ %@ çš„ç¼“å­˜", typeName);
    
    // ç”±äºBackupOptionTaskå¯èƒ½æ²¡æœ‰æä¾›æ¸…é™¤ç‰¹å®šç¼“å­˜çš„æ–¹æ³•
    // æˆ‘ä»¬é‡‡ç”¨é‡è¿çš„æ–¹å¼æ¥æ¸…é™¤çŠ¶æ€
    [self.backupOptionTask disconnectDevice];
    [NSThread sleepForTimeInterval:0.1];
    
    NSError *error = nil;
    [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
    
    if (error) {
        NSLog(@"é‡è¿è®¾å¤‡æ—¶å‡ºé”™: %@", error.localizedDescription);
    }
}

// âœ… å°è¯•å¼‚æ­¥æ•°æ®è·å–
- (NSDictionary *)tryAsyncDataRetrieval:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"å°è¯•å¼‚æ­¥è·å– %@ æ•°æ®", typeName);
    
    __block NSArray<SyncDataItem *> *asyncItems = nil;
    __block NSError *asyncError = nil;
    __block BOOL completed = NO;
    
    [self.backupOptionTask getDataItemsForTypeAsync:dataType completion:^(NSArray<SyncDataItem *> *items, NSError *error) {
        asyncItems = items;
        asyncError = error;
        completed = YES;
    }];
    
    // ç­‰å¾…å¼‚æ­¥å®Œæˆï¼ˆæœ€å¤š5ç§’ï¼‰
    NSDate *timeout = [NSDate dateWithTimeIntervalSinceNow:5.0];
    while (!completed && [[NSDate date] compare:timeout] == NSOrderedAscending) {
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
    }
    
    if (!completed) {
        NSLog(@"âŒ å¼‚æ­¥è·å– %@ æ•°æ®è¶…æ—¶", typeName);
        return nil;
    }
    
    if (asyncError) {
        NSLog(@"âŒ å¼‚æ­¥è·å– %@ æ•°æ®å‡ºé”™: %@", typeName, asyncError.localizedDescription);
        return nil;
    }
    
    if (asyncItems && asyncItems.count > 0) {
        NSLog(@"âœ… å¼‚æ­¥æ–¹æ³•æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹", typeName, (unsigned long)asyncItems.count);
        return [self createDataDictionary:asyncItems forType:dataType];
    }
    
    NSLog(@"âŒ %@ ç¡®å®æ²¡æœ‰æ•°æ®", typeName);
    return nil;
}

// âœ… å¤„ç†çœŸå®æ•°æ®æ‰«æç»“æœ
- (void)handleRealDataScanResults:(NSDictionary *)realDataResults {
    if (realDataResults.count == 0) {
        [self handleNoRealDataFound];
        return;
    }
    
    // ä¿å­˜çœŸå®æ•°æ®ç»“æœ
    self.deviceScannedData = [realDataResults mutableCopy];
    
    // è®°å½•è¯¦ç»†ç»“æœ
    [self logRealDataResults:realDataResults];
    
    NSString *successMsg = [NSString stringWithFormat:@"âœ… æˆåŠŸè·å–è®¾å¤‡çœŸå®æ•°æ®ï¼š%lu ç§æ•°æ®ç±»å‹",
                           (unsigned long)realDataResults.count];
    [self showLogsWithMessage:successMsg];
    
    // æ˜¾ç¤ºé€‰æ‹©ç•Œé¢
    [self createAndShowEnhancedSelectiveBackupWindow];
}

// âœ… è®°å½•çœŸå®æ•°æ®ç»“æœ
- (void)logRealDataResults:(NSDictionary *)realDataResults {
    NSLog(@"=== çœŸå®è®¾å¤‡æ•°æ®è·å–ç»“æœ ===");
    [self showLogsWithMessage:@"ğŸ“Š è®¾å¤‡çœŸå®æ•°æ®ç»Ÿè®¡:"];
    
    for (NSNumber *typeNumber in realDataResults.allKeys) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSDictionary *typeData = realDataResults[typeNumber];
        
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSNumber *itemCount = typeData[@"itemCount"];
        NSString *formattedSize = typeData[@"formattedSize"];
        
        NSString *logMsg = [NSString stringWithFormat:@"  ğŸ“± %@: %@ é¡¹, %@ (çœŸå®æ•°æ®)",
                           typeName, itemCount, formattedSize];
        [self showLogsWithMessage:logMsg];
    }
    
    NSLog(@"=== ç»“æœè®°å½•å®Œæˆ ===");
}

// âœ… å¤„ç†æ²¡æœ‰æ‰¾åˆ°çœŸå®æ•°æ®çš„æƒ…å†µ
- (void)handleNoRealDataFound {
    NSLog(@"æœªæ‰¾åˆ°ä»»ä½•çœŸå®è®¾å¤‡æ•°æ®ï¼Œå¼€å§‹æ•…éšœæ’é™¤");
    
    [self showLogsWithMessage:@"âŒ æœªåœ¨è®¾å¤‡ä¸­æ‰¾åˆ°å¯å¤‡ä»½çš„æ•°æ®"];
    
    // æ‰§è¡Œè¯¦ç»†è¯Šæ–­
    [self performDetailedDiagnostics];
    
    NSString *troubleshootingMsg = @"æ•…éšœæ’é™¤å»ºè®®ï¼š\n\n"
                                  @"1ï¸âƒ£ è®¾å¤‡çŠ¶æ€æ£€æŸ¥ï¼š\n"
                                  @"   â€¢ ç¡®ä¿è®¾å¤‡å·²è§£é”\n"
                                  @"   â€¢ ç¡®ä¿å·²ç‚¹å‡»'ä¿¡ä»»æ­¤ç”µè„‘'\n"
                                  @"   â€¢ æ£€æŸ¥è®¾å¤‡æ˜¯å¦å¤„äºæ­£å¸¸æ¨¡å¼\n\n"
                                  @"2ï¸âƒ£ æ•°æ®æƒé™æ£€æŸ¥ï¼š\n"
                                  @"   â€¢ è®¾å¤‡ä¸­æ˜¯å¦æœ‰è”ç³»äººã€æ—¥å†ç­‰æ•°æ®\n"
                                  @"   â€¢ æ£€æŸ¥iCloudåŒæ­¥è®¾ç½®\n\n"
                                  @"3ï¸âƒ£ è¿æ¥é—®é¢˜æ£€æŸ¥ï¼š\n"
                                  @"   â€¢ å°è¯•é‡æ–°è¿æ¥USBçº¿\n"
                                  @"   â€¢ å…³é—­å…¶ä»–iOSç®¡ç†è½¯ä»¶\n\n"
                                  @"4ï¸âƒ£ ç³»ç»Ÿå…¼å®¹æ€§ï¼š\n"
                                  @"   â€¢ æ£€æŸ¥iOSç‰ˆæœ¬å…¼å®¹æ€§\n"
                                  @"   â€¢ å°è¯•ä½¿ç”¨å®Œæ•´å¤‡ä»½åŠŸèƒ½";
    
    [self showAlert:@"æœªæ‰¾åˆ°å¯å¤‡ä»½æ•°æ®" informativeText:troubleshootingMsg];
}

// âœ… æ‰§è¡Œè¯¦ç»†è¯Šæ–­
- (void)performDetailedDiagnostics {
    NSLog(@"=== æ‰§è¡Œè¯¦ç»†è®¾å¤‡è¯Šæ–­ ===");
    [self showLogsWithMessage:@"ğŸ” æ­£åœ¨æ‰§è¡Œè¯¦ç»†è®¾å¤‡è¯Šæ–­..."];
    
    // 1. è¿æ¥çŠ¶æ€è¯Šæ–­
    BOOL isConnected = [self.backupOptionTask isConnected];
    NSString *connectionMsg = [NSString stringWithFormat:@"è®¾å¤‡è¿æ¥çŠ¶æ€: %@",
                              isConnected ? @"âœ… å·²è¿æ¥" : @"âŒ æœªè¿æ¥"];
    [self showLogsWithMessage:connectionMsg];
    
    // 2. è®¾å¤‡ä¿¡æ¯è¯Šæ–­
    [self showLogsWithMessage:[NSString stringWithFormat:@"ç›®æ ‡è®¾å¤‡: %@", self.lockedDeviceID]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"è®¾å¤‡æ¨¡å¼: %@", self.deviceMode]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"è®¾å¤‡ç±»å‹: %@", self.deviceType]];
    
    // 3. æ•°æ®ç±»å‹æ”¯æŒè¯Šæ–­
    NSError *error = nil;
    BackupDataType supportedTypes = [self.backupOptionTask getSupportedDataTypes:&error];
    
    if (error) {
        [self showLogsWithMessage:[NSString stringWithFormat:@"âŒ è·å–æ”¯æŒç±»å‹å¤±è´¥: %@", error.localizedDescription]];
    } else {
        [self showLogsWithMessage:[NSString stringWithFormat:@"âœ… è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : %lu", (unsigned long)supportedTypes]];
        
        // åˆ—å‡ºå…·ä½“æ”¯æŒçš„ç±»å‹
        NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
        for (NSNumber *typeNumber in allDataTypes) {
            BackupDataType dataType = [typeNumber unsignedIntegerValue];
            NSString *typeName = [BackupOptionTask stringForDataType:dataType];
            
            if (supportedTypes & dataType) {
                [self showLogsWithMessage:[NSString stringWithFormat:@"  âœ… æ”¯æŒ: %@", typeName]];
            }
        }
    }
    
    // 4. è°ƒç”¨BackupOptionTaskå†…ç½®è¯Šæ–­
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [self.backupOptionTask diagnoseDeviceSyncCapabilities];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [self showLogsWithMessage:@"ğŸ” è®¾å¤‡åŒæ­¥èƒ½åŠ›è¯Šæ–­å®Œæˆï¼Œè¯·æŸ¥çœ‹è¯¦ç»†æ—¥å¿—"];
        });
    });
}
















#pragma mark - âœ… åˆ›å»ºç¾è§‚çš„é€‰æ‹©ç•Œé¢ï¼ˆç±»ä¼¼æˆªå›¾æ•ˆæœï¼‰
- (void)createAndShowEnhancedSelectiveBackupWindow {
    NSLog(@"DeviceBackupRestore: åˆ›å»ºå¢å¼ºçš„é€‰æ‹©æ€§å¤‡ä»½çª—å£");
    
    // åˆ›å»ºçª—å£
    NSRect windowFrame = NSMakeRect(0, 0, 480, 650);
    self.selectiveBackupWindow = [[NSWindow alloc] initWithContentRect:windowFrame
                                                             styleMask:NSWindowStyleMaskTitled | NSWindowStyleMaskClosable
                                                               backing:NSBackingStoreBuffered
                                                                 defer:NO];
    
    [self.selectiveBackupWindow setTitle:@"é€‰æ‹©å¤‡ä»½å†…å®¹"];
    [self.selectiveBackupWindow center];
    
    // åˆ›å»ºä¸»è§†å›¾
    NSView *mainView = [[NSView alloc] initWithFrame:windowFrame];
    [mainView setWantsLayer:YES];
    [mainView.layer setBackgroundColor:[[NSColor controlBackgroundColor] CGColor]];
    [self.selectiveBackupWindow setContentView:mainView];
    
    // åˆ›å»ºæ ‡é¢˜åŒºåŸŸ
    [self createTitleSection:mainView];
    
    // åˆ›å»ºæ•°æ®ç±»å‹é€‰æ‹©åŒºåŸŸ
    [self createDataTypeGrid:mainView];
    
    // åˆ›å»ºåº•éƒ¨æ§åˆ¶åŒºåŸŸ
    [self createBottomControls:mainView];
    
    // æ˜¾ç¤ºçª—å£
    [self.selectiveBackupWindow makeKeyAndOrderFront:nil];
    
    NSLog(@"DeviceBackupRestore: å¢å¼ºçš„é€‰æ‹©æ€§å¤‡ä»½çª—å£å·²æ˜¾ç¤º");
}

// åˆ›å»ºæ ‡é¢˜åŒºåŸŸ
- (void)createTitleSection:(NSView *)parentView {
    // ä¸»æ ‡é¢˜
    NSTextField *titleLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(30, 580, 420, 35)];
    [titleLabel setBezeled:NO];
    [titleLabel setDrawsBackground:NO];
    [titleLabel setEditable:NO];
    [titleLabel setStringValue:@"å¤‡ä»½å†…å®¹"];
    [titleLabel setFont:[NSFont boldSystemFontOfSize:24]];
    [titleLabel setAlignment:NSTextAlignmentLeft];
    [parentView addSubview:titleLabel];
    
    // å‰¯æ ‡é¢˜
    NSTextField *subtitleLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(30, 550, 420, 25)];
    [subtitleLabel setBezeled:NO];
    [subtitleLabel setDrawsBackground:NO];
    [subtitleLabel setEditable:NO];
    [subtitleLabel setStringValue:@"é€‰æ‹©è¦å¤‡ä»½çš„æ•°æ®ç±»å‹ï¼Œå¯ä»¥èŠ‚çœæ—¶é—´å’Œå­˜å‚¨ç©ºé—´"];
    [subtitleLabel setFont:[NSFont systemFontOfSize:14]];
    [subtitleLabel setTextColor:[NSColor secondaryLabelColor]];
    [parentView addSubview:subtitleLabel];
    
    // åˆ†éš”çº¿
    NSBox *separator = [[NSBox alloc] initWithFrame:NSMakeRect(30, 535, 420, 1)];
    [separator setBoxType:NSBoxSeparator];
    [parentView addSubview:separator];
}

// åˆ›å»ºæ•°æ®ç±»å‹ç½‘æ ¼
- (void)createDataTypeGrid:(NSView *)parentView {
    NSScrollView *scrollView = [[NSScrollView alloc] initWithFrame:NSMakeRect(20, 120, 440, 400)];
    [scrollView setHasVerticalScroller:YES];
    [scrollView setAutohidesScrollers:YES];
    [scrollView setBorderType:NSNoBorder];
    [scrollView setDrawsBackground:NO];
    [parentView addSubview:scrollView];
    
    // åˆ›å»ºç½‘æ ¼å®¹å™¨
    NSView *gridView = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, 420, 0)];
    
    CGFloat yPosition = 10;
    [self.dataTypeCheckboxes removeAllObjects];
    
    NSDictionary *displayInfo = [self getDataTypeDisplayInfo];
    
    // éå†æ‰«æåˆ°çš„æ•°æ®ç±»å‹
    for (NSNumber *typeNumber in self.deviceScannedData.allKeys) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSDictionary *typeInfo = displayInfo[typeNumber];  // âœ… ä¿®å¤ï¼šç§»é™¤å¤šä½™çš„@()
        NSDictionary *scanData = self.deviceScannedData[typeNumber];  // âœ… ä¿®å¤ï¼šç§»é™¤å¤šä½™çš„@()
        
        if (!typeInfo || !scanData) continue;
        
        // åˆ›å»ºå•ä¸ªæ•°æ®ç±»å‹é¡¹
        NSView *itemView = [self createDataTypeItemCard:dataType
                                               typeInfo:typeInfo
                                               scanData:scanData
                                                  frame:NSMakeRect(10, yPosition, 400, 70)];
        [gridView addSubview:itemView];
        
        yPosition += 80; // å¡ç‰‡é—´è·
    }
    
    // è®¾ç½®ç½‘æ ¼è§†å›¾å¤§å°
    NSRect gridFrame = gridView.frame;
    gridFrame.size.height = MAX(yPosition + 20, 400);
    [gridView setFrame:gridFrame];
    
    [scrollView setDocumentView:gridView];
}


// åˆ›å»ºå•ä¸ªæ•°æ®ç±»å‹å¡ç‰‡
- (NSView *)createDataTypeItemCard:(BackupDataType)dataType
                          typeInfo:(NSDictionary *)typeInfo
                          scanData:(NSDictionary *)scanData
                             frame:(NSRect)frame {
    
    // ä¸»å®¹å™¨
    NSView *cardView = [[NSView alloc] initWithFrame:frame];
    [cardView setWantsLayer:YES];
    [cardView.layer setBackgroundColor:[[NSColor controlColor] CGColor]];
    [cardView.layer setCornerRadius:12.0];
    [cardView.layer setBorderWidth:1.0];
    [cardView.layer setBorderColor:[[NSColor separatorColor] CGColor]];
    
    // å¤é€‰æ¡†
    NSButton *checkbox = [[NSButton alloc] initWithFrame:NSMakeRect(20, 25, 20, 20)];
    [checkbox setButtonType:NSButtonTypeSwitch];
    [checkbox setTarget:self];
    [checkbox setAction:@selector(dataTypeCheckboxChanged:)];
    [checkbox setTag:dataType];
    [cardView addSubview:checkbox];
    [self.dataTypeCheckboxes addObject:checkbox];
    
    // å›¾æ ‡
    NSImageView *iconView = [[NSImageView alloc] initWithFrame:NSMakeRect(55, 20, 30, 30)];
    NSString *iconName = typeInfo[@"icon"];
    if (@available(macOS 11.0, *)) {
        NSImage *icon = [NSImage imageWithSystemSymbolName:iconName accessibilityDescription:nil];
        if (icon) {
            [icon setTemplate:YES];
            [iconView setImage:icon];
            [iconView setContentTintColor:typeInfo[@"color"]];
        }
    } else {
        // æ—§ç‰ˆæœ¬ä½¿ç”¨é»˜è®¤å›¾æ ‡
        [iconView setImage:[NSImage imageNamed:NSImageNameFolder]];
    }
    [cardView addSubview:iconView];
    
    // ä¸»æ ‡é¢˜ï¼ˆæ•°æ®ç±»å‹åç§°ï¼‰
    NSTextField *nameLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(100, 35, 200, 20)];
    [nameLabel setBezeled:NO];
    [nameLabel setDrawsBackground:NO];
    [nameLabel setEditable:NO];
    [nameLabel setStringValue:typeInfo[@"name"]];
    [nameLabel setFont:[NSFont boldSystemFontOfSize:16]];
    [cardView addSubview:nameLabel];
    
    // ç»Ÿè®¡ä¿¡æ¯
    NSNumber *itemCount = scanData[@"itemCount"];
    NSString *formattedSize = scanData[@"formattedSize"];
    NSString *statsText = [NSString stringWithFormat:@"%@ é¡¹ â€¢ %@", itemCount, formattedSize];
    
    NSTextField *statsLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(100, 15, 200, 18)];
    [statsLabel setBezeled:NO];
    [statsLabel setDrawsBackground:NO];
    [statsLabel setEditable:NO];
    [statsLabel setStringValue:statsText];
    [statsLabel setFont:[NSFont systemFontOfSize:13]];
    [statsLabel setTextColor:[NSColor secondaryLabelColor]];
    [cardView addSubview:statsLabel];
    
    // å³ä¾§ç®­å¤´ï¼ˆå¯é€‰ï¼‰
    if (@available(macOS 11.0, *)) {
        NSImageView *arrowView = [[NSImageView alloc] initWithFrame:NSMakeRect(350, 25, 20, 20)];
        NSImage *arrowIcon = [NSImage imageWithSystemSymbolName:@"chevron.right" accessibilityDescription:nil];
        if (arrowIcon) {
            [arrowIcon setTemplate:YES];
            [arrowView setImage:arrowIcon];
            [arrowView setContentTintColor:[NSColor tertiaryLabelColor]];
        }
        [cardView addSubview:arrowView];
    }
    
    return cardView;
}


// åˆ›å»ºåº•éƒ¨æ§åˆ¶åŒºåŸŸ
- (void)createBottomControls:(NSView *)parentView {
    // è¿›åº¦æ¡
    self.selectiveBackupProgress = [[NSProgressIndicator alloc] initWithFrame:NSMakeRect(30, 80, 420, 8)];
    [self.selectiveBackupProgress setStyle:NSProgressIndicatorStyleBar];
    [self.selectiveBackupProgress setMinValue:0.0];
    [self.selectiveBackupProgress setMaxValue:100.0];
    [self.selectiveBackupProgress setHidden:YES];
    [parentView addSubview:self.selectiveBackupProgress];
    
    // çŠ¶æ€æ ‡ç­¾
    self.selectiveBackupStatusLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(30, 95, 420, 20)];
    [self.selectiveBackupStatusLabel setBezeled:NO];
    [self.selectiveBackupStatusLabel setDrawsBackground:NO];
    [self.selectiveBackupStatusLabel setEditable:NO];
    [self.selectiveBackupStatusLabel setStringValue:@""];
    [self.selectiveBackupStatusLabel setFont:[NSFont systemFontOfSize:13]];
    [self.selectiveBackupStatusLabel setTextColor:[NSColor secondaryLabelColor]];
    [parentView addSubview:self.selectiveBackupStatusLabel];
    
    // æŒ‰é’®åŒºåŸŸ
    // å–æ¶ˆæŒ‰é’®
    NSButton *cancelButton = [[NSButton alloc] initWithFrame:NSMakeRect(270, 25, 80, 32)];
    [cancelButton setTitle:@"å–æ¶ˆ"];
    [cancelButton setTarget:self];
    [cancelButton setAction:@selector(cancelSelectiveBackup:)];
    [cancelButton setBezelStyle:NSBezelStyleRounded];
    [parentView addSubview:cancelButton];
    
    // å¼€å§‹å¤‡ä»½æŒ‰é’®
    NSButton *startButton = [[NSButton alloc] initWithFrame:NSMakeRect(360, 25, 90, 32)];
    [startButton setTitle:@"å¼€å§‹å¤‡ä»½"];
    [startButton setTarget:self];
    [startButton setAction:@selector(startSelectiveBackup:)];
    [startButton setBezelStyle:NSBezelStyleRounded];
    [startButton setKeyEquivalent:@"\r"]; // å›è½¦é”®
    [parentView addSubview:startButton];
    
    // å…¨é€‰/æ¸…ç©ºæŒ‰é’®
    NSButton *selectAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(30, 25, 60, 32)];
    [selectAllButton setTitle:@"å…¨é€‰"];
    [selectAllButton setTarget:self];
    [selectAllButton setAction:@selector(selectAllDataTypes:)];
    [selectAllButton setBezelStyle:NSBezelStyleRounded];
    [parentView addSubview:selectAllButton];
    
    NSButton *clearAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(100, 25, 60, 32)];
    [clearAllButton setTitle:@"æ¸…ç©º"];
    [clearAllButton setTarget:self];
    [clearAllButton setAction:@selector(clearAllDataTypes:)];
    [clearAllButton setBezelStyle:NSBezelStyleRounded];
    [parentView addSubview:clearAllButton];
}



- (NSUInteger)countDataTypes:(BackupDataType)dataTypes {
    NSUInteger count = 0;
    NSArray<NSNumber *> *allTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNumber in allTypes) {
        BackupDataType type = [typeNumber unsignedIntegerValue];
        if (dataTypes & type) {
            count++;
        }
    }
    
    return count;
}

#pragma mark - âœ… é€‰æ‹©æ€§å¤‡ä»½çª—å£åˆ›å»º

- (void)createAndShowSelectiveBackupWindow {
    NSLog(@"DeviceBackupRestore: åˆ›å»ºé€‰æ‹©æ€§å¤‡ä»½çª—å£");
    
    // åˆ›å»ºçª—å£
    NSRect windowFrame = NSMakeRect(0, 0, 500, 600);
    self.selectiveBackupWindow = [[NSWindow alloc] initWithContentRect:windowFrame
                                                             styleMask:NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable
                                                               backing:NSBackingStoreBuffered
                                                                 defer:NO];
    
    [self.selectiveBackupWindow setTitle:@"é€‰æ‹©æ€§å¤‡ä»½"];
    [self.selectiveBackupWindow center];
    
    // åˆ›å»ºå†…å®¹è§†å›¾
    NSView *contentView = [[NSView alloc] initWithFrame:windowFrame];
    [self.selectiveBackupWindow setContentView:contentView];
    
    // åˆ›å»ºæ»šåŠ¨è§†å›¾ç”¨äºæ•°æ®ç±»å‹é€‰æ‹©
    NSScrollView *scrollView = [[NSScrollView alloc] initWithFrame:NSMakeRect(20, 100, 460, 400)];
    [scrollView setHasVerticalScroller:YES];
    [scrollView setAutohidesScrollers:YES];
    [contentView addSubview:scrollView];
    
    // åˆ›å»ºæ•°æ®ç±»å‹é€‰æ‹©åŒºåŸŸ
    [self createDataTypeSelectionView:scrollView];
    
    // åˆ›å»ºåº•éƒ¨æŒ‰é’®
    [self createSelectiveBackupButtons:contentView];
    
    // åˆ›å»ºé¡¶éƒ¨è¯´æ˜æ ‡ç­¾
    [self createSelectiveBackupInstructions:contentView];
    
    // æ˜¾ç¤ºçª—å£
    [self.selectiveBackupWindow makeKeyAndOrderFront:nil];
    
    NSLog(@"DeviceBackupRestore: é€‰æ‹©æ€§å¤‡ä»½çª—å£å·²æ˜¾ç¤º");
}

- (void)createDataTypeSelectionView:(NSScrollView *)scrollView {
    // åˆ›å»ºæ–‡æ¡£è§†å›¾
    NSView *documentView = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, 440, 0)];
    
    // æ¸…ç©ºä¹‹å‰çš„é€‰æ‹©æ¡†
    [self.dataTypeCheckboxes removeAllObjects];
    
    CGFloat yPosition = 10;
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        
        // æ£€æŸ¥æ˜¯å¦æ”¯æŒæ­¤æ•°æ®ç±»å‹
        if (!(self.supportedDataTypes & dataType)) {
            continue;
        }
        
        // åˆ›å»ºå¤é€‰æ¡†
        NSButton *checkbox = [[NSButton alloc] initWithFrame:NSMakeRect(20, yPosition, 400, 24)];
        [checkbox setButtonType:NSButtonTypeSwitch];
        [checkbox setTitle:[BackupOptionTask localizedStringForDataType:dataType]];
        [checkbox setTarget:self];
        [checkbox setAction:@selector(dataTypeCheckboxChanged:)];
        [checkbox setTag:dataType];
        
        // æ·»åŠ åˆ°æ–‡æ¡£è§†å›¾å’Œæ•°ç»„
        [documentView addSubview:checkbox];
        [self.dataTypeCheckboxes addObject:checkbox];
        
        yPosition += 30;
        
        // å¼‚æ­¥è·å–æ­¤æ•°æ®ç±»å‹çš„è¯¦ç»†ä¿¡æ¯
        [self fetchDataItemsForType:dataType checkbox:checkbox];
    }
    
    // è®¾ç½®æ–‡æ¡£è§†å›¾å¤§å°
    NSRect docFrame = documentView.frame;
    docFrame.size.height = yPosition + 20;
    [documentView setFrame:docFrame];
    
    [scrollView setDocumentView:documentView];
}

- (void)fetchDataItemsForType:(BackupDataType)dataType checkbox:(NSButton *)checkbox {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self.backupOptionTask getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (items && items.count > 0) {
                NSString *detailText = [NSString stringWithFormat:@"%@ (%lu é¡¹)",
                                      [BackupOptionTask localizedStringForDataType:dataType],
                                      (unsigned long)items.count];
                [checkbox setTitle:detailText];
                
                // ä¿å­˜æ•°æ®é¡¹åˆ°å…¨å±€æ•°ç»„
                [self.availableDataItems addObjectsFromArray:items];
            } else if (error) {
                NSString *errorText = [NSString stringWithFormat:@"%@ (è·å–å¤±è´¥)",
                                     [BackupOptionTask localizedStringForDataType:dataType]];
                [checkbox setTitle:errorText];
                [checkbox setEnabled:NO];
            }
        });
    });
}

- (void)createSelectiveBackupButtons:(NSView *)contentView {
    // å¼€å§‹å¤‡ä»½æŒ‰é’®
    NSButton *startButton = [[NSButton alloc] initWithFrame:NSMakeRect(300, 20, 80, 32)];
    [startButton setTitle:@"å¼€å§‹å¤‡ä»½"];
    [startButton setTarget:self];
    [startButton setAction:@selector(startSelectiveBackup:)];
    [startButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:startButton];
    
    // å–æ¶ˆæŒ‰é’®
    NSButton *cancelButton = [[NSButton alloc] initWithFrame:NSMakeRect(400, 20, 60, 32)];
    [cancelButton setTitle:@"å–æ¶ˆ"];
    [cancelButton setTarget:self];
    [cancelButton setAction:@selector(cancelSelectiveBackup:)];
    [cancelButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:cancelButton];
    
    // å…¨é€‰æŒ‰é’®
    NSButton *selectAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(20, 20, 60, 32)];
    [selectAllButton setTitle:@"å…¨é€‰"];
    [selectAllButton setTarget:self];
    [selectAllButton setAction:@selector(selectAllDataTypes:)];
    [selectAllButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:selectAllButton];
    
    // æ¸…ç©ºæŒ‰é’®
    NSButton *clearAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(100, 20, 60, 32)];
    [clearAllButton setTitle:@"æ¸…ç©º"];
    [clearAllButton setTarget:self];
    [clearAllButton setAction:@selector(clearAllDataTypes:)];
    [clearAllButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:clearAllButton];
    
    // è¿›åº¦æŒ‡ç¤ºå™¨
    self.selectiveBackupProgress = [[NSProgressIndicator alloc] initWithFrame:NSMakeRect(20, 60, 460, 20)];
    [self.selectiveBackupProgress setStyle:NSProgressIndicatorStyleBar];
    [self.selectiveBackupProgress setMinValue:0.0];
    [self.selectiveBackupProgress setMaxValue:100.0];
    [self.selectiveBackupProgress setHidden:YES];
    [contentView addSubview:self.selectiveBackupProgress];
    
    // çŠ¶æ€æ ‡ç­¾
    self.selectiveBackupStatusLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(20, 85, 460, 20)];
    [self.selectiveBackupStatusLabel setBezeled:NO];
    [self.selectiveBackupStatusLabel setDrawsBackground:NO];
    [self.selectiveBackupStatusLabel setEditable:NO];
    [self.selectiveBackupStatusLabel setStringValue:@""];
    [contentView addSubview:self.selectiveBackupStatusLabel];
}

- (void)createSelectiveBackupInstructions:(NSView *)contentView {
    NSTextField *instructionLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(20, 520, 460, 60)];
    [instructionLabel setBezeled:NO];
    [instructionLabel setDrawsBackground:NO];
    [instructionLabel setEditable:NO];
    [instructionLabel setStringValue:@"é€‰æ‹©è¦å¤‡ä»½çš„æ•°æ®ç±»å‹ã€‚ç³»ç»Ÿå°†åªå¤‡ä»½æ‚¨é€‰æ‹©çš„æ•°æ®ç±»å‹ï¼Œè¿™å¯ä»¥èŠ‚çœæ—¶é—´å’Œå­˜å‚¨ç©ºé—´ã€‚\n\næ³¨æ„ï¼šé€‰æ‹©æ€§å¤‡ä»½å¯èƒ½ä¸åŒ…å«å®Œæ•´çš„è®¾å¤‡è¿˜åŸä¿¡æ¯ã€‚"];
    [instructionLabel setFont:[NSFont systemFontOfSize:12]];
    [instructionLabel setTextColor:[NSColor secondaryLabelColor]];
    [contentView addSubview:instructionLabel];
}

#pragma mark - âœ… é€‰æ‹©æ€§å¤‡ä»½æ“ä½œæ–¹æ³•

- (IBAction)dataTypeCheckboxChanged:(NSButton *)sender {
    BackupDataType dataType = (BackupDataType)sender.tag;
    
    if (sender.state == NSControlStateValueOn) {
        self.selectedDataTypes |= dataType;
        NSLog(@"é€‰ä¸­æ•°æ®ç±»å‹: %@", [BackupOptionTask stringForDataType:dataType]);
    } else {
        self.selectedDataTypes &= ~dataType;
        NSLog(@"å–æ¶ˆé€‰ä¸­æ•°æ®ç±»å‹: %@", [BackupOptionTask stringForDataType:dataType]);
    }
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
    [self updateSelectionStatistics];
    
    [self updateSelectiveBackupButtonStates];
}

// æ›´æ–°åº•éƒ¨ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
- (void)updateSelectionStatistics {
    NSDictionary *stats = [self getSelectedDataTypesStatistics];
    NSUInteger typeCount = [stats[@"typeCount"] unsignedIntegerValue];
    
    if (typeCount > 0) {
        NSString *statsText = [NSString stringWithFormat:@"å·²é€‰æ‹© %lu ç§æ•°æ®ç±»å‹ï¼Œå…± %@ é¡¹ï¼Œå¤§å°çº¦ %@",
                              (unsigned long)typeCount,
                              stats[@"totalItems"],
                              stats[@"formattedSize"]];
        [self.selectiveBackupStatusLabel setStringValue:statsText];
    } else {
        [self.selectiveBackupStatusLabel setStringValue:@"è¯·é€‰æ‹©è¦å¤‡ä»½çš„æ•°æ®ç±»å‹"];
    }
}

// è·å–é€‰ä¸­çš„æ•°æ®ç±»å‹ç»Ÿè®¡
- (NSDictionary *)getSelectedDataTypesStatistics {
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    NSMutableArray *selectedTypeNames = [NSMutableArray array];
    
    for (NSButton *checkbox in self.dataTypeCheckboxes) {
        if (checkbox.state == NSControlStateValueOn) {
            BackupDataType dataType = (BackupDataType)checkbox.tag;
            NSNumber *dataTypeKey = @(dataType);  // âœ… å…ˆåˆ›å»ºNSNumberå¯¹è±¡
            NSDictionary *scanData = self.deviceScannedData[dataTypeKey];  // âœ… ä½¿ç”¨NSNumberå¯¹è±¡ä½œä¸ºkey
            
            if (scanData) {
                totalItems += [scanData[@"itemCount"] unsignedIntegerValue];
                totalSize += [scanData[@"totalSize"] unsignedIntegerValue];
                
                NSString *typeName = [BackupOptionTask stringForDataType:dataType];
                [selectedTypeNames addObject:typeName];
            }
        }
    }
    
    return @{
        @"totalItems": @(totalItems),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatSize:totalSize],
        @"selectedTypes": [selectedTypeNames copy],
        @"typeCount": @(selectedTypeNames.count)
    };
}

- (IBAction)selectAllDataTypes:(id)sender {
    for (NSButton *checkbox in self.dataTypeCheckboxes) {
        if (checkbox.isEnabled) {
            [checkbox setState:NSControlStateValueOn];
            BackupDataType dataType = (BackupDataType)checkbox.tag;
            self.selectedDataTypes |= dataType;
        }
    }
    
    [self updateSelectiveBackupButtonStates];
    NSLog(@"å·²é€‰æ‹©æ‰€æœ‰å¯ç”¨çš„æ•°æ®ç±»å‹");
}

- (IBAction)clearAllDataTypes:(id)sender {
    for (NSButton *checkbox in self.dataTypeCheckboxes) {
        [checkbox setState:NSControlStateValueOff];
    }
    
    self.selectedDataTypes = BackupDataTypeNone;
    [self updateSelectiveBackupButtonStates];
    NSLog(@"å·²æ¸…ç©ºæ‰€æœ‰æ•°æ®ç±»å‹é€‰æ‹©");
}

- (void)updateSelectiveBackupButtonStates {
    // è¿™é‡Œå¯ä»¥æ ¹æ®é€‰æ‹©çŠ¶æ€æ›´æ–°æŒ‰é’®å¯ç”¨æ€§
    // ä¾‹å¦‚ï¼šå¦‚æœæ²¡æœ‰é€‰æ‹©ä»»ä½•æ•°æ®ç±»å‹ï¼Œç¦ç”¨å¼€å§‹å¤‡ä»½æŒ‰é’®
}

- (IBAction)startSelectiveBackup:(id)sender {
    NSLog(@"DeviceBackupRestore: å¼€å§‹é€‰æ‹©æ€§å¤‡ä»½");
    
    if (self.selectedDataTypes == BackupDataTypeNone) {
        [self showAlert:@"æœªé€‰æ‹©æ•°æ®ç±»å‹" informativeText:@"è¯·è‡³å°‘é€‰æ‹©ä¸€ç§è¦å¤‡ä»½çš„æ•°æ®ç±»å‹"];
        return;
    }
    
    // âœ… å…³é”®ä¿®å¤ï¼šä¿å­˜å½“å‰è®¾å¤‡ä¿¡æ¯
    [self saveCurrentDeviceInfoForSelectiveBackup];
    
    // æ˜¾ç¤ºè¿›åº¦æŒ‡ç¤ºå™¨
    [self.selectiveBackupProgress setHidden:NO];
    [self.selectiveBackupProgress setDoubleValue:0.0];
    [self.selectiveBackupStatusLabel setStringValue:@"æ­£åœ¨å‡†å¤‡é€‰æ‹©æ€§å¤‡ä»½..."];
    
    // åˆ›å»ºå¤‡ä»½ç›®å½•
    NSString *backupPath = [self createSelectiveBackupDirectory];
    if (!backupPath) {
        [self showAlert:@"åˆ›å»ºå¤‡ä»½ç›®å½•å¤±è´¥" informativeText:@"æ— æ³•åˆ›å»ºé€‰æ‹©æ€§å¤‡ä»½ç›®å½•"];
        [self restoreDeviceInfoAfterSelectiveBackup]; // æ¢å¤è®¾å¤‡ä¿¡æ¯
        return;
    }
    
    // æ˜¾ç¤ºæ—¥å¿—
    NSString *startMessage = [NSString stringWithFormat:@"å¼€å§‹é€‰æ‹©æ€§å¤‡ä»½ï¼Œæ•°æ®ç±»å‹: %luï¼Œå¤‡ä»½è·¯å¾„: %@",
                            (unsigned long)self.selectedDataTypes, [backupPath lastPathComponent]];
    [self showLogsWithMessage:startMessage];
    
    // å¼€å§‹å¤‡ä»½
    NSError *error = nil;
    BOOL started = [self.backupOptionTask backupSelectedDataTypes:self.selectedDataTypes
                                                      toDirectory:backupPath
                                                            error:&error];
    
    if (!started) {
        NSString *errorMsg = [NSString stringWithFormat:@"[ERR] é€‰æ‹©æ€§å¤‡ä»½å¯åŠ¨å¤±è´¥: %@",
                            error.localizedDescription ?: @"æœªçŸ¥é”™è¯¯"];
        [self showLogsWithMessage:errorMsg];
        [self showAlert:@"å¤‡ä»½å¯åŠ¨å¤±è´¥" informativeText:error.localizedDescription ?: @"æœªçŸ¥é”™è¯¯"];
        
        // éšè—è¿›åº¦æŒ‡ç¤ºå™¨å¹¶æ¢å¤è®¾å¤‡ä¿¡æ¯
        [self.selectiveBackupProgress setHidden:YES];
        [self.selectiveBackupStatusLabel setStringValue:@""];
        [self restoreDeviceInfoAfterSelectiveBackup];
    }
}


#pragma mark - âœ… æ–°å¢ï¼šè®¾å¤‡ä¿¡æ¯ä¿å­˜å’Œæ¢å¤æ–¹æ³•

- (void)saveCurrentDeviceInfoForSelectiveBackup {
    NSLog(@"DeviceBackupRestore: ä¿å­˜é€‰æ‹©æ€§å¤‡ä»½å‰çš„è®¾å¤‡ä¿¡æ¯");
    
    // ä¿å­˜å½“å‰çš„è®¾å¤‡ä¿¡æ¯
    self.savedDeviceIDForSelectiveBackup = [self.lockedDeviceID copy];
    self.savedDeviceInfoForSelectiveBackup = [self.LockedDeviceInfo copy];
    
    NSLog(@"DeviceBackupRestore: å·²ä¿å­˜è®¾å¤‡ä¿¡æ¯ - ID: %@, Info: %@",
          self.savedDeviceIDForSelectiveBackup, self.savedDeviceInfoForSelectiveBackup);
}

- (void)restoreDeviceInfoAfterSelectiveBackup {
    NSLog(@"DeviceBackupRestore: æ¢å¤é€‰æ‹©æ€§å¤‡ä»½åçš„è®¾å¤‡ä¿¡æ¯");
    
    if (self.savedDeviceIDForSelectiveBackup && self.savedDeviceInfoForSelectiveBackup) {
        // æ¢å¤è®¾å¤‡ä¿¡æ¯
        self.lockedDeviceID = self.savedDeviceIDForSelectiveBackup;
        self.LockedDeviceInfo = self.savedDeviceInfoForSelectiveBackup;
        
        NSLog(@"DeviceBackupRestore: å·²æ¢å¤è®¾å¤‡ä¿¡æ¯ - ID: %@", self.lockedDeviceID);
        
        // æ¸…ç©ºä¿å­˜çš„ä¿¡æ¯
        self.savedDeviceIDForSelectiveBackup = nil;
        self.savedDeviceInfoForSelectiveBackup = nil;
    } else {
        NSLog(@"DeviceBackupRestore: è­¦å‘Š - æ²¡æœ‰ä¿å­˜çš„è®¾å¤‡ä¿¡æ¯å¯æ¢å¤");
    }
}

- (NSString *)createSelectiveBackupDirectory {
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    NSString *deviceBackupPath = [defaultBackupPath stringByAppendingPathComponent:self.lockedDeviceID];
    
    // åˆ›å»ºé€‰æ‹©æ€§å¤‡ä»½å­ç›®å½•
    NSString *timestamp = [self generateBackupTimestamp];
    NSString *selectiveBackupDir = [NSString stringWithFormat:@"%@", timestamp];
    NSString *fullBackupPath = [deviceBackupPath stringByAppendingPathComponent:selectiveBackupDir];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    
    BOOL success = [fileManager createDirectoryAtPath:fullBackupPath
                           withIntermediateDirectories:YES
                                            attributes:nil
                                                 error:&error];
    
    if (!success) {
        NSLog(@"åˆ›å»ºé€‰æ‹©æ€§å¤‡ä»½ç›®å½•å¤±è´¥: %@", error.localizedDescription);
        return nil;
    }
    
    // âœ… åˆ›å»ºé€‰æ‹©æ€§å¤‡ä»½æ ‡è¯†æ–‡ä»¶ï¼Œç¡®ä¿èƒ½è¢«è¯†åˆ«
    NSString *selectiveMetadataPath = [fullBackupPath stringByAppendingPathComponent:@"selective_backup_metadata.plist"];
    NSDictionary *selectiveMetadata = @{
        @"backupType": @"selective",
        @"deviceID": self.lockedDeviceID ?: @"",
        @"deviceName": self.LockedDeviceInfo[@"officialName"] ?: @"Unknown Device",
        @"deviceType": self.LockedDeviceInfo[@"type"] ?: @"iPhone",
        @"backupDate": [NSDate date],
        @"selectedDataTypes": @(self.selectedDataTypes)
    };
    
    [selectiveMetadata writeToFile:selectiveMetadataPath atomically:YES];
    NSLog(@"å·²åˆ›å»ºé€‰æ‹©æ€§å¤‡ä»½æ ‡è¯†æ–‡ä»¶: %@", selectiveMetadataPath);
    
    return fullBackupPath;
}

#pragma mark - å–æ¶ˆé€‰æ‹©æ€§å¤‡ä»½æ–¹æ³•

- (IBAction)cancelSelectiveBackup:(id)sender {
    NSLog(@"DeviceBackupRestore: å–æ¶ˆé€‰æ‹©æ€§å¤‡ä»½");
    
    // å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„å¤‡ä»½
    [self.backupOptionTask cancelCurrentOperation];
    
    // âœ… æ¢å¤è®¾å¤‡ä¿¡æ¯
    [self restoreDeviceInfoAfterSelectiveBackup];
    
    // å…³é—­çª—å£
    [self.selectiveBackupWindow close];
    self.selectiveBackupWindow = nil;
    
    [self showLogsWithMessage:@"é€‰æ‹©æ€§å¤‡ä»½å·²å–æ¶ˆ"];
}

#pragma mark - âœ… é€‰æ‹©æ€§å¤‡ä»½å›è°ƒå¤„ç†

- (void)updateSelectiveBackupProgress:(float)progress
                            operation:(NSString *)operation
                              current:(NSUInteger)current
                                total:(NSUInteger)total {
    
    [self.selectiveBackupProgress setDoubleValue:progress];
    
    NSString *statusText = [NSString stringWithFormat:@"%@ (%.1f%%) - %lu/%lu",
                          operation ?: @"å¤„ç†ä¸­", progress, (unsigned long)current, (unsigned long)total];
    [self.selectiveBackupStatusLabel setStringValue:statusText];
    
    // ä¹Ÿæ›´æ–°ä¸»è¿›åº¦è§†å›¾
    if (self.backupProgressViewController) {
        [self.backupProgressViewController updateProgress:progress];
    }
}

- (void)updateSelectiveBackupStatus:(SyncTaskStatus)status description:(NSString *)description {
    NSString *statusMessage = [NSString stringWithFormat:@"çŠ¶æ€: %@", description ?: @"å¤„ç†ä¸­"];
    [self.selectiveBackupStatusLabel setStringValue:statusMessage];
    
    NSString *logMessage = [NSString stringWithFormat:@"é€‰æ‹©æ€§å¤‡ä»½çŠ¶æ€æ›´æ–°: %@", description];
    [self showLogsWithMessage:logMessage];
}

//é€‰æ‹©æ€§å¤‡ä»½å®Œæˆå¤„ç†æ–¹æ³•
- (void)handleSelectiveBackupCompletion:(BOOL)success
                         completedTypes:(BackupDataType)completedTypes
                                  error:(NSError *)error {
    
    NSLog(@"DeviceBackupRestore: é€‰æ‹©æ€§å¤‡ä»½å®Œæˆå¤„ç†å¼€å§‹");
    
    // éšè—è¿›åº¦æŒ‡ç¤ºå™¨
    [self.selectiveBackupProgress setHidden:YES];
    
    // âœ… å…³é”®ä¿®å¤ï¼šå…ˆæ¢å¤è®¾å¤‡ä¿¡æ¯ï¼Œå†å¤„ç†åç»­é€»è¾‘
    [self restoreDeviceInfoAfterSelectiveBackup];
    
    if (success) {
        NSString *successMessage = [NSString stringWithFormat:@"[SUC] é€‰æ‹©æ€§å¤‡ä»½å®Œæˆï¼Œå·²å¤‡ä»½ %lu ç§æ•°æ®ç±»å‹",
                                  (unsigned long)[self countDataTypes:completedTypes]];
        [self showLogsWithMessage:successMessage];
        [self.selectiveBackupStatusLabel setStringValue:@"å¤‡ä»½å®Œæˆ"];
        
        // æ˜¾ç¤ºå®Œæˆå¯¹è¯æ¡†
        [self showAlert:@"å¤‡ä»½å®Œæˆ" informativeText:@"é€‰æ‹©æ€§å¤‡ä»½å·²æˆåŠŸå®Œæˆ"];
        
        // âœ… ä¿®å¤ï¼šå»¶è¿Ÿåˆ·æ–°å¤‡ä»½åˆ—è¡¨ï¼Œç¡®ä¿è®¾å¤‡ä¿¡æ¯å·²æ¢å¤
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            NSLog(@"DeviceBackupRestore: å¼€å§‹åˆ·æ–°å¤‡ä»½åˆ—è¡¨ï¼Œå½“å‰è®¾å¤‡ID: %@", self.lockedDeviceID);
            [self.backupProgressViewController checkAndLoadExistingBackupData];
        });
        
        // å»¶è¿Ÿå…³é—­çª—å£
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self.selectiveBackupWindow close];
            self.selectiveBackupWindow = nil;
        });
        
    } else {
        NSString *errorMessage = [NSString stringWithFormat:@"[ERR] é€‰æ‹©æ€§å¤‡ä»½å¤±è´¥: %@",
                                error.localizedDescription ?: @"æœªçŸ¥é”™è¯¯"];
        [self showLogsWithMessage:errorMessage];
        [self.selectiveBackupStatusLabel setStringValue:@"å¤‡ä»½å¤±è´¥"];
        
        [self showAlert:@"å¤‡ä»½å¤±è´¥" informativeText:error.localizedDescription ?: @"é€‰æ‹©æ€§å¤‡ä»½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯"];
    }
    
    NSLog(@"DeviceBackupRestore: é€‰æ‹©æ€§å¤‡ä»½å®Œæˆå¤„ç†ç»“æŸ");
}

#pragma mark - âœ… é€‰æ‹©æ€§æ¢å¤åŠŸèƒ½

- (IBAction)showSelectiveRestoreOptions:(id)sender {
    NSLog(@"DeviceBackupRestore: æ˜¾ç¤ºé€‰æ‹©æ€§æ¢å¤é€‰é¡¹");
    
    // éªŒè¯è®¾å¤‡è¿æ¥
    if (![self validateDeviceConnection]) {
        return;
    }
    
    // è·å–å¯ç”¨çš„å¤‡ä»½
    [self showSelectiveRestoreBackupSelection];
}

- (void)showSelectiveRestoreBackupSelection {
    // è¿™é‡Œå¯ä»¥å®ç°é€‰æ‹©æ€§æ¢å¤çš„UI
    // 1. åˆ—å‡ºå¯ç”¨çš„å¤‡ä»½
    // 2. è®©ç”¨æˆ·é€‰æ‹©è¦æ¢å¤çš„å¤‡ä»½
    // 3. æ˜¾ç¤ºè¯¥å¤‡ä»½ä¸­å¯ç”¨çš„æ•°æ®ç±»å‹
    // 4. è®©ç”¨æˆ·é€‰æ‹©è¦æ¢å¤çš„æ•°æ®ç±»å‹
    
    [self showAlert:@"åŠŸèƒ½å¼€å‘ä¸­" informativeText:@"é€‰æ‹©æ€§æ¢å¤åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­ï¼Œæ•¬è¯·æœŸå¾…"];
}

#pragma mark - âœ… è¯Šæ–­å’Œè°ƒè¯•åŠŸèƒ½

- (IBAction)diagnoseSelectiveBackupCapabilities:(id)sender {
    NSLog(@"DeviceBackupRestore: è¯Šæ–­é€‰æ‹©æ€§å¤‡ä»½èƒ½åŠ›");
    
    if (![self validateDeviceConnection]) {
        return;
    }
    
    [self showLogsWithMessage:@"æ­£åœ¨è¯Šæ–­è®¾å¤‡çš„é€‰æ‹©æ€§å¤‡ä»½èƒ½åŠ›..."];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (connected) {
                [self.backupOptionTask diagnoseDeviceSyncCapabilities];
                [self showLogsWithMessage:@"è®¾å¤‡è¯Šæ–­å®Œæˆï¼Œè¯·æŸ¥çœ‹æ—¥å¿—è¯¦æƒ…"];
            } else {
                NSString *errorMsg = [NSString stringWithFormat:@"[ERR] æ— æ³•è¿æ¥è®¾å¤‡è¿›è¡Œè¯Šæ–­: %@",
                                    error.localizedDescription ?: @"æœªçŸ¥é”™è¯¯"];
                [self showLogsWithMessage:errorMsg];
            }
        });
    });
}

#pragma mark - âœ… ä¾¿æ·å¤‡ä»½æ–¹æ³•

- (IBAction)quickBackupContacts:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeContacts typeName:@"è”ç³»äºº"];
}

- (IBAction)quickBackupCalendars:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeCalendars typeName:@"æ—¥å†"];
}

- (IBAction)quickBackupBookmarks:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeBookmarks typeName:@"ä¹¦ç­¾"];
}

- (IBAction)quickBackupNotes:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeNotes typeName:@"å¤‡å¿˜å½•"];
}

- (void)performQuickBackupForDataType:(BackupDataType)dataType typeName:(NSString *)typeName {
    if (![self validateDeviceConnection]) {
        return;
    }
    
    [self showLogsWithMessage:[NSString stringWithFormat:@"å¼€å§‹å¿«é€Ÿå¤‡ä»½%@...", typeName]];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
        
        if (connected) {
            // åˆ›å»ºå¤‡ä»½ç›®å½•
            NSString *backupPath = [self createSelectiveBackupDirectory];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                if (backupPath) {
                    NSError *backupError = nil;
                    BOOL started = [self.backupOptionTask backupSelectedDataTypes:dataType
                                                                      toDirectory:backupPath
                                                                            error:&backupError];
                    
                    if (started) {
                        [self showLogsWithMessage:[NSString stringWithFormat:@"æ­£åœ¨å¤‡ä»½%@ï¼Œè¯·ç­‰å¾…å®Œæˆ...", typeName]];
                    } else {
                        NSString *errorMsg = [NSString stringWithFormat:@"[ERR] %@å¤‡ä»½å¯åŠ¨å¤±è´¥: %@",
                                            typeName, backupError.localizedDescription ?: @"æœªçŸ¥é”™è¯¯"];
                        [self showLogsWithMessage:errorMsg];
                    }
                } else {
                    [self showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@å¤‡ä»½ç›®å½•åˆ›å»ºå¤±è´¥", typeName]];
                }
            });
        } else {
            dispatch_async(dispatch_get_main_queue(), ^{
                NSString *errorMsg = [NSString stringWithFormat:@"[ERR] %@å¤‡ä»½è¿æ¥å¤±è´¥: %@",
                                    typeName, error.localizedDescription ?: @"æœªçŸ¥é”™è¯¯"];
                [self showLogsWithMessage:errorMsg];
            });
        }
    });
}

- (BOOL)validateDeviceConnection {
    if (!self.lockedDeviceID || self.lockedDeviceID.length == 0) {
        [self showAlert:@"è®¾å¤‡æœªé€‰æ‹©"
         informativeText:@"è¯·å…ˆé€‰æ‹©è¦å¤‡ä»½çš„è®¾å¤‡"];
        return NO;
    }
    
   // if (![self.currentDeviceMode isEqualToString:@"Normal"]) {
       // [self showAlert:@"è®¾å¤‡çŠ¶æ€é”™è¯¯"
       //  informativeText:@"è®¾å¤‡å¿…é¡»å¤„äºæ­£å¸¸æ¨¡å¼æ‰èƒ½è¿›è¡Œé€‰æ‹©æ€§å¤‡ä»½"];
       // return NO;
   // }
    
    return YES;
}


@end



//
//  BackupProgressViewController.m
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import "BackupProgressViewController.h"
#import "DeviceManager.h" // å¼•å…¥è®¾å¤‡ç®¡ç†æ¨¡å—
#import "DatalogsSettings.h"//æ—¥å¿—ä¿å­˜è·¯å¾„å…¨å±€
#import "LanguageManager.h" //è¯­è¨€
#import "CurrentHistoryController.h" //å†å²æ“ä½œè®°å½•
#import "SidebarViewController.h"
#import "LogUtility.h" // è‡ªå®šä¹‰æ—¥å¿—å‡½æ•°LogWithTimestampï¼Œè‡ªåŠ¨æ·»åŠ æ—¶é—´æˆ³
#import "LogManager.h" //å…¨å±€æ—¥å¿—åŒºåŸŸ
#import "BackupTask.h"
#import "DeviceBackupRestore.h"
#import <sqlite3.h>


@interface BackupProgressViewController ()
@property (nonatomic, strong) NSArray *backupDirectories; // æ”¹ä¸ºå¤‡ä»½ç›®å½•åˆ—è¡¨
@end

@implementation BackupProgressViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"BackupProgressViewController: viewDidLoad");
    
    // åˆå§‹åŒ–å¤‡ä»½ç›®å½•åˆ—è¡¨
    self.backupDirectories = @[];
    
    // è®¾ç½®è¡¨æ ¼è§†å›¾
    [self.tableView setDataSource:self];
    [self.tableView setDelegate:self];
    
    // è®¾ç½®è¿›åº¦æ¡
    [self.progressBar setMinValue:0.0];
    [self.progressBar setMaxValue:100.0];
    [self.progressBar setDoubleValue:0.0];
    
    // è®¾ç½®æ–‡æœ¬è§†å›¾
    [self.logTextView setEditable:NO];
    [self.logTextView setFont:[NSFont fontWithName:@"Menlo" size:12.0]];
    self.collectedLogs = [[NSMutableString alloc] init]; // åˆå§‹åŒ–æ—¥å¿—ç¼“å­˜
    
    NSLog(@"BackupProgressViewController: æ§ä»¶å·²åˆå§‹åŒ–");
    
    //------æ·»åŠ å…¨å±€æ—¥å¿—start-----------
    [[LogManager sharedManager] attachLogToViewController:self];

    NSScrollView *logScrollView = [LogManager sharedManager].logScrollView;

    // è®¾ç½®å¸ƒå±€
    logScrollView.frame = NSMakeRect(0, 3, 852, 360);

    // ç¡®ä¿å…ˆä»ä¹‹å‰çš„çˆ¶è§†å›¾ç§»é™¤ï¼ˆé¿å…é‡å¤æ·»åŠ åˆ°å¤šä¸ªçˆ¶è§†å›¾ï¼‰
    [logScrollView removeFromSuperview];

    // å°† logScrollView æ·»åŠ åˆ°å½“å‰è§†å›¾å¹¶æ§åˆ¶å…¶å±‚çº§
    [self.view addSubview:logScrollView positioned:NSWindowBelow relativeTo:nil]; // æ·»åŠ åˆ°è¾ƒä½å±‚çº§

    //------æ·»åŠ å…¨å±€æ—¥å¿—end-----------
}

- (void)viewWillAppear {
    [super viewWillAppear];
    NSLog(@"BackupProgressViewController: viewWillAppear");
    
    // ç¡®ä¿æ—¥å¿—åŒºåŸŸåœ¨æ­£ç¡®ä½ç½®ï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
    NSScrollView *logScrollView = [LogManager sharedManager].logScrollView;
    if (logScrollView.superview != self.view) {
        // å¦‚æœæ—¥å¿—åŒºåŸŸä¸åœ¨å½“å‰è§†å›¾ä¸­ï¼Œé‡æ–°æ·»åŠ 
        [logScrollView removeFromSuperview];
        logScrollView.frame = NSMakeRect(0, -4, 1007, 293);
        [self.view addSubview:logScrollView positioned:NSWindowBelow relativeTo:nil];
        NSLog(@"BackupProgressViewController: é‡æ–°æ·»åŠ æ—¥å¿—åŒºåŸŸ");
    }
    
    // åªåœ¨è¡¨æ ¼ä¸ºç©ºæ—¶æ‰å°è¯•åŠ è½½æ•°æ®
    if (self.backupDirectories.count == 0) {
        NSLog(@"BackupProgressViewController: è¡¨æ ¼ä¸ºç©ºï¼Œå°è¯•åŠ è½½ç°æœ‰å¤‡ä»½ç›®å½•");
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self checkAndLoadExistingBackupData];
        });
    }
}

- (void)viewWillDisappear {
    [super viewWillDisappear];
    NSLog(@"BackupProgressViewController: viewWillDisappear");
    // å¯ä»¥é€‰æ‹©æ€§åœ°åœ¨è¿™é‡Œåšä¸€äº›æ¸…ç†ï¼Œä½†é€šå¸¸ä¸éœ€è¦
}

// ä¾¿æ·çš„æ—¥å¿—æ–¹æ³•
- (void)addLogMessage:(NSString *)message {
    [[LogManager sharedManager] addLogMessage:message forViewController:self];
}

- (void)clearLogs {
    [[LogManager sharedManager] clearLogForViewController:self];
}

#pragma mark - å…¬å…±æ–¹æ³•

// ç›´æ¥æ¥æ”¶è®¾å¤‡ä¿¡æ¯å¹¶åŠ è½½å¤‡ä»½ç›®å½•
- (void)loadBackupDataForDevice:(NSString *)deviceID deviceInfo:(NSDictionary *)deviceInfo {
    NSLog(@"BackupProgressViewController: æ¥æ”¶åˆ°è®¾å¤‡ä¿¡æ¯ - ID: %@, Info: %@", deviceID, deviceInfo);
    
    // âœ… å¢åŠ è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
    if (!deviceID || deviceID.length == 0) {
        NSLog(@"BackupProgressViewController: è®¾å¤‡IDä¸ºç©ºï¼Œå°è¯•è·å–å¤‡ä»½æ•°æ®ç®¡ç†å™¨çš„è®¾å¤‡ä¿¡æ¯");
        
        // å°è¯•ä»ä¸»æ§åˆ¶å™¨å†æ¬¡è·å–è®¾å¤‡ä¿¡æ¯
        DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
        NSString *fallbackDeviceID = mainController.lockedDeviceID;
        NSDictionary *fallbackDeviceInfo = mainController.LockedDeviceInfo;
        
        NSLog(@"BackupProgressViewController: å¤‡ç”¨è®¾å¤‡ä¿¡æ¯ - ID: %@, Info: %@", fallbackDeviceID, fallbackDeviceInfo);
        
        if (fallbackDeviceID && fallbackDeviceID.length > 0) {
            NSLog(@"BackupProgressViewController: ä½¿ç”¨å¤‡ç”¨è®¾å¤‡ä¿¡æ¯");
            deviceID = fallbackDeviceID;
            deviceInfo = fallbackDeviceInfo;
        } else {
            NSLog(@"BackupProgressViewController: è®¾å¤‡IDç¡®å®ä¸ºç©ºï¼Œæ— æ³•åŠ è½½å¤‡ä»½æ•°æ®");
            dispatch_async(dispatch_get_main_queue(), ^{                
                // æ¸…ç©ºè¡¨æ ¼
                self.backupDirectories = @[];
                [self.tableView reloadData];
            });
            return;
        }
    }
    
    // ç»§ç»­åŸæœ‰çš„åŠ è½½é€»è¾‘...
    NSString *deviceName = deviceInfo[@"officialName"] ?: @"Unknown Device";
    NSString *deviceType = deviceInfo[@"type"] ?: @"Unknown Type";
    
    // è·å–å½“å‰è®¾å¤‡çš„å¤‡ä»½åŸºç¡€ç›®å½•è·¯å¾„
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    NSString *deviceBackupBasePath = [defaultBackupPath stringByAppendingPathComponent:deviceID];
    
    NSLog(@"BackupProgressViewController: å½“å‰è®¾å¤‡å¤‡ä»½åŸºç¡€è·¯å¾„: %@", deviceBackupBasePath);
    
    // æ˜¾ç¤ºè®¾å¤‡ä¿¡æ¯
    dispatch_async(dispatch_get_main_queue(), ^{
        NSString *deviceMessage = [NSString stringWithFormat:@"å½“å‰è®¾å¤‡: %@ (%@)\n", deviceName, deviceType];
        [self appendLog:deviceMessage];
    });
    
    // åªåŠ è½½å½“å‰è®¾å¤‡çš„å¤‡ä»½ç›®å½•
    NSMutableArray *currentDeviceBackups = [NSMutableArray array];
    [self loadCurrentDeviceBackupDirectories:deviceBackupBasePath
                                    deviceID:deviceID
                                  deviceName:deviceName
                                     toArray:currentDeviceBackups];
    
    NSLog(@"BackupProgressViewController: å½“å‰è®¾å¤‡å¤‡ä»½ç›®å½•æ•°é‡: %lu", (unsigned long)currentDeviceBackups.count);
    
    if (currentDeviceBackups.count > 0) {
        NSLog(@"BackupProgressViewController: æ‰¾åˆ° %lu ä¸ªå½“å‰è®¾å¤‡çš„å¤‡ä»½ç›®å½•", (unsigned long)currentDeviceBackups.count);
        
        // æ›´æ–°è¡¨æ ¼æ•°æ®
        dispatch_async(dispatch_get_main_queue(), ^{
            self.backupDirectories = [currentDeviceBackups copy];
            [self.tableView reloadData];
            
            // âœ… åˆ·æ–°å®Œæˆåçš„é™„åŠ æ“ä½œ
            [self onBackupListRefreshed:currentDeviceBackups.count];
            
            NSLog(@"BackupProgressViewController: è¡¨æ ¼å·²é‡æ–°åŠ è½½ï¼Œå½“å‰è¡Œæ•°: %ld", [self.tableView numberOfRows]);
        });
    } else {
        NSLog(@"BackupProgressViewController: å½“å‰è®¾å¤‡æ²¡æœ‰æ‰¾åˆ°å¤‡ä»½ç›®å½•");
        dispatch_async(dispatch_get_main_queue(), ^{
            self.backupDirectories = @[]; // æ¸…ç©ºåˆ—è¡¨
            [self.tableView reloadData];
            [self appendLog:@"å½“å‰è®¾å¤‡æš‚æ— å¤‡ä»½æ•°æ®\n"];
        });
    }
}

// å¤‡ä»½åˆ—è¡¨åˆ·æ–°å®Œæˆåçš„å›è°ƒ
- (void)onBackupListRefreshed:(NSUInteger)backupCount {
    NSLog(@"BackupProgressViewController: å¤‡ä»½åˆ—è¡¨åˆ·æ–°å®Œæˆï¼Œå…± %lu é¡¹", (unsigned long)backupCount);
    
    // æ˜¾ç¤ºåŠ è½½ä¿¡æ¯
    NSString *loadMessage = [NSString stringWithFormat:@"å·²åˆ·æ–°å½“å‰è®¾å¤‡çš„ %lu ä¸ªå¤‡ä»½ç›®å½•\n", (unsigned long)backupCount];
    [self appendLog:loadMessage];
    
    // å¦‚æœæœ‰å¤‡ä»½é¡¹ï¼Œè‡ªåŠ¨é€‰ä¸­æœ€æ–°çš„
    if (backupCount > 0 && self.tableView.numberOfRows > 0) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self.tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:0] byExtendingSelection:NO];
            [self.tableView scrollRowToVisible:0];
        });
    }
}


- (IBAction)refreshBackupList:(id)sender {
    NSLog(@"BackupProgressViewController: æ‰‹åŠ¨åˆ·æ–°å¤‡ä»½åˆ—è¡¨");
    [self forceRefreshBackupList];
}

// æ–°æ–¹æ³•ï¼šåªåŠ è½½å½“å‰è®¾å¤‡çš„å¤‡ä»½ç›®å½•ï¼ˆæ”¯æŒæ—¶é—´æˆ³å­ç›®å½•ï¼‰
- (void)loadCurrentDeviceBackupDirectories:(NSString *)deviceBackupBasePath
                                  deviceID:(NSString *)deviceID
                                deviceName:(NSString *)deviceName
                                   toArray:(NSMutableArray *)backupDirs {
    NSLog(@"BackupProgressViewController: å¼€å§‹åŠ è½½å½“å‰è®¾å¤‡å¤‡ä»½ç›®å½•: %@", deviceBackupBasePath);
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // æ£€æŸ¥è®¾å¤‡åŸºç¡€ç›®å½•æ˜¯å¦å­˜åœ¨
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:deviceBackupBasePath isDirectory:&isDirectory] || !isDirectory) {
        NSLog(@"BackupProgressViewController: è®¾å¤‡å¤‡ä»½åŸºç¡€ç›®å½•ä¸å­˜åœ¨: %@", deviceBackupBasePath);
        return;
    }
    
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:deviceBackupBasePath error:&error];
    
    if (error || !contents) {
        NSLog(@"BackupProgressViewController: æ— æ³•è¯»å–è®¾å¤‡å¤‡ä»½ç›®å½•: %@", error.localizedDescription);
        return;
    }
    
    NSLog(@"BackupProgressViewController: åœ¨è®¾å¤‡ç›®å½•ä¸­æ‰¾åˆ° %lu ä¸ªé¡¹ç›®", (unsigned long)contents.count);
    
    // éå†è®¾å¤‡ç›®å½•ä¸‹çš„æ‰€æœ‰æ—¶é—´æˆ³ç›®å½•
    for (NSString *item in contents) {
        NSString *itemPath = [deviceBackupBasePath stringByAppendingPathComponent:item];
        BOOL itemIsDirectory = NO;
        
        if ([fileManager fileExistsAtPath:itemPath isDirectory:&itemIsDirectory] && itemIsDirectory) {
            NSLog(@"BackupProgressViewController: æ£€æŸ¥æ—¶é—´æˆ³ç›®å½•: %@", item);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ—¶é—´æˆ³æ ¼å¼çš„ç›®å½•åï¼ˆå¦‚202505271018AMï¼‰
            if ([self isTimestampDirectoryName:item]) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å¤‡ä»½ç›®å½•
                if ([self isValidBackupDirectory:itemPath]) {
                    // è·å–ç›®å½•ä¿¡æ¯
                    NSDictionary *dirInfo = [self getCurrentDeviceBackupDirectoryInfo:itemPath
                                                                             deviceID:deviceID
                                                                           deviceName:deviceName
                                                                        timestampDir:item];
                    if (dirInfo) {
                        [backupDirs addObject:dirInfo];
                        NSLog(@"BackupProgressViewController: æ·»åŠ å½“å‰è®¾å¤‡å¤‡ä»½ç›®å½•: %@", item);
                    }
                } else {
                    NSLog(@"BackupProgressViewController: è·³è¿‡æ— æ•ˆçš„æ—¶é—´æˆ³ç›®å½•: %@", item);
                }
            } else {
                NSLog(@"BackupProgressViewController: è·³è¿‡éæ—¶é—´æˆ³æ ¼å¼ç›®å½•: %@", item);
            }
        }
    }
    
    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œæœ€æ–°çš„åœ¨å‰ï¼ˆæ ¹æ®ç›®å½•åç§°çš„æ—¶é—´æˆ³ï¼‰
    [backupDirs sortUsingComparator:^NSComparisonResult(NSDictionary *obj1, NSDictionary *obj2) {
        NSString *timestamp1 = obj1[@"timestamp"];
        NSString *timestamp2 = obj2[@"timestamp"];
        return [timestamp2 compare:timestamp1]; // å€’åºï¼Œæœ€æ–°çš„åœ¨å‰
    }];
    
    NSLog(@"BackupProgressViewController: æœ€ç»ˆåŠ è½½å½“å‰è®¾å¤‡å¤‡ä»½ç›®å½•æ•°é‡: %lu", (unsigned long)backupDirs.count);
}

// æ£€æŸ¥ç›®å½•åæ˜¯å¦ä¸ºæ—¶é—´æˆ³æ ¼å¼
- (BOOL)isTimestampDirectoryName:(NSString *)dirName {
    // æ£€æŸ¥æ ¼å¼ï¼š202505271018AM æˆ– 202505271318PM
    if (dirName.length < 12) return NO;
    
    // æ£€æŸ¥å‰12ä¸ªå­—ç¬¦æ˜¯å¦éƒ½æ˜¯æ•°å­—
    NSString *numericPart = [dirName substringToIndex:12];
    NSCharacterSet *nonNumericSet = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
    if ([numericPart rangeOfCharacterFromSet:nonNumericSet].location != NSNotFound) {
        return NO;
    }
    
    // æ£€æŸ¥æ˜¯å¦ä»¥AMæˆ–PMç»“å°¾
    if (dirName.length >= 14) {
        NSString *ampmPart = [dirName substringFromIndex:12];
        if ([ampmPart isEqualToString:@"AM"] || [ampmPart isEqualToString:@"PM"]) {
            return YES;
        }
    }
    
    return NO;
}

// è·å–å½“å‰è®¾å¤‡å¤‡ä»½ç›®å½•ä¿¡æ¯
- (NSDictionary *)getCurrentDeviceBackupDirectoryInfo:(NSString *)dirPath
                                             deviceID:(NSString *)deviceID
                                           deviceName:(NSString *)deviceName
                                        timestampDir:(NSString *)timestampDir {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // è·å–ç›®å½•å±æ€§
    NSDictionary *dirAttributes = [fileManager attributesOfItemAtPath:dirPath error:nil];
    if (!dirAttributes) {
        return nil;
    }
    
    NSDate *modificationDate = dirAttributes[NSFileModificationDate];
    NSString *dateString = [dateFormatter stringFromDate:modificationDate];
    
    // è§£ææ—¶é—´æˆ³ç›®å½•åè·å–å¤‡ä»½æ—¶é—´
    NSString *backupTimeString = [self parseTimestampFromDirectoryName:timestampDir];
    if (backupTimeString) {
        dateString = [NSString stringWithFormat:@"%@", backupTimeString];
    }
    
    // è¯»å–å¤‡ä»½ä¿¡æ¯
    NSString *infoPath = [dirPath stringByAppendingPathComponent:@"Info.plist"];
    NSDictionary *backupInfo = [NSDictionary dictionaryWithContentsOfFile:infoPath];
    
    // è·å–åŠ å¯†çŠ¶æ€
    BOOL isEncrypted = NO;
    if (backupInfo) {
        isEncrypted = [backupInfo[@"IsEncrypted"] boolValue];
    }
    
    // è®¡ç®—ç›®å½•æ€»å¤§å°
    unsigned long long totalSize = [self calculateDirectorySize:dirPath];
    NSString *sizeString = [self formatFileSize:totalSize];
    
    return @{
        @"backupitem": [NSString stringWithFormat:@"%@", timestampDir],
        @"backuplocation": dirPath,
        @"backupfilesize": sizeString,
        @"backupdate": dateString,
        @"backupdate_raw": modificationDate, // ç”¨äºæ’åº
        @"backupencryptionstatus": isEncrypted ? @"Yes" : @"No",
        @"backuptype": @"Current Device",
        @"deviceid": deviceID,
        @"timestamp": timestampDir // ç”¨äºæ’åº
    };
}

// è§£ææ—¶é—´æˆ³ç›®å½•åè·å–å¯è¯»çš„æ—¶é—´å­—ç¬¦ä¸²
- (NSString *)parseTimestampFromDirectoryName:(NSString *)dirName {
    // è§£ææ ¼å¼å¦‚ 202505271018AM æˆ– 202505271318PM
    if (dirName.length < 12) return nil;
    
    NSString *yearStr = [dirName substringWithRange:NSMakeRange(0, 4)];
    NSString *monthStr = [dirName substringWithRange:NSMakeRange(4, 2)];
    NSString *dayStr = [dirName substringWithRange:NSMakeRange(6, 2)];
    NSString *hourStr = [dirName substringWithRange:NSMakeRange(8, 2)];
    NSString *minuteStr = [dirName substringWithRange:NSMakeRange(10, 2)];
    
    NSString *ampmStr = @"";
    if (dirName.length >= 14) {
        ampmStr = [dirName substringFromIndex:12];
    }
    
    return [NSString stringWithFormat:@"%@-%@-%@ %@:%@ %@",
            yearStr, monthStr, dayStr, hourStr, minuteStr, ampmStr];
}

// âœ… ç®€åŒ–åŸæœ‰çš„æ–¹æ³•ï¼Œä¸»è¦ç”¨äºåˆå§‹åŒ–æ—¶è°ƒç”¨
- (void)checkAndLoadExistingBackupData {
    NSLog(@"BackupProgressViewController: æ£€æŸ¥ç°æœ‰å¤‡ä»½æ•°æ®ï¼ˆé€šè¿‡è·å–ä¸»æ§åˆ¶å™¨ä¿¡æ¯ï¼‰");
    
    // è·å–å½“å‰é€‰ä¸­çš„è®¾å¤‡ID
    DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
    NSString *currentDeviceID = mainController.lockedDeviceID;
    NSDictionary *deviceInfo = mainController.LockedDeviceInfo;
    
    if (currentDeviceID && currentDeviceID.length > 0) {
        [self loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            // å³ä½¿æ²¡æœ‰é€‰ä¸­è®¾å¤‡ï¼Œä¹Ÿæ˜¾ç¤ºæ‰€æœ‰å¤‡ä»½ç›®å½•
            [self loadBackupDataForDevice:@"" deviceInfo:@{}];
        });
    }
}

// æ–°æ–¹æ³•ï¼šåŠ è½½å¤‡ä»½ç›®å½•ï¼ˆè€Œä¸æ˜¯æ–‡ä»¶ï¼‰
- (void)loadBackupDirectoriesFromPath:(NSString *)backupBasePath toArray:(NSMutableArray *)backupDirs currentDeviceID:(NSString *)currentDeviceID {
    NSLog(@"BackupProgressViewController: å¼€å§‹ä»è·¯å¾„åŠ è½½å¤‡ä»½ç›®å½•: %@", backupBasePath);
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:backupBasePath error:&error];
    
    if (error || !contents) {
        NSLog(@"BackupProgressViewController: æ— æ³•è¯»å–å¤‡ä»½åŸºç¡€ç›®å½•: %@", error.localizedDescription);
        return;
    }
    
    NSLog(@"BackupProgressViewController: æ‰¾åˆ° %lu ä¸ªé¡¹ç›®åœ¨å¤‡ä»½ç›®å½•ä¸­", (unsigned long)contents.count);
    
    // éå†æ‰€æœ‰é¡¹ç›®ï¼ŒæŸ¥æ‰¾å¤‡ä»½ç›®å½•
    for (NSString *item in contents) {
        NSString *itemPath = [backupBasePath stringByAppendingPathComponent:item];
        BOOL isDirectory = NO;
        
        if ([fileManager fileExistsAtPath:itemPath isDirectory:&isDirectory] && isDirectory) {
            NSLog(@"BackupProgressViewController: æ£€æŸ¥ç›®å½•: %@", item);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å¤‡ä»½ç›®å½•
            if ([self isValidBackupDirectory:itemPath]) {
                // è·å–ç›®å½•ä¿¡æ¯
                NSDictionary *dirInfo = [self getBackupDirectoryInfo:itemPath deviceID:item currentDeviceID:currentDeviceID];
                if (dirInfo) {
                    [backupDirs addObject:dirInfo];
                    NSLog(@"BackupProgressViewController: æ·»åŠ å¤‡ä»½ç›®å½•: %@", item);
                }
            } else {
                NSLog(@"BackupProgressViewController: è·³è¿‡æ— æ•ˆç›®å½•: %@", item);
            }
        }
    }
    
    // æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼Œæœ€æ–°çš„åœ¨å‰
    [backupDirs sortUsingComparator:^NSComparisonResult(NSDictionary *obj1, NSDictionary *obj2) {
        NSDate *date1 = obj1[@"backupdate_raw"];
        NSDate *date2 = obj2[@"backupdate_raw"];
        return [date2 compare:date1];
    }];
    
    NSLog(@"BackupProgressViewController: æœ€ç»ˆåŠ è½½çš„å¤‡ä»½ç›®å½•æ•°é‡: %lu", (unsigned long)backupDirs.count);
}


// æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å¤‡ä»½ç›®å½•ï¼ˆæ”¯æŒé€‰æ‹©æ€§å¤‡ä»½ï¼‰
- (BOOL)isValidBackupDirectory:(NSString *)dirPath {
   
    // æ£€æŸ¥æ ‡å‡†å¤‡ä»½æ ¼å¼
    if ([self isStandardBackupDirectory:dirPath]) {
        return YES;
    }
    
    // âœ… æ–°å¢ï¼šæ£€æŸ¥é€‰æ‹©æ€§å¤‡ä»½æ ¼å¼
    if ([self isSelectiveBackupDirectory:dirPath]) {
        return YES;
    }
    
    return NO;
}

// æ£€æŸ¥æ ‡å‡†iTuneså¤‡ä»½ç›®å½•
- (BOOL)isStandardBackupDirectory:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // æ£€æŸ¥å¿…è¦çš„å¤‡ä»½æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    NSArray *requiredFiles = @[@"Info.plist"];
    NSArray *optionalFiles = @[@"Status.plist", @"Manifest.plist", @"Manifest.db"];
    
    // å¿…é¡»æ–‡ä»¶æ£€æŸ¥
    BOOL hasRequiredFiles = YES;
    for (NSString *file in requiredFiles) {
        NSString *filePath = [dirPath stringByAppendingPathComponent:file];
        if (![fileManager fileExistsAtPath:filePath]) {
            hasRequiredFiles = NO;
            break;
        }
    }
    
    if (!hasRequiredFiles) {
        return NO;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è‡³å°‘ä¸€ä¸ªå¯é€‰æ–‡ä»¶
    BOOL hasOptionalFile = NO;
    for (NSString *file in optionalFiles) {
        NSString *filePath = [dirPath stringByAppendingPathComponent:file];
        if ([fileManager fileExistsAtPath:filePath]) {
            hasOptionalFile = YES;
            break;
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å“ˆå¸Œç›®å½•
    BOOL hasHashDirs = NO;
    for (int i = 0; i < 16; i++) {
        NSString *hashDir = [NSString stringWithFormat:@"%02x", i];
        NSString *hashDirPath = [dirPath stringByAppendingPathComponent:hashDir];
        if ([fileManager fileExistsAtPath:hashDirPath]) {
            hasHashDirs = YES;
            break;
        }
    }
    
    return hasOptionalFile || hasHashDirs;
}

// âœ… æ–°å¢ï¼šæ£€æŸ¥é€‰æ‹©æ€§å¤‡ä»½ç›®å½•
- (BOOL)isSelectiveBackupDirectory:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // æ£€æŸ¥é€‰æ‹©æ€§å¤‡ä»½çš„ç‰¹å¾æ–‡ä»¶/ç›®å½•
    NSArray *selectiveBackupIndicators = @[
        @"Contacts",        // è”ç³»äººå¤‡ä»½ç›®å½•
        @"Calendars",       // æ—¥å†å¤‡ä»½ç›®å½•
        @"Bookmarks",       // ä¹¦ç­¾å¤‡ä»½ç›®å½•
        @"Notes",           // å¤‡å¿˜å½•å¤‡ä»½ç›®å½•
        @"Reminders",       // æé†’äº‹é¡¹å¤‡ä»½ç›®å½•
        @"Applications",    // åº”ç”¨å¤‡ä»½ç›®å½•
        @"metadata.plist",  // é€‰æ‹©æ€§å¤‡ä»½å…ƒæ•°æ®æ–‡ä»¶
        @"items.plist"      // é€‰æ‹©æ€§å¤‡ä»½é¡¹ç›®æ–‡ä»¶
    ];
    
    // åªè¦æœ‰å…¶ä¸­ä¸€ä¸ªç‰¹å¾æ–‡ä»¶/ç›®å½•å°±è®¤ä¸ºæ˜¯é€‰æ‹©æ€§å¤‡ä»½
    for (NSString *indicator in selectiveBackupIndicators) {
        NSString *indicatorPath = [dirPath stringByAppendingPathComponent:indicator];
        if ([fileManager fileExistsAtPath:indicatorPath]) {
            NSLog(@"å‘ç°é€‰æ‹©æ€§å¤‡ä»½ç‰¹å¾: %@ åœ¨ %@", indicator, [dirPath lastPathComponent]);
            return YES;
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½• .plist æ–‡ä»¶ï¼ˆé€‰æ‹©æ€§å¤‡ä»½å¯èƒ½åˆ›å»ºçš„å…ƒæ•°æ®æ–‡ä»¶ï¼‰
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:dirPath error:&error];
    if (!error && contents) {
        for (NSString *item in contents) {
            if ([item.lowercaseString hasSuffix:@".plist"]) {
                NSLog(@"å‘ç°é€‰æ‹©æ€§å¤‡ä»½plistæ–‡ä»¶: %@ åœ¨ %@", item, [dirPath lastPathComponent]);
                return YES;
            }
        }
    }
    
    return NO;
}

// è·å–å¤‡ä»½ç›®å½•ä¿¡æ¯ï¼ˆæ”¯æŒé€‰æ‹©æ€§å¤‡ä»½ï¼‰
- (NSDictionary *)getBackupDirectoryInfo:(NSString *)dirPath deviceID:(NSString *)deviceID currentDeviceID:(NSString *)currentDeviceID {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // è·å–ç›®å½•å±æ€§
    NSDictionary *dirAttributes = [fileManager attributesOfItemAtPath:dirPath error:nil];
    if (!dirAttributes) {
        return nil;
    }
    
    NSDate *modificationDate = dirAttributes[NSFileModificationDate];
    NSString *dateString = [dateFormatter stringFromDate:modificationDate];
    
    // åˆå§‹åŒ–é»˜è®¤å€¼
    NSString *deviceName = @"Unknown Device";
    NSString *deviceModel = @"Unknown Model";
    BOOL isEncrypted = NO;
    NSString *backupType = @"Unknown";
    
    // âœ… æ£€æŸ¥æ˜¯å¦æ˜¯æ ‡å‡†å¤‡ä»½è¿˜æ˜¯é€‰æ‹©æ€§å¤‡ä»½
    if ([self isStandardBackupDirectory:dirPath]) {
        // å¤„ç†æ ‡å‡†å¤‡ä»½
        NSString *infoPath = [dirPath stringByAppendingPathComponent:@"Info.plist"];
        NSDictionary *backupInfo = [NSDictionary dictionaryWithContentsOfFile:infoPath];
        
        if (backupInfo) {
            deviceName = backupInfo[@"Device Name"] ?: backupInfo[@"Display Name"] ?: @"Unknown Device";
            deviceModel = backupInfo[@"Product Type"] ?: @"Unknown Model";
            isEncrypted = [backupInfo[@"IsEncrypted"] boolValue];
        }
        
        backupType = @"Complete";
        
    } else if ([self isSelectiveBackupDirectory:dirPath]) {
        // âœ… å¤„ç†é€‰æ‹©æ€§å¤‡ä»½
        backupType = @"Selective";
        
        // å°è¯•ä»é€‰æ‹©æ€§å¤‡ä»½çš„å…ƒæ•°æ®æ–‡ä»¶è·å–ä¿¡æ¯
        NSString *metadataPath = [dirPath stringByAppendingPathComponent:@"metadata.plist"];
        NSDictionary *metadata = [NSDictionary dictionaryWithContentsOfFile:metadataPath];
        
        if (metadata) {
            deviceName = metadata[@"deviceName"] ?: @"Current Device";
            deviceModel = metadata[@"deviceType"] ?: @"iPhone";
        } else {
            // å¦‚æœæ²¡æœ‰å…ƒæ•°æ®æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤å€¼è¡¨ç¤ºé€‰æ‹©æ€§å¤‡ä»½
            deviceName = @"Current Device";
            deviceModel = @"Selective Backup";
        }
        
        // é€‰æ‹©æ€§å¤‡ä»½é€šå¸¸ä¸åŠ å¯†
        isEncrypted = NO;
    }
    
    // è®¡ç®—ç›®å½•æ€»å¤§å°
    unsigned long long totalSize = [self calculateDirectorySize:dirPath];
    NSString *sizeString = [self formatFileSize:totalSize];
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯å½“å‰è®¾å¤‡
    BOOL isCurrentDevice = [deviceID isEqualToString:currentDeviceID];
    NSString *statusString = isCurrentDevice ? @"Current" : @"Other";
    
    return @{
        @"backupitem": [NSString stringWithFormat:@"%@ (%@)", deviceName, deviceModel],
        @"backuplocation": dirPath,
        @"backupfilesize": sizeString,
        @"backupdate": dateString,
        @"backupdate_raw": modificationDate,
        @"backupencryptionstatus": isEncrypted ? @"Yes" : @"No",
        @"backuptype": [NSString stringWithFormat:@"%@ - %@", statusString, backupType], // æ˜¾ç¤ºå¤‡ä»½ç±»å‹
        @"deviceid": deviceID
    };
}


// è®¡ç®—ç›®å½•æ€»å¤§å°
- (unsigned long long)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    unsigned long long totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedLongLongValue];
        }
    }
    
    return totalSize;
}

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
- (NSString *)formatFileSize:(unsigned long long)bytes {
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    return [formatter stringFromByteCount:(long long)bytes];
}

// ä¿®æ”¹ï¼šæ›´æ–°å½“å‰å¤‡ä»½è¿‡ç¨‹ä¸­çš„æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤ºï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
- (void)updateBackupFilesList:(NSArray *)filesList {
    // å¯¹äºç›®å½•æ˜¾ç¤ºæ¨¡å¼ï¼Œæˆ‘ä»¬å¯èƒ½ä¸éœ€è¦å®æ—¶æ›´æ–°æ–‡ä»¶åˆ—è¡¨
    // æˆ–è€…å¯ä»¥åœ¨è¿™é‡Œæ›´æ–°å½“å‰æ­£åœ¨å¤‡ä»½çš„è®¾å¤‡ç›®å½•ä¿¡æ¯
    dispatch_async(dispatch_get_main_queue(), ^{
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å®æ—¶æ›´æ–°é€»è¾‘ï¼Œæ¯”å¦‚æ›´æ–°å½“å‰è®¾å¤‡çš„å¤‡ä»½çŠ¶æ€
        NSLog(@"BackupProgressViewController: å¤‡ä»½è¿‡ç¨‹ä¸­ï¼Œæ–‡ä»¶æ•°é‡: %lu", (unsigned long)filesList.count);
        
        // é‡æ–°åŠ è½½å½“å‰æ•°æ®ä»¥åæ˜ å¤‡ä»½è¿›åº¦
        [self checkAndLoadExistingBackupData];
    });
}

- (void)startBackupWithInitialLog:(NSString *)initialLog {
    NSLog(@"BackupProgressViewController: å¼€å§‹å¤‡ä»½ï¼Œåˆå§‹æ—¥å¿—: %@", initialLog);
    
    // é‡ç½®è¿›åº¦æ¡
    [self.progressBar setDoubleValue:0.0];
    
    // è®¾ç½®åˆå§‹æ—¥å¿—
    [self.logTextView.textStorage setAttributedString:[[NSAttributedString alloc] initWithString:initialLog]];
}

- (void)updateProgress:(double)progress {
    NSLog(@"BackupProgressViewController: æ›´æ–°è¿›åº¦: %.1f%%", progress);
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.progressBar setDoubleValue:progress];
    });
}

#pragma mark - æ›´æ–°æ—¥å¿—åŒºåŸŸ
- (void)appendLog:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        // ç”Ÿæˆæ—¶é—´æˆ³
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
        NSString *timestamp = [dateFormatter stringFromDate:[NSDate date]];

        // æ‰‹åŠ¨ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ—¥å¿—
        NSString *formattedLog = [NSString stringWithFormat:@"[%@] %@", timestamp, message];

        // è·å–æ—¥å¿—æ˜¾ç¤ºçš„ NSTextView
        NSTextView *textView = (NSTextView *)[LogManager sharedManager].logScrollView.documentView;
        if (textView) {
            // âœ… ç›´æ¥è°ƒç”¨ AppendLogToTextView è¿½åŠ æ—¥å¿—ï¼ˆä»ç„¶æ˜¯åŸå§‹ messageï¼‰
            AppendLogToTextView(textView, message);

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            NSRange endRange = NSMakeRange(textView.string.length, 0);
            [textView scrollRangeToVisible:endRange];

            // âœ… å­˜å…¥ collectedLogsï¼Œä½†åŠ ä¸Šæ—¶é—´æˆ³ï¼Œç¡®ä¿æœ€ç»ˆæ—¥å¿—æ–‡ä»¶æœ‰å®Œæ•´æ ¼å¼
            [self.collectedLogs appendFormat:@"%@\n", formattedLog];
        } else {
            NSLog(@"[ERROR] Failed to access NSTextView.");
        }
    });
}

#pragma mark - æŒ‰é’®åŠ¨ä½œ

- (IBAction)cancelBackup:(id)sender {
    NSLog(@"BackupProgressViewController: å–æ¶ˆå¤‡ä»½æŒ‰é’®è¢«ç‚¹å‡»");
    if ([self.delegate respondsToSelector:@selector(cancelBackup)]) {
        [self.delegate cancelBackup];
    }
}

#pragma mark - NSTableViewDataSource

- (NSInteger)numberOfRowsInTableView:(NSTableView *)tableView {
    // è¿”å›å¤‡ä»½ç›®å½•åˆ—è¡¨çš„è¡Œæ•°
    return self.backupDirectories.count;
}

// ä¿®æ”¹ viewForTableColumn æ–¹æ³•ä»¥æ˜¾ç¤ºç›®å½•ä¿¡æ¯
- (NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row {
    if (row < self.backupDirectories.count) {
        NSDictionary *dirInfo = self.backupDirectories[row];
        
        NSTableCellView *cellView = [tableView makeViewWithIdentifier:tableColumn.identifier owner:self];
        if (!cellView) {
            cellView = [[NSTableCellView alloc] init];
            cellView.identifier = tableColumn.identifier;
            
            NSTextField *textField = [[NSTextField alloc] init];
            textField.bordered = NO;
            textField.backgroundColor = [NSColor clearColor];
            textField.editable = NO;
            textField.font = [NSFont systemFontOfSize:11.0];
            [cellView addSubview:textField];
            cellView.textField = textField;
            
            // è®¾ç½®çº¦æŸ
            textField.translatesAutoresizingMaskIntoConstraints = NO;
            [NSLayoutConstraint activateConstraints:@[
                [textField.leadingAnchor constraintEqualToAnchor:cellView.leadingAnchor constant:6],
                [textField.trailingAnchor constraintEqualToAnchor:cellView.trailingAnchor constant:-6],
                [textField.centerYAnchor constraintEqualToAnchor:cellView.centerYAnchor]
            ]];
        }
        
        // æ ¹æ®åˆ—æ ‡è¯†ç¬¦è®¾ç½®å†…å®¹
        if ([tableColumn.identifier isEqualToString:@"backupitem"]) {
            NSString *displayName = dirInfo[@"backupitem"] ?: @"";
            // æ‰€æœ‰æ˜¾ç¤ºçš„éƒ½æ˜¯å½“å‰è®¾å¤‡çš„å¤‡ä»½ï¼Œç”¨è“è‰²æ˜¾ç¤º
           // cellView.textField.textColor = [NSColor systemBlueColor];
            cellView.textField.stringValue = displayName;
        } else if ([tableColumn.identifier isEqualToString:@"backuplocation"]) {
            cellView.textField.stringValue = dirInfo[@"backuplocation"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupfilesize"]) {
            cellView.textField.stringValue = dirInfo[@"backupfilesize"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupdate"]) {
            cellView.textField.stringValue = dirInfo[@"backupdate"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupencryptionstatus"]) {
            cellView.textField.stringValue = dirInfo[@"backupencryptionstatus"] ?: @"";
        }
        
        return cellView;
    }
    
    return nil;
}

- (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row {
    return 30.0; // è®¾ç½®è¡Œé«˜
}

#pragma mark - è¡¨æ ¼æ“ä½œè¾…åŠ©æ–¹æ³•

- (void)scrollToNewestBackup {
    NSLog(@"BackupProgressViewController: æ»šåŠ¨åˆ°æœ€æ–°å¤‡ä»½é¡¹");
    
    if (self.backupDirectories.count > 0) {
        // æ»šåŠ¨åˆ°ç¬¬ä¸€è¡Œï¼ˆæœ€æ–°çš„å¤‡ä»½ï¼‰
        [self.tableView scrollRowToVisible:0];
        
        // å¯é€‰ï¼šé€‰ä¸­ç¬¬ä¸€è¡Œ
        [self.tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:0] byExtendingSelection:NO];
        
        NSLog(@"BackupProgressViewController: å·²æ»šåŠ¨å¹¶é€‰ä¸­æœ€æ–°å¤‡ä»½é¡¹");
    } else {
        NSLog(@"BackupProgressViewController: æ²¡æœ‰å¤‡ä»½é¡¹å¯æ»šåŠ¨");
    }
}
// æ·»åŠ ä¸€ä¸ªå¼ºåˆ¶åˆ·æ–°æ–¹æ³•
- (void)forceRefreshBackupList {
    NSLog(@"BackupProgressViewController: å¼ºåˆ¶åˆ·æ–°å¤‡ä»½åˆ—è¡¨");
    
    // è·å–ä¸»æ§åˆ¶å™¨ä¿¡æ¯
    DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
    NSString *currentDeviceID = mainController.lockedDeviceID;
    NSDictionary *deviceInfo = mainController.LockedDeviceInfo;
    
    if (currentDeviceID && currentDeviceID.length > 0) {
        [self loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
        
        // æ·»åŠ åˆ·æ–°æ—¥å¿—
        dispatch_async(dispatch_get_main_queue(), ^{
            [self appendLog:@"å¤‡ä»½åˆ—è¡¨å·²åˆ·æ–°\n"];
        });
    }
}

// ä¿æŒåŸæœ‰çš„æ–¹æ³•ç”¨äºå…¼å®¹æ€§
- (id)tableView:(NSTableView *)tableView objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row {
    if (row >= self.backupDirectories.count) {
        NSLog(@"BackupProgressViewController: è¯·æ±‚çš„è¡Œ %ld è¶…å‡ºèŒƒå›´", row);
        return nil;
    }
    
    NSDictionary *item = self.backupDirectories[row];
    NSString *identifier = tableColumn.identifier;
    id value = item[identifier];
    NSLog(@"BackupProgressViewController: è¡¨æ ¼è¡Œ %ld, åˆ— %@, å€¼: %@", row, identifier, value);
    return value;
}

@end




------------æ“ä½œæ—¥å¿—---------------

2025-05-28 16:03:17.902377+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: ğŸ”§ å¯åŠ¨ä¿®å¤ç‰ˆé€‰æ‹©æ€§å¤‡ä»½
2025-05-28 16:03:17.903386+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:17] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:18.904491+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Connecting to device: 00008030-0008352034B9802E
2025-05-28 16:03:18.904790+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:18.905036+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Status changed: 0 -> 1
2025-05-28 16:03:18.905810+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Device connection established
2025-05-28 16:03:18.962105+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Lockdown connection established
2025-05-28 16:03:19.061097+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:19] [BackupOptionTask] Successfully connected to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.061559+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:19] [BackupOptionTask] Status changed: 1 -> 0
2025-05-28 16:03:19.062325+0800 MFCTOOL.bin[53398:13803419] [2025-05-28 16:03:19] [BackupOptionTask] Connecting to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.062738+0800 MFCTOOL.bin[53398:13803419] [2025-05-28 16:03:19] [BackupOptionTask] Already connected to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.068042+0800 MFCTOOL.bin[53398:13803430] === ç¡®ä¿è®¾å¤‡è¿æ¥å’Œåˆå§‹åŒ– ===
2025-05-28 16:03:19.068193+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:19.576103+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Connecting to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.577190+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:19.577829+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Status changed: 0 -> 1
2025-05-28 16:03:19.580100+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Device connection established
2025-05-28 16:03:19.632064+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Lockdown connection established
2025-05-28 16:03:59.717394+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:59] [BackupOptionTask] MobileSync client creation failed (attempt 1): -5
2025-05-28 16:03:59.718342+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:59] [BackupOptionTask] Retrying in 2 seconds...
2025-05-28 16:04:01.770246+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] Successfully connected to device: 00008030-0008352034B9802E
2025-05-28 16:04:01.771017+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] Status changed: 1 -> 0
2025-05-28 16:04:01.771105+0800 MFCTOOL.bin[53398:13803430] âœ… è®¾å¤‡è¿æ¥æˆåŠŸ
2025-05-28 16:04:01.771484+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] === Device Sync Capabilities Diagnosis ===
2025-05-28 16:04:01.771855+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ğŸ“± Device UDID: 00008030-0008352034B9802E
2025-05-28 16:04:01.807599+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âœ… Contacts (com.apple.Contacts)
2025-05-28 16:04:01.864026+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âœ… Calendars (com.apple.Calendars)
2025-05-28 16:04:01.869189+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Bookmarks (com.apple.WebBookmarks)
2025-05-28 16:04:01.869739+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Notes (com.apple.Notes)
2025-05-28 16:04:01.870022+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Reminders (com.apple.Reminders)
2025-05-28 16:04:01.870272+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Applications (com.apple.MobileApplication)
2025-05-28 16:04:01.870521+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Configuration (com.apple.SystemConfiguration)
2025-05-28 16:04:01.870760+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Keychain (com.apple.Keychain)
2025-05-28 16:04:01.871053+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Voice Memos (com.apple.VoiceMemos)
2025-05-28 16:04:01.871629+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] âŒ Wallpaper (com.apple.Wallpaper)
2025-05-28 16:04:01.877236+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ğŸ“Š Total: 2/10 data types supported
2025-05-28 16:04:01.877495+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] === End Diagnosis ===
2025-05-28 16:04:01.877550+0800 MFCTOOL.bin[53398:13803430] âœ… è®¾å¤‡è¿æ¥å’Œåˆå§‹åŒ–å®Œæˆ
2025-05-28 16:04:01.877634+0800 MFCTOOL.bin[53398:13803430] === ğŸ”§ å¼€å§‹ä¿®å¤ç‰ˆè®¾å¤‡çœŸå®æ•°æ®æ‰«æ ===
2025-05-28 16:04:02.484061+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:02] [BackupOptionTask] Getting supported data types with enhanced stability
2025-05-28 16:04:02.487403+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:02] [BackupOptionTask] Connection quality verified
2025-05-28 16:04:02.728539+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:02] [BackupOptionTask] âœ… Supported data type: Contacts
2025-05-28 16:04:03.091440+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:03] [BackupOptionTask] âœ… Supported data type: Calendars
2025-05-28 16:04:05.547565+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] ğŸ“Š Final result: 2/10 data types supported
2025-05-28 16:04:05.547833+0800 MFCTOOL.bin[53398:13803430] âœ… è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : 3
2025-05-28 16:04:05.547930+0800 MFCTOOL.bin[53398:13803430] ğŸ” æ­£åœ¨è·å– Contacts çš„çœŸå®æ•°æ®...
2025-05-28 16:04:05.548009+0800 MFCTOOL.bin[53398:13803430] å¢å¼ºæ–¹æ³•è·å– Contacts çš„çœŸå®æ•°æ®
2025-05-28 16:04:05.548828+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] Getting data items for type: Contacts
2025-05-28 16:04:05.549504+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] è·å–ç®€åŒ–æ•°æ®é¡¹ - ç±»å‹: Contacts, åŒæ­¥ç±»: com.apple.Contacts
2025-05-28 16:04:05.550031+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] è·³è¿‡é‡å¤æ”¯æŒæ£€æŸ¥ï¼Œç›´æ¥è·å– com.apple.Contacts æ•°æ®
2025-05-28 16:04:05.550565+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] ğŸ”§ ä½¿ç”¨ä¿®å¤ç‰ˆè·å– com.apple.Contacts æ•°æ®
2025-05-28 16:04:05.555555+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] ğŸ“± è®¾å¤‡åç§°:
2025-05-28 16:04:05.556812+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] ğŸ“± iOSç‰ˆæœ¬: 18.4
2025-05-28 16:04:05.557203+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] ğŸ’¡ iOS 15+è®¾å¤‡ï¼Œæ•°æ®æ ¼å¼å¯èƒ½æœ‰å˜åŒ–
2025-05-28 16:04:05.559233+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] ğŸ“± è®¾å¤‡å‹å·: iPhone12,3
2025-05-28 16:04:05.559559+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] ğŸ”„ é‡æ–°å»ºç«‹ MobileSync è¿æ¥ä»¥ç¡®ä¿æ•°æ®è·å–ç¨³å®šæ€§
2025-05-28 16:04:43.160945+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:43] [BackupOptionTask] MobileSync client creation failed (attempt 1): -5
2025-05-28 16:04:43.161855+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:43] [BackupOptionTask] Retrying in 2 seconds...
2025-05-28 16:04:45.245859+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] âœ… MobileSync è¿æ¥å·²é‡æ–°å»ºç«‹
2025-05-28 16:04:45.246490+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ğŸ”§ ä½¿ç”¨å¹²å‡€è¿æ¥å¯åŠ¨åŒæ­¥ä¼šè¯: com.apple.Contacts
2025-05-28 16:04:45.278015+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] âœ… com.apple.Contacts åŒæ­¥ä¼šè¯å¯åŠ¨æˆåŠŸï¼ˆå¹²å‡€è¿æ¥ï¼‰
2025-05-28 16:04:45.278828+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] âœ… æˆåŠŸè¯·æ±‚ com.apple.Contacts çš„æ‰€æœ‰è®°å½•
2025-05-28 16:04:45.285476+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ğŸ“¦ mobilesync_receive_changes è¿”å›çŠ¶æ€: 0 (æ‰¹æ¬¡ 1)
2025-05-28 16:04:45.285871+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ğŸ“¦ å¤„ç† com.apple.Contacts ç¬¬ 1 æ‰¹æ•°æ®
2025-05-28 16:04:45.286284+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ğŸ“Š æ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹: DICT (5)
2025-05-28 16:04:45.286563+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ğŸ“‹ com.apple.Contacts è¿”å›å­—å…¸æ•°æ®ï¼Œå°è¯•è§£æ
2025-05-28 16:04:45.286995+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ğŸ“Š å­—å…¸åŒ…å« 1 ä¸ªé”®å€¼å¯¹
2025-05-28 16:04:45.287305+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ğŸ’¡ å°è¯•å°† com.apple.Contacts å­—å…¸ä½œä¸ºæ•°æ®é¡¹å¤„ç†
2025-05-28 16:04:45.287953+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] âœ… æˆåŠŸåˆ›å»º com.apple.Contacts æ•°æ®é¡¹: Contacts Item 1
2025-05-28 16:04:45.288735+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] âœ… ä»ç¬¬ 1 æ‰¹è·å–åˆ° 1 é¡¹æ•°æ®
2025-05-28 16:05:15.395590+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ“¦ mobilesync_receive_changes è¿”å›çŠ¶æ€: -5 (æ‰¹æ¬¡ 2)
2025-05-28 16:05:15.396432+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] â° com.apple.Contacts æ¥æ”¶è¶…æ—¶ (ç¬¬ 1 æ¬¡ï¼Œå…± 2 æ¬¡)
2025-05-28 16:05:15.396993+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ’¡ com.apple.Contacts å·²è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸ç»“æŸ
2025-05-28 16:05:15.397364+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ“Š com.apple.Contacts æ•°æ®æ¥æ”¶å®Œæˆ: 1 æ‰¹æ¬¡, 1 é¡¹
2025-05-28 16:05:15.411306+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] âœ… com.apple.Contacts åŒæ­¥ä¼šè¯å·²ç»“æŸ
2025-05-28 16:05:15.411665+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ“Š com.apple.Contacts æœ€ç»ˆè·å–åˆ° 1 é¡¹çœŸå®æ•°æ®ï¼ˆå¹²å‡€è¿æ¥ï¼‰
2025-05-28 16:05:15.411941+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] âœ… æˆåŠŸè·å– com.apple.Contacts æ•°æ®: 1 é¡¹
2025-05-28 16:05:15.412199+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] Retrieved 1 data items
2025-05-28 16:05:15.412252+0800 MFCTOOL.bin[53398:13803430] âœ… ç¬¬ 1 æ¬¡å°è¯•æˆåŠŸè·å– Contacts æ•°æ®: 1 é¡¹
2025-05-28 16:05:15.412380+0800 MFCTOOL.bin[53398:13803430] âœ… Contacts è·å–æˆåŠŸ: 1 é¡¹
2025-05-28 16:05:15.717510+0800 MFCTOOL.bin[53398:13803430] ğŸ” æ­£åœ¨è·å– Calendars çš„çœŸå®æ•°æ®...
2025-05-28 16:05:15.717787+0800 MFCTOOL.bin[53398:13803430] å¢å¼ºæ–¹æ³•è·å– Calendars çš„çœŸå®æ•°æ®
2025-05-28 16:05:15.718701+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] Getting data items for type: Calendars
2025-05-28 16:05:15.719467+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] è·å–ç®€åŒ–æ•°æ®é¡¹ - ç±»å‹: Calendars, åŒæ­¥ç±»: com.apple.Calendars
2025-05-28 16:05:15.719998+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] è·³è¿‡é‡å¤æ”¯æŒæ£€æŸ¥ï¼Œç›´æ¥è·å– com.apple.Calendars æ•°æ®
2025-05-28 16:05:15.720503+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ”§ ä½¿ç”¨ä¿®å¤ç‰ˆè·å– com.apple.Calendars æ•°æ®
2025-05-28 16:05:15.724549+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ“± è®¾å¤‡åç§°:
2025-05-28 16:05:15.726989+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ“± iOSç‰ˆæœ¬: 18.4
2025-05-28 16:05:15.727514+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ’¡ iOS 15+è®¾å¤‡ï¼Œæ•°æ®æ ¼å¼å¯èƒ½æœ‰å˜åŒ–
2025-05-28 16:05:15.731166+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ“± è®¾å¤‡å‹å·: iPhone12,3
2025-05-28 16:05:15.731436+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ğŸ”„ é‡æ–°å»ºç«‹ MobileSync è¿æ¥ä»¥ç¡®ä¿æ•°æ®è·å–ç¨³å®šæ€§
2025-05-28 16:05:16.338705+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] âœ… MobileSync è¿æ¥å·²é‡æ–°å»ºç«‹
2025-05-28 16:05:16.339317+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ğŸ”§ ä½¿ç”¨å¹²å‡€è¿æ¥å¯åŠ¨åŒæ­¥ä¼šè¯: com.apple.Calendars
2025-05-28 16:05:16.369740+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] âœ… com.apple.Calendars åŒæ­¥ä¼šè¯å¯åŠ¨æˆåŠŸï¼ˆå¹²å‡€è¿æ¥ï¼‰
2025-05-28 16:05:16.370293+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] âœ… æˆåŠŸè¯·æ±‚ com.apple.Calendars çš„æ‰€æœ‰è®°å½•
2025-05-28 16:05:16.376168+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ğŸ“¦ mobilesync_receive_changes è¿”å›çŠ¶æ€: 0 (æ‰¹æ¬¡ 1)
2025-05-28 16:05:16.376559+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ğŸ“¦ å¤„ç† com.apple.Calendars ç¬¬ 1 æ‰¹æ•°æ®
2025-05-28 16:05:16.376875+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ğŸ“Š æ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹: DICT (5)
2025-05-28 16:05:16.377178+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ğŸ“‹ com.apple.Calendars è¿”å›å­—å…¸æ•°æ®ï¼Œå°è¯•è§£æ
2025-05-28 16:05:16.377478+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ğŸ“Š å­—å…¸åŒ…å« 1 ä¸ªé”®å€¼å¯¹
2025-05-28 16:05:16.377949+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ğŸ’¡ å°è¯•å°† com.apple.Calendars å­—å…¸ä½œä¸ºæ•°æ®é¡¹å¤„ç†
2025-05-28 16:05:16.378265+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] âœ… æˆåŠŸåˆ›å»º com.apple.Calendars æ•°æ®é¡¹: Calendars Item 1
2025-05-28 16:05:16.378503+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] âœ… ä»ç¬¬ 1 æ‰¹è·å–åˆ° 1 é¡¹æ•°æ®
2025-05-28 16:05:46.485210+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] ğŸ“¦ mobilesync_receive_changes è¿”å›çŠ¶æ€: -5 (æ‰¹æ¬¡ 2)
2025-05-28 16:05:46.486091+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] â° com.apple.Calendars æ¥æ”¶è¶…æ—¶ (ç¬¬ 1 æ¬¡ï¼Œå…± 2 æ¬¡)
2025-05-28 16:05:46.486650+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] ğŸ’¡ com.apple.Calendars å·²è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸ç»“æŸ
2025-05-28 16:05:46.487018+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] ğŸ“Š com.apple.Calendars æ•°æ®æ¥æ”¶å®Œæˆ: 1 æ‰¹æ¬¡, 1 é¡¹
2025-05-28 16:05:46.505544+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] âœ… com.apple.Calendars åŒæ­¥ä¼šè¯å·²ç»“æŸ
2025-05-28 16:05:46.505921+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] ğŸ“Š com.apple.Calendars æœ€ç»ˆè·å–åˆ° 1 é¡¹çœŸå®æ•°æ®ï¼ˆå¹²å‡€è¿æ¥ï¼‰
2025-05-28 16:05:46.506186+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] âœ… æˆåŠŸè·å– com.apple.Calendars æ•°æ®: 1 é¡¹
2025-05-28 16:05:46.506435+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] Retrieved 1 data items
2025-05-28 16:05:46.506489+0800 MFCTOOL.bin[53398:13803430] âœ… ç¬¬ 1 æ¬¡å°è¯•æˆåŠŸè·å– Calendars æ•°æ®: 1 é¡¹
2025-05-28 16:05:46.506593+0800 MFCTOOL.bin[53398:13803430] âœ… Calendars è·å–æˆåŠŸ: 1 é¡¹
2025-05-28 16:05:46.811749+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Bookmarks
2025-05-28 16:05:46.812030+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Notes
2025-05-28 16:05:46.812109+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Reminders
2025-05-28 16:05:46.812182+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Applications
2025-05-28 16:05:46.812250+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Configuration
2025-05-28 16:05:46.812325+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Keychain
2025-05-28 16:05:46.812391+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Voice Memos
2025-05-28 16:05:46.812457+0800 MFCTOOL.bin[53398:13803430] â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Wallpaper
2025-05-28 16:05:46.812529+0800 MFCTOOL.bin[53398:13803430] === ğŸ”§ ä¿®å¤ç‰ˆæ•°æ®æ‰«æå®Œæˆï¼Œå…±å¤„ç† 2 ç§æ•°æ®ç±»å‹ ===
2025-05-28 16:05:46.812706+0800 MFCTOOL.bin[53398:13803416] === çœŸå®è®¾å¤‡æ•°æ®è·å–ç»“æœ ===
2025-05-28 16:05:46.812834+0800 MFCTOOL.bin[53398:13803416] === ç»“æœè®°å½•å®Œæˆ ===
2025-05-28 16:05:46.813069+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: åˆ›å»ºå¢å¼ºçš„é€‰æ‹©æ€§å¤‡ä»½çª—å£
2025-05-28 16:05:46.842300+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: å¢å¼ºçš„é€‰æ‹©æ€§å¤‡ä»½çª—å£å·²æ˜¾ç¤º
2025-05-28 16:05:50.285009+0800 MFCTOOL.bin[53398:13803416] å·²é€‰æ‹©æ‰€æœ‰å¯ç”¨çš„æ•°æ®ç±»å‹
2025-05-28 16:05:51.925333+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: å¼€å§‹é€‰æ‹©æ€§å¤‡ä»½
2025-05-28 16:05:51.925590+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: ä¿å­˜é€‰æ‹©æ€§å¤‡ä»½å‰çš„è®¾å¤‡ä¿¡æ¯
2025-05-28 16:05:51.925753+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: å·²ä¿å­˜è®¾å¤‡ä¿¡æ¯ - ID: 00008030-0008352034B9802E, Info: {
    mode = Normal;
    officialName = "iPhone 11 Pro";
    type = "iPhone12,3";
    uniqueKey = "00008030-0008352034B9802E";
}
2025-05-28 16:05:51.927010+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: ç”Ÿæˆå¤‡ä»½æ—¶é—´æˆ³: 202505281605PM
2025-05-28 16:05:51.928544+0800 MFCTOOL.bin[53398:13803416] å·²åˆ›å»ºé€‰æ‹©æ€§å¤‡ä»½æ ‡è¯†æ–‡ä»¶: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM/selective_backup_metadata.plist
2025-05-28 16:05:51.929031+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Backing up selected data types to: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM
2025-05-28 16:05:51.929368+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Starting selective sync for types: 3, direction: 0
2025-05-28 16:05:51.929679+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Status changed: 0 -> 2
2025-05-28 16:05:51.930098+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Performing selective sync internally
2025-05-28 16:05:51.936062+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Status changed: 2 -> 3
2025-05-28 16:05:51.936388+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 0.00% - Starting selective sync (0/100)
2025-05-28 16:05:51.936657+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 0.00% - Syncing Contacts (0/2)
2025-05-28 16:05:51.936912+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Performing sync for data type: Contacts, direction: 0
2025-05-28 16:05:51.937166+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Backing up data type: Contacts to path: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM
2025-05-28 16:05:51.937407+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Getting data items for type: Contacts
2025-05-28 16:05:51.937668+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Returning cached data items: 1
2025-05-28 16:05:51.938542+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: æ›´æ–°è¿›åº¦: 0.0%
2025-05-28 16:05:51.938629+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: æ›´æ–°è¿›åº¦: 0.0%
2025-05-28 16:05:51.939258+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Successfully backed up 1 items of type: Contacts
2025-05-28 16:05:51.939622+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 50.00% - Syncing Calendars (1/2)
2025-05-28 16:05:51.939942+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Performing sync for data type: Calendars, direction: 0
2025-05-28 16:05:51.940319+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Backing up data type: Calendars to path: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM
2025-05-28 16:05:51.940589+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Getting data items for type: Calendars
2025-05-28 16:05:51.940835+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Returning cached data items: 1
2025-05-28 16:05:51.942280+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Successfully backed up 1 items of type: Calendars
2025-05-28 16:05:51.942582+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 100.00% - Selective sync completed (2/2)
2025-05-28 16:05:51.942837+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Selective sync completed successfully
2025-05-28 16:05:51.951924+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: æ›´æ–°è¿›åº¦: 50.0%
2025-05-28 16:05:51.952253+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Status changed: 3 -> 4
2025-05-28 16:05:51.952518+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: æ›´æ–°è¿›åº¦: 100.0%
2025-05-28 16:05:51.952777+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: é€‰æ‹©æ€§å¤‡ä»½å®Œæˆå¤„ç†å¼€å§‹
2025-05-28 16:05:51.952839+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: æ¢å¤é€‰æ‹©æ€§å¤‡ä»½åçš„è®¾å¤‡ä¿¡æ¯
2025-05-28 16:05:51.952872+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: å·²æ¢å¤è®¾å¤‡ä¿¡æ¯ - ID: 00008030-0008352034B9802E
2025-05-28 16:05:51.952926+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: æ˜¾ç¤ºè­¦å‘Š: å¤‡ä»½å®Œæˆ - é€‰æ‹©æ€§å¤‡ä»½å·²æˆåŠŸå®Œæˆ
2025-05-28 16:05:52.250695+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: é€‰æ‹©æ€§å¤‡ä»½å®Œæˆå¤„ç†ç»“æŸ
2025-05-28 16:05:52.796761+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: å¼€å§‹åˆ·æ–°å¤‡ä»½åˆ—è¡¨ï¼Œå½“å‰è®¾å¤‡ID: 00008030-0008352034B9802E
2025-05-28 16:05:52.796926+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: æ£€æŸ¥ç°æœ‰å¤‡ä»½æ•°æ®ï¼ˆé€šè¿‡è·å–ä¸»æ§åˆ¶å™¨ä¿¡æ¯ï¼‰
2025-05-28 16:05:52.797000+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: æ¥æ”¶åˆ°è®¾å¤‡ä¿¡æ¯ - ID: , Info: {
}
2025-05-28 16:05:52.797038+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: è®¾å¤‡IDä¸ºç©ºï¼Œå°è¯•è·å–å¤‡ä»½æ•°æ®ç®¡ç†å™¨çš„è®¾å¤‡ä¿¡æ¯
2025-05-28 16:05:52.797077+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: å¤‡ç”¨è®¾å¤‡ä¿¡æ¯ - ID: (null), Info: (null)
2025-05-28 16:05:52.797111+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: è®¾å¤‡IDç¡®å®ä¸ºç©ºï¼Œæ— æ³•åŠ è½½å¤‡ä»½æ•°æ®





----------å¥”æºƒæ—¥å¿—----------------

-------------------------------------
Translated Report (Full Report Below)
-------------------------------------

Process:               MFCTOOL.bin [53398]
Path:                  /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/MacOS/MFCTOOL.bin
Identifier:            MFCTOOL.bin
Version:               ???
Code Type:             ARM-64 (Native)
Parent Process:        launchd [1]
User ID:               501

Date/Time:             2025-05-28 16:05:54.4650 +0800
OS Version:            macOS 12.7.2 (21G1974)
Report Version:        12
Anonymous UUID:        57B94FB4-6A44-571C-3243-401813F68875


Time Awake Since Boot: 1900000 seconds

System Integrity Protection: disabled

Crashed Thread:        0  Dispatch queue: com.apple.main-thread

Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       KERN_INVALID_ADDRESS at 0x0000000000000020
Exception Codes:       0x0000000000000001, 0x0000000000000020
Exception Note:        EXC_CORPSE_NOTIFY

Termination Reason:    Namespace SIGNAL, Code 11 Segmentation fault: 11
Terminating Process:   exc handler [53398]

VM Region Info: 0x20 is not in any region.  Bytes before following region: 105553518919648
      REGION TYPE                    START - END         [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL
      UNUSED SPACE AT START
--->  
      MALLOC_NANO (reserved)   600018000000-600020000000 [128.0M] rw-/rwx SM=NUL  ...(unallocated)

Thread 0 Crashed::  Dispatch queue: com.apple.main-thread
0   libobjc.A.dylib                        0x18bae8540 objc_release + 16
1   libobjc.A.dylib                        0x18baecd44 AutoreleasePoolPage::releaseUntil(objc_object**) + 196
2   libobjc.A.dylib                        0x18bae96a4 objc_autoreleasePoolPop + 212
3   CoreFoundation                         0x18bcea12c _CFAutoreleasePoolPop + 32
4   CoreFoundation                         0x18be064d4 __CFRunLoopPerCalloutARPEnd + 48
5   CoreFoundation                         0x18bd2bb7c __CFRunLoopRun + 2600
6   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
7   HIToolbox                              0x194970338 RunCurrentEventLoopInMode + 292
8   HIToolbox                              0x1949700b4 ReceiveNextEventCommon + 564
9   HIToolbox                              0x19496fe68 _BlockUntilNextEventMatchingListInModeWithFilter + 72
10  AppKit                                 0x18e8934b8 _DPSNextEvent + 860
11  AppKit                                 0x18e891db0 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1328
12  AppKit                                 0x18e883f7c -[NSApplication run] + 596
13  AppKit                                 0x18e855698 NSApplicationMain + 1132
14  MFCTOOL.bin                            0x102dc4c14 main + 384 (main.m:300)
15  dyld                                   0x1034d108c start + 520

Thread 1::  Dispatch queue: com.apple.root.default-qos
0   libsystem_kernel.dylib                 0x18bc22890 mach_msg_trap + 8
1   libsystem_kernel.dylib                 0x18bc22d00 mach_msg + 76
2   CoreFoundation                         0x18bd2d140 __CFRunLoopServiceMachPort + 372
3   CoreFoundation                         0x18bd2b5f0 __CFRunLoopRun + 1180
4   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
5   CoreFoundation                         0x18bdb7bd8 CFRunLoopRun + 64
6   MFCTOOL.bin                            0x102e4b364 __51-[DeviceManager dfu_recovery_device_event_callback]_block_invoke + 452 (DeviceManager.m:5798)
7   libdispatch.dylib                      0x18ba9a5f0 _dispatch_call_block_and_release + 32
8   libdispatch.dylib                      0x18ba9c1b4 _dispatch_client_callout + 20
9   libdispatch.dylib                      0x18ba9f2c8 _dispatch_queue_override_invoke + 784
10  libdispatch.dylib                      0x18baad8e8 _dispatch_root_queue_drain + 396
11  libdispatch.dylib                      0x18baae104 _dispatch_worker_thread2 + 164
12  libsystem_pthread.dylib                0x18bc5c324 _pthread_wqthread + 228
13  libsystem_pthread.dylib                0x18bc5b080 start_wqthread + 8

Thread 2:
0   libsystem_kernel.dylib                 0x18bc2ae90 poll + 8
1   libimfccoreextra.dylib                 0x103a27998 socket_check_fd + 428
2   libimfccoreextra.dylib                 0x103a27c90 socket_receive_timeout + 52
3   libimfcusb.dylib                       0x1038df868 receive_packet + 108
4   libimfcusb.dylib                       0x1038e164c get_next_event + 68
5   libimfcusb.dylib                       0x1038de714 device_monitor + 104
6   libsystem_pthread.dylib                0x18bc6026c _pthread_start + 148
7   libsystem_pthread.dylib                0x18bc5b08c thread_start + 8

Thread 3:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 4:: com.apple.NSEventThread
0   libsystem_kernel.dylib                 0x18bc22890 mach_msg_trap + 8
1   libsystem_kernel.dylib                 0x18bc22d00 mach_msg + 76
2   CoreFoundation                         0x18bd2d140 __CFRunLoopServiceMachPort + 372
3   CoreFoundation                         0x18bd2b5f0 __CFRunLoopRun + 1180
4   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
5   AppKit                                 0x18ea0009c _NSEventThread + 196
6   libsystem_pthread.dylib                0x18bc6026c _pthread_start + 148
7   libsystem_pthread.dylib                0x18bc5b08c thread_start + 8

Thread 5:: com.apple.NSURLConnectionLoader
0   libsystem_kernel.dylib                 0x18bc22890 mach_msg_trap + 8
1   libsystem_kernel.dylib                 0x18bc22d00 mach_msg + 76
2   CoreFoundation                         0x18bd2d140 __CFRunLoopServiceMachPort + 372
3   CoreFoundation                         0x18bd2b5f0 __CFRunLoopRun + 1180
4   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
5   CFNetwork                              0x190b22738 0x1908b8000 + 2533176
6   Foundation                             0x18cc0959c __NSThread__start__ + 808
7   libsystem_pthread.dylib                0x18bc6026c _pthread_start + 148
8   libsystem_pthread.dylib                0x18bc5b08c thread_start + 8

Thread 6:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 7:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 8:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 9:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 10:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 11:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 12:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0


Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x00000001041159d0   x1: 0x0000600000dfa520   x2: 0x0000000000000002   x3: 0x000000018ba6f04c
    x4: 0x0000000000000001   x5: 0x0000000000000034   x6: 0x0000000000000000   x7: 0x0000000000000000
    x8: 0x2000000000000000   x9: 0x0000000000000000  x10: 0x08000001e46ada85  x11: 0x09000001e46ada85
   x12: 0x00000000000000c7  x13: 0x00000000fe4680cc  x14: 0x00000000fe668800  x15: 0x00000000000000d1
   x16: 0x000000018bae8530  x17: 0x00000001e5d991f8  x18: 0x0000000000000000  x19: 0x0000000128815000
   x20: 0x0000000128815048  x21: 0x00000001041159d0  x22: 0x00000000a1a1a1a1  x23: 0x0000000103544660
   x24: 0xa3a3a3a3a3a3a3a3  x25: 0x0000000000000001  x26: 0x0000000000000000  x27: 0x000000016d0bdc60
   x28: 0x0000000000000000   fp: 0x000000016d0bdad0   lr: 0x000000018baecd44
    sp: 0x000000016d0bda90   pc: 0x000000018bae8540 cpsr: 0x20001000
   far: 0x0000000000000020  esr: 0x92000006 (Data Abort) byte read Translation fault

Binary Images:
       0x18badf000 -        0x18bb1cfff libobjc.A.dylib (*) <44d5d68a-ad18-33b8-adea-eb65b4dc906c> /usr/lib/libobjc.A.dylib
       0x18bca8000 -        0x18c1eefff com.apple.CoreFoundation (6.9) <07e05b49-8c3c-354e-89a7-cc7994572dfe> /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
       0x19493e000 -        0x194c71fff com.apple.HIToolbox (2.1.1) <07987381-b579-3f72-8ba8-97fa5b5a3352> /System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/HIToolbox
       0x18e852000 -        0x18f70afff com.apple.AppKit (6.9) <2f9d63e8-f87c-3348-b5c5-39de32463324> /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit
       0x102d40000 -        0x102f63fff MFCTOOL.bin (*) <f0b329ab-7294-3ece-9e13-ec1e22473c83> /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/MacOS/MFCTOOL.bin
       0x1034cc000 -        0x10352bfff dyld (*) <0a55d424-2537-3f9b-ada1-ef612d185def> /usr/lib/dyld
       0x18bc21000 -        0x18bc58fff libsystem_kernel.dylib (*) <6e9cd1b1-2daa-3338-a85a-965721bcebdc> /usr/lib/system/libsystem_kernel.dylib
       0x18ba98000 -        0x18badefff libdispatch.dylib (*) <26532eb9-1697-3bcb-aa36-f07a3405770a> /usr/lib/system/libdispatch.dylib
       0x18bc59000 -        0x18bc65fff libsystem_pthread.dylib (*) <569fc817-bb09-3ef2-8b18-af7f7bd615ec> /usr/lib/system/libsystem_pthread.dylib
       0x103a24000 -        0x103a33fff libimfccoreextra.dylib (*) <f4558a88-ccf6-3de5-92cf-937c11037767> /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/Frameworks/libimfccoreextra.dylib
       0x1038dc000 -        0x1038e3fff libimfcusb.dylib (*) <19108f9b-0fcc-3b50-ac83-8fd75d2e78ea> /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/Frameworks/libimfcusb.dylib
       0x1908b8000 -        0x190d6bfff com.apple.CFNetwork (1335.5) <46dc101d-2215-38ff-b769-f08335df88fc> /System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork
       0x18cbad000 -        0x18cf9efff com.apple.Foundation (6.9) <ed1a7ccd-78c8-37a7-a4fe-1e5051fcf967> /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
               0x0 - 0xffffffffffffffff ??? (*) <00000000-0000-0000-0000-000000000000> ???

External Modification Summary:
  Calls made by other processes targeting this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by all processes on this machine:
    task_for_pid: 4
    thread_create: 0
    thread_set_state: 0

VM Region Summary:
ReadOnly portion of Libraries: Total=1.1G resident=0K(0%) swapped_out_or_unallocated=1.1G(100%)
Writable regions: Total=1.6G written=0K(0%) resident=0K(0%) swapped_out=0K(0%) unallocated=1.6G(100%)

                                VIRTUAL   REGION 
REGION TYPE                        SIZE    COUNT (non-coalesced) 
===========                     =======  ======= 
Accelerate framework              1536K       12 
Activity Tracing                   256K        1 
CG backing stores                  768K        4 
CG image                          1088K       60 
ColorSync                          640K       28 
CoreAnimation                     19.0M      284 
CoreGraphics                        32K        2 
CoreImage                           96K        6 
CoreUI image data                 3904K       54 
Foundation                          48K        2 
Image IO                          1712K       11 
Kernel Alloc Once                   32K        1 
MALLOC                           294.5M       62 
MALLOC guard page                  288K       16 
MALLOC_MEDIUM (reserved)         960.0M        8         reserved VM address space (unallocated)
MALLOC_NANO (reserved)           384.0M        1         reserved VM address space (unallocated)
SQLite page cache                  256K        4 
STACK GUARD                       56.2M       13 
Stack                             14.4M       13 
VM_ALLOCATE                        272K       15 
__AUTH                            2494K      285 
__AUTH_CONST                      19.5M      470 
__CTF                               756        1 
__DATA                            15.4M      490 
__DATA_CONST                      18.4M      503 
__DATA_DIRTY                      1706K      200 
__FONT_DATA                          4K        1 
__LINKEDIT                       582.0M       33 
__OBJC_CONST                      3323K      257 
__OBJC_RO                         83.0M        1 
__OBJC_RW                         3168K        1 
__TEXT                           521.9M      522 
__UNICODE                          592K        1 
dyld private memory               1024K        1 
libnetwork                        1152K       16 
mapped file                      499.1M       65 
shared memory                      848K       12 
===========                     =======  ======= 
TOTAL                              3.4G     3456 
TOTAL, minus reserved VM space     2.1G     3456 



-----------
Full Report
-----------

{"app_name":"MFCTOOL.bin","timestamp":"2025-05-28 16:05:54.00 +0800","app_version":"","slice_uuid":"f0b329ab-7294-3ece-9e13-ec1e22473c83","build_version":"","platform":1,"share_with_app_devs":0,"is_first_party":1,"bug_type":"309","os_version":"macOS 12.7.2 (21G1974)","incident_id":"0596E158-05EA-4280-B1AA-F8B802B3B621","name":"MFCTOOL.bin"}
{
  "uptime" : 1900000,
  "procLaunch" : "2025-05-28 16:03:02.1275 +0800",
  "procRole" : "Foreground",
  "version" : 2,
  "userID" : 501,
  "deployVersion" : 210,
  "modelCode" : "Macmini9,1",
  "procStartAbsTime" : 47250022846578,
  "coalitionID" : 95803,
  "osVersion" : {
    "train" : "macOS 12.7.2",
    "build" : "21G1974",
    "releaseType" : "User"
  },
  "captureTime" : "2025-05-28 16:05:54.4650 +0800",
  "incident" : "0596E158-05EA-4280-B1AA-F8B802B3B621",
  "bug_type" : "309",
  "pid" : 53398,
  "procExitAbsTime" : 47254158396025,
  "translated" : false,
  "cpuType" : "ARM-64",
  "procName" : "MFCTOOL.bin",
  "procPath" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/MacOS\/MFCTOOL.bin",
  "parentProc" : "launchd",
  "parentPid" : 1,
  "coalitionName" : "com.apple.mfcbox",
  "crashReporterKey" : "57B94FB4-6A44-571C-3243-401813F68875",
  "sip" : "disabled",
  "vmRegionInfo" : "0x20 is not in any region.  Bytes before following region: 105553518919648\n      REGION TYPE                    START - END         [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->  \n      MALLOC_NANO (reserved)   600018000000-600020000000 [128.0M] rw-\/rwx SM=NUL  ...(unallocated)",
  "isCorpse" : 1,
  "exception" : {"codes":"0x0000000000000001, 0x0000000000000020","rawCodes":[1,32],"type":"EXC_BAD_ACCESS","signal":"SIGSEGV","subtype":"KERN_INVALID_ADDRESS at 0x0000000000000020"},
  "termination" : {"flags":0,"code":11,"namespace":"SIGNAL","indicator":"Segmentation fault: 11","byProc":"exc handler","byPid":53398},
  "vmregioninfo" : "0x20 is not in any region.  Bytes before following region: 105553518919648\n      REGION TYPE                    START - END         [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->  \n      MALLOC_NANO (reserved)   600018000000-600020000000 [128.0M] rw-\/rwx SM=NUL  ...(unallocated)",
  "extMods" : {"caller":{"thread_create":0,"thread_set_state":0,"task_for_pid":0},"system":{"thread_create":0,"thread_set_state":0,"task_for_pid":4},"targeted":{"thread_create":0,"thread_set_state":0,"task_for_pid":0},"warnings":0},
  "faultingThread" : 0,
  "threads" : [{"triggered":true,"id":13803416,"threadState":{"x":[{"value":4363213264},{"value":105553130923296},{"value":2},{"value":6637940812,"symbolLocation":0,"symbol":"nanov2_free_definite_size"},{"value":1},{"value":52},{"value":0},{"value":0},{"value":2305843009213693952},{"value":0},{"value":576460760430598789,"symbolLocation":576460752303423493,"symbol":"OBJC_CLASS_$_NSCGSWindow"},{"value":648518354468526725,"symbolLocation":648518346341351429,"symbol":"OBJC_CLASS_$_NSCGSWindow"},{"value":199},{"value":4266033356},{"value":4268132352},{"value":209},{"value":6638437680,"symbolLocation":0,"symbol":"objc_release"},{"value":8151208440},{"value":0},{"value":4974530560},{"value":4974530632},{"value":4363213264},{"value":2711724449},{"value":4350821984,"symbolLocation":224,"symbol":"_main_thread"},{"value":11791448172606497699},{"value":1},{"value":0},{"value":6124461152},{"value":0}],"flavor":"ARM_THREAD_STATE64","lr":{"value":6638456132},"cpsr":{"value":536875008},"fp":{"value":6124460752},"sp":{"value":6124460688},"esr":{"value":2449473542,"description":"(Data Abort) byte read Translation fault"},"pc":{"value":6638437696,"matchesCrashFrame":1},"far":{"value":32}},"queue":"com.apple.main-thread","frames":[{"imageOffset":38208,"symbol":"objc_release","symbolLocation":16,"imageIndex":0},{"imageOffset":56644,"symbol":"AutoreleasePoolPage::releaseUntil(objc_object**)","symbolLocation":196,"imageIndex":0},{"imageOffset":42660,"symbol":"objc_autoreleasePoolPop","symbolLocation":212,"imageIndex":0},{"imageOffset":270636,"symbol":"_CFAutoreleasePoolPop","symbolLocation":32,"imageIndex":1},{"imageOffset":1434836,"symbol":"__CFRunLoopPerCalloutARPEnd","symbolLocation":48,"imageIndex":1},{"imageOffset":539516,"symbol":"__CFRunLoopRun","symbolLocation":2600,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":205624,"symbol":"RunCurrentEventLoopInMode","symbolLocation":292,"imageIndex":2},{"imageOffset":204980,"symbol":"ReceiveNextEventCommon","symbolLocation":564,"imageIndex":2},{"imageOffset":204392,"symbol":"_BlockUntilNextEventMatchingListInModeWithFilter","symbolLocation":72,"imageIndex":2},{"imageOffset":267448,"symbol":"_DPSNextEvent","symbolLocation":860,"imageIndex":3},{"imageOffset":261552,"symbol":"-[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:]","symbolLocation":1328,"imageIndex":3},{"imageOffset":204668,"symbol":"-[NSApplication run]","symbolLocation":596,"imageIndex":3},{"imageOffset":13976,"symbol":"NSApplicationMain","symbolLocation":1132,"imageIndex":3},{"imageOffset":543764,"sourceLine":300,"sourceFile":"main.m","symbol":"main","imageIndex":4,"symbolLocation":384},{"imageOffset":20620,"symbol":"start","symbolLocation":520,"imageIndex":5}]},{"id":13803422,"queue":"com.apple.root.default-qos","frames":[{"imageOffset":6288,"symbol":"mach_msg_trap","symbolLocation":8,"imageIndex":6},{"imageOffset":7424,"symbol":"mach_msg","symbolLocation":76,"imageIndex":6},{"imageOffset":545088,"symbol":"__CFRunLoopServiceMachPort","symbolLocation":372,"imageIndex":1},{"imageOffset":538096,"symbol":"__CFRunLoopRun","symbolLocation":1180,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":1113048,"symbol":"CFRunLoopRun","symbolLocation":64,"imageIndex":1},{"imageOffset":1094500,"sourceLine":5798,"sourceFile":"DeviceManager.m","symbol":"__51-[DeviceManager dfu_recovery_device_event_callback]_block_invoke","imageIndex":4,"symbolLocation":452},{"imageOffset":9712,"symbol":"_dispatch_call_block_and_release","symbolLocation":32,"imageIndex":7},{"imageOffset":16820,"symbol":"_dispatch_client_callout","symbolLocation":20,"imageIndex":7},{"imageOffset":29384,"symbol":"_dispatch_queue_override_invoke","symbolLocation":784,"imageIndex":7},{"imageOffset":88296,"symbol":"_dispatch_root_queue_drain","symbolLocation":396,"imageIndex":7},{"imageOffset":90372,"symbol":"_dispatch_worker_thread2","symbolLocation":164,"imageIndex":7},{"imageOffset":13092,"symbol":"_pthread_wqthread","symbolLocation":228,"imageIndex":8},{"imageOffset":8320,"symbol":"start_wqthread","symbolLocation":8,"imageIndex":8}]},{"id":13803426,"frames":[{"imageOffset":40592,"symbol":"poll","symbolLocation":8,"imageIndex":6},{"imageOffset":14744,"symbol":"socket_check_fd","symbolLocation":428,"imageIndex":9},{"imageOffset":15504,"symbol":"socket_receive_timeout","symbolLocation":52,"imageIndex":9},{"imageOffset":14440,"symbol":"receive_packet","symbolLocation":108,"imageIndex":10},{"imageOffset":22092,"symbol":"get_next_event","symbolLocation":68,"imageIndex":10},{"imageOffset":10004,"symbol":"device_monitor","symbolLocation":104,"imageIndex":10},{"imageOffset":29292,"symbol":"_pthread_start","symbolLocation":148,"imageIndex":8},{"imageOffset":8332,"symbol":"thread_start","symbolLocation":8,"imageIndex":8}]},{"id":13803430,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13803434,"name":"com.apple.NSEventThread","frames":[{"imageOffset":6288,"symbol":"mach_msg_trap","symbolLocation":8,"imageIndex":6},{"imageOffset":7424,"symbol":"mach_msg","symbolLocation":76,"imageIndex":6},{"imageOffset":545088,"symbol":"__CFRunLoopServiceMachPort","symbolLocation":372,"imageIndex":1},{"imageOffset":538096,"symbol":"__CFRunLoopRun","symbolLocation":1180,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":1761436,"symbol":"_NSEventThread","symbolLocation":196,"imageIndex":3},{"imageOffset":29292,"symbol":"_pthread_start","symbolLocation":148,"imageIndex":8},{"imageOffset":8332,"symbol":"thread_start","symbolLocation":8,"imageIndex":8}]},{"id":13803458,"name":"com.apple.NSURLConnectionLoader","frames":[{"imageOffset":6288,"symbol":"mach_msg_trap","symbolLocation":8,"imageIndex":6},{"imageOffset":7424,"symbol":"mach_msg","symbolLocation":76,"imageIndex":6},{"imageOffset":545088,"symbol":"__CFRunLoopServiceMachPort","symbolLocation":372,"imageIndex":1},{"imageOffset":538096,"symbol":"__CFRunLoopRun","symbolLocation":1180,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":2533176,"imageIndex":11},{"imageOffset":378268,"symbol":"__NSThread__start__","symbolLocation":808,"imageIndex":12},{"imageOffset":29292,"symbol":"_pthread_start","symbolLocation":148,"imageIndex":8},{"imageOffset":8332,"symbol":"thread_start","symbolLocation":8,"imageIndex":8}]},{"id":13804631,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804818,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804820,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804821,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804822,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804823,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804824,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]}],
  "usedImages" : [
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6638399488,
    "size" : 253952,
    "uuid" : "44d5d68a-ad18-33b8-adea-eb65b4dc906c",
    "path" : "\/usr\/lib\/libobjc.A.dylib",
    "name" : "libobjc.A.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6640271360,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.CoreFoundation",
    "size" : 5533696,
    "uuid" : "07e05b49-8c3c-354e-89a7-cc7994572dfe",
    "path" : "\/System\/Library\/Frameworks\/CoreFoundation.framework\/Versions\/A\/CoreFoundation",
    "name" : "CoreFoundation",
    "CFBundleVersion" : "1866"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6787686400,
    "CFBundleShortVersionString" : "2.1.1",
    "CFBundleIdentifier" : "com.apple.HIToolbox",
    "size" : 3358720,
    "uuid" : "07987381-b579-3f72-8ba8-97fa5b5a3352",
    "path" : "\/System\/Library\/Frameworks\/Carbon.framework\/Versions\/A\/Frameworks\/HIToolbox.framework\/Versions\/A\/HIToolbox",
    "name" : "HIToolbox"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6686056448,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.AppKit",
    "size" : 15437824,
    "uuid" : "2f9d63e8-f87c-3348-b5c5-39de32463324",
    "path" : "\/System\/Library\/Frameworks\/AppKit.framework\/Versions\/C\/AppKit",
    "name" : "AppKit",
    "CFBundleVersion" : "2113.60.148"
  },
  {
    "source" : "P",
    "arch" : "arm64",
    "base" : 4342415360,
    "size" : 2244608,
    "uuid" : "f0b329ab-7294-3ece-9e13-ec1e22473c83",
    "path" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/MacOS\/MFCTOOL.bin",
    "name" : "MFCTOOL.bin"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 4350328832,
    "size" : 393216,
    "uuid" : "0a55d424-2537-3f9b-ada1-ef612d185def",
    "path" : "\/usr\/lib\/dyld",
    "name" : "dyld"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6639718400,
    "size" : 229376,
    "uuid" : "6e9cd1b1-2daa-3338-a85a-965721bcebdc",
    "path" : "\/usr\/lib\/system\/libsystem_kernel.dylib",
    "name" : "libsystem_kernel.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6638108672,
    "size" : 290816,
    "uuid" : "26532eb9-1697-3bcb-aa36-f07a3405770a",
    "path" : "\/usr\/lib\/system\/libdispatch.dylib",
    "name" : "libdispatch.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6639947776,
    "size" : 53248,
    "uuid" : "569fc817-bb09-3ef2-8b18-af7f7bd615ec",
    "path" : "\/usr\/lib\/system\/libsystem_pthread.dylib",
    "name" : "libsystem_pthread.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64",
    "base" : 4355932160,
    "size" : 65536,
    "uuid" : "f4558a88-ccf6-3de5-92cf-937c11037767",
    "path" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/Frameworks\/libimfccoreextra.dylib",
    "name" : "libimfccoreextra.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64",
    "base" : 4354588672,
    "size" : 32768,
    "uuid" : "19108f9b-0fcc-3b50-ac83-8fd75d2e78ea",
    "path" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/Frameworks\/libimfcusb.dylib",
    "name" : "libimfcusb.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6720028672,
    "CFBundleShortVersionString" : "1335.5",
    "CFBundleIdentifier" : "com.apple.CFNetwork",
    "size" : 4931584,
    "uuid" : "46dc101d-2215-38ff-b769-f08335df88fc",
    "path" : "\/System\/Library\/Frameworks\/CFNetwork.framework\/Versions\/A\/CFNetwork",
    "name" : "CFNetwork",
    "CFBundleVersion" : "1335.5"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6656020480,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.Foundation",
    "size" : 4136960,
    "uuid" : "ed1a7ccd-78c8-37a7-a4fe-1e5051fcf967",
    "path" : "\/System\/Library\/Frameworks\/Foundation.framework\/Versions\/C\/Foundation",
    "name" : "Foundation",
    "CFBundleVersion" : "1866"
  },
  {
    "size" : 0,
    "source" : "A",
    "base" : 0,
    "uuid" : "00000000-0000-0000-0000-000000000000"
  }
],
  "sharedCache" : {
  "base" : 6636650496,
  "size" : 3144597504,
  "uuid" : "5c4078a4-271a-3960-afba-5253d8f04519"
},
  "vmSummary" : "ReadOnly portion of Libraries: Total=1.1G resident=0K(0%) swapped_out_or_unallocated=1.1G(100%)\nWritable regions: Total=1.6G written=0K(0%) resident=0K(0%) swapped_out=0K(0%) unallocated=1.6G(100%)\n\n                                VIRTUAL   REGION \nREGION TYPE                        SIZE    COUNT (non-coalesced) \n===========                     =======  ======= \nAccelerate framework              1536K       12 \nActivity Tracing                   256K        1 \nCG backing stores                  768K        4 \nCG image                          1088K       60 \nColorSync                          640K       28 \nCoreAnimation                     19.0M      284 \nCoreGraphics                        32K        2 \nCoreImage                           96K        6 \nCoreUI image data                 3904K       54 \nFoundation                          48K        2 \nImage IO                          1712K       11 \nKernel Alloc Once                   32K        1 \nMALLOC                           294.5M       62 \nMALLOC guard page                  288K       16 \nMALLOC_MEDIUM (reserved)         960.0M        8         reserved VM address space (unallocated)\nMALLOC_NANO (reserved)           384.0M        1         reserved VM address space (unallocated)\nSQLite page cache                  256K        4 \nSTACK GUARD                       56.2M       13 \nStack                             14.4M       13 \nVM_ALLOCATE                        272K       15 \n__AUTH                            2494K      285 \n__AUTH_CONST                      19.5M      470 \n__CTF                               756        1 \n__DATA                            15.4M      490 \n__DATA_CONST                      18.4M      503 \n__DATA_DIRTY                      1706K      200 \n__FONT_DATA                          4K        1 \n__LINKEDIT                       582.0M       33 \n__OBJC_CONST                      3323K      257 \n__OBJC_RO                         83.0M        1 \n__OBJC_RW                         3168K        1 \n__TEXT                           521.9M      522 \n__UNICODE                          592K        1 \ndyld private memory               1024K        1 \nlibnetwork                        1152K       16 \nmapped file                      499.1M       65 \nshared memory                      848K       12 \n===========                     =======  ======= \nTOTAL                              3.4G     3456 \nTOTAL, minus reserved VM space     2.1G     3456 \n",
  "legacyInfo" : {
  "threadTriggered" : {
    "queue" : "com.apple.main-thread"
  }
},
  "trialInfo" : {
  "rollouts" : [
    {
      "rolloutId" : "61af99aeda72d16a4beb7756",
      "factorPackIds" : {

      },
      "deploymentId" : 240000409
    },
    {
      "rolloutId" : "6112e14f37f5d11121dcd519",
      "factorPackIds" : {
        "SIRI_TEXT_TO_SPEECH" : "634710168e8be655c1316aaa"
      },
      "deploymentId" : 240000231
    }
  ],
  "experiments" : [

  ]
}
}


