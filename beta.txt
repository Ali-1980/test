//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Created based on libimobiledevice mobilesync API
//  Provides selective backup functionality using mobilesync protocol
//
//  Final Version - 2025.01.27
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// 引入 libimobiledevice 相关头文件
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// 常量定义
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// 基于实际iOS同步类的数据类型映射
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        // 基于实际的iOS同步服务类标识符
        map = @{
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.WebBookmarks",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper"
        };
    });
    return map;
}

// 获取已知的同步类列表 - 用于检测支持的数据类型
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.WebBookmarks",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - SyncDataItem 实现

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
            self.name, self.identifier, @(self.recordCount)];
}

@end

#pragma mark - BackupOptionTask 内部接口

@interface BackupOptionTask () {
    // libimobiledevice C API 指针
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // 操作状态
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // 同步上下文
    dispatch_queue_t _operationQueue;
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;
    
    // 当前操作参数
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // 内部状态
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
}

// 私有方法声明
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// 真实数据处理方法
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// 数据获取方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// 同步操作方法
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// 验证和错误处理
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;

// 工具方法
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;

// 添加状态保护
@property (nonatomic, assign) BOOL isDeallocation;
@property (nonatomic, strong) NSLock *connectionLock;
@property (nonatomic, strong) NSMutableSet *activeOperations;

@end

#pragma mark - BackupOptionTask 实现

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;

#pragma mark - 单例和初始化

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

// 初始化方法
- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        _isDeallocation = NO; // 新增
        
        // 线程安全锁
        _connectionLock = [[NSLock alloc] init];
        _activeOperations = [NSMutableSet set];
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        
        // 设置默认数据存储路径
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        
        [self logMessage:[NSString stringWithFormat:@"BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}

- (void)dealloc {
    
    [self logMessage:@"BackupOptionTask deallocating and cleaning up resources"];
    // 设置释放标志
    _isDeallocation = YES;
    
    // 取消所有进行中的操作
    _cancelRequested = YES;
    
    // 等待活动操作完成
    [self waitForActiveOperationsToComplete];
    
    // 安全断开设备连接
    [self safeDisconnectDevice];
    
    // 清理缓存
    [_syncAnchors removeAllObjects];
    [_dataCache removeAllObjects];
    [_activeOperations removeAllObjects];
    
    [self logMessage:@"BackupOptionTask deallocation completed"];
}

#pragma mark - 设备连接和查询

// 新增：等待活动操作完成
- (void)waitForActiveOperationsToComplete {
    NSTimeInterval timeout = 5.0; // 5秒超时
    NSDate *startTime = [NSDate date];
    
    while (_activeOperations.count > 0 && [[NSDate date] timeIntervalSinceDate:startTime] < timeout) {
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
    }
    
    if (_activeOperations.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"Warning: %lu operations did not complete within timeout",
                         (unsigned long)_activeOperations.count]];
    }
}



- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
    
    if (!deviceUDID || deviceUDID.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Device UDID cannot be empty"];
        }
        return NO;
    }
    
    // 如果已经连接到同一设备，直接返回成功
    if ([_deviceUDID isEqualToString:deviceUDID] && _device && _lockdown && _mobilesync) {
        [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@", deviceUDID]];
        return YES;
    }
    
    // 先断开现有连接
    [self disconnectDevice];
    
    _deviceUDID = [deviceUDID copy];
    return [self connectToDeviceInternal:deviceUDID error:error];
}

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    // 检查是否正在释放
    if (_isDeallocation) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Object is being deallocated"];
        }
        return NO;
    }
    
    [_connectionLock lock]; // 线程安全保护
    
    @try {
        [self setInternalStatus:SyncTaskStatusConnecting];
        
        // 1. 安全连接设备
        idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
        if (ret != IDEVICE_E_SUCCESS) {
            NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
            }
            return NO;
        }
        
        [self logMessage:@"Device connection established"];
        
        // 2. 创建lockdown客户端 - 添加NULL检查
        if (_device == NULL) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"Device handle is NULL"];
            }
            return NO;
        }
        
        lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
        if (ldret != LOCKDOWN_E_SUCCESS) {
            NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
            }
            return NO;
        }
        
        [self logMessage:@"Lockdown connection established"];
        
        // 3. 启动mobilesync服务
        if (![self startMobileSyncService:error]) {
            return NO;
        }
        
        [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@", deviceUDID]];
        [self setInternalStatus:SyncTaskStatusIdle];
        return YES;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception in connectToDeviceInternal: %@", exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:[NSString stringWithFormat:@"Connection exception: %@", exception.reason]];
        }
        return NO;
    } @finally {
        [_connectionLock unlock];
    }
}

// 在 startMobileSyncService 方法中添加重试逻辑
- (BOOL)startMobileSyncService:(NSError **)error {
    int maxRetries = 3;
    int retryDelay = 2; // 秒
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            if (err == MOBILESYNC_E_SUCCESS) {
                return YES;  // 成功
            }
            
            [self logMessage:[NSString stringWithFormat:@"MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
        }
        
        // 如果不是最后一次尝试，等待后重试
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"Retrying in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // 所有尝试都失败
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                         description:@"Failed to create mobilesync client after multiple attempts"];
    }
    return NO;
}

- (void)disconnectDevice {
    [self safeDisconnectDevice];
}

// 修复安全断开连接方法
- (void)safeDisconnectDevice {
    [_connectionLock lock];
    
    @try {
        [self logMessage:@"Safe disconnecting device"];
        
        // 按正确顺序释放资源
        if (_mobilesync) {
            @try {
                mobilesync_finish(_mobilesync);
                mobilesync_client_free(_mobilesync);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing mobilesync: %@", e.reason]];
            }
            _mobilesync = NULL;
        }
        
        if (_afc) {
            @try {
                afc_client_free(_afc);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing afc: %@", e.reason]];
            }
            _afc = NULL;
        }
        
        if (_np) {
            @try {
                np_client_free(_np);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing np: %@", e.reason]];
            }
            _np = NULL;
        }
        
        if (_lockdown) {
            @try {
                lockdownd_client_free(_lockdown);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing lockdown: %@", e.reason]];
            }
            _lockdown = NULL;
        }
        
        if (_device) {
            @try {
                idevice_free(_device);
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception freeing device: %@", e.reason]];
            }
            _device = NULL;
        }
        
        [self setInternalStatus:SyncTaskStatusIdle];
        
    } @finally {
        [_connectionLock unlock];
    }
}

- (BOOL)isConnected {
    return (_device != NULL && _lockdown != NULL && _mobilesync != NULL);
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    @try {
        // 使用正确的API创建anchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // 准备正确的参数
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // 正确调用mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // 如果成功启动，需要结束会话
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

// 修复getSupportedDataTypes方法
- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    // 检查释放状态
    if (_isDeallocation) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Object is being deallocated"];
        }
        return BackupDataTypeNone;
    }
    
    // 创建操作ID用于追踪
    NSString *operationId = [[NSUUID UUID] UUIDString];
    [_activeOperations addObject:operationId];
    
    @try {
        // 重置MobileSync状态 - 添加安全检查
        [_connectionLock lock];
        
        if (_mobilesync && !_isDeallocation) {
            @try {
                mobilesync_finish(_mobilesync);
                mobilesync_client_free(_mobilesync);
                _mobilesync = NULL;
                [NSThread sleepForTimeInterval:0.5];
            } @catch (NSException *e) {
                [self logMessage:[NSString stringWithFormat:@"Exception resetting mobilesync: %@", e.reason]];
            }
        }
        
        [_connectionLock unlock];
        
        // 检查是否被取消
        if (_isDeallocation || _cancelRequested) {
            return BackupDataTypeNone;
        }
        
        // 重新启动MobileSync服务
        if (![self startMobileSyncService:error]) {
            return BackupDataTypeNone;
        }
        
        [self logMessage:@"Getting supported data types with enhanced stability"];
        
        if (![self isConnected]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"Not connected to device"];
            }
            return BackupDataTypeNone;
        }
        
        BackupDataType supportedTypes = BackupDataTypeNone;
        
        // 使用缓存机制
        static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
        static NSString *cachedDeviceUDID = nil;
        static NSDate *cacheTime = nil;
        
        // 检查缓存是否有效（5分钟内且同一设备）
        if (cachedSupportedTypes != BackupDataTypeNone &&
            [cachedDeviceUDID isEqualToString:_deviceUDID] &&
            cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
            
            [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                             (unsigned long)cachedSupportedTypes]];
            return cachedSupportedTypes;
        }
        
        // 确保连接稳定性
        if (![self ensureStableConnection:error]) {
            return BackupDataTypeNone;
        }
        
        NSArray *allDataTypes = @[
            @(BackupDataTypeContacts),
            @(BackupDataTypeCalendars),
            @(BackupDataTypeBookmarks),
            @(BackupDataTypeNotes),
            @(BackupDataTypeReminders),
            @(BackupDataTypeApplications),
            @(BackupDataTypeConfiguration),
            @(BackupDataTypeKeychain),
            @(BackupDataTypeVoiceMemos),
            @(BackupDataTypeWallpaper)
        ];
        
        NSUInteger successCount = 0;
        NSUInteger totalCount = allDataTypes.count;
        
        for (NSNumber *dataTypeNum in allDataTypes) {
            // 检查取消状态
            if (_isDeallocation || _cancelRequested) {
                break;
            }
            
            BackupDataType dataType = [dataTypeNum unsignedIntegerValue];
            BOOL isSupported = [self isDataTypeSupportedSafe:dataType];
            
            if (isSupported) {
                supportedTypes |= dataType;
                successCount++;
                [self logMessage:[NSString stringWithFormat:@"✅ Supported data type: %@",
                                 [BackupOptionTask stringForDataType:dataType]]];
            }
            
            // 添加延迟避免过度请求
            if (dataTypeNum != allDataTypes.lastObject && !_isDeallocation) {
                [NSThread sleepForTimeInterval:0.1];
            }
        }
        
        // 更新缓存
        if (successCount > 0 && !_isDeallocation) {
            cachedSupportedTypes = supportedTypes;
            cachedDeviceUDID = [_deviceUDID copy];
            cacheTime = [NSDate date];
        }
        
        [self logMessage:[NSString stringWithFormat:@"📊 Final result: %lu/%lu data types supported",
                         (unsigned long)successCount, (unsigned long)totalCount]];
        
        return supportedTypes;
        
    } @finally {
        // 移除操作追踪
        [_activeOperations removeObject:operationId];
    }
}

// 新增：安全的数据类型支持检查
- (BOOL)isDataTypeSupportedSafe:(BackupDataType)dataType {
    if (_isDeallocation || _cancelRequested) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    [_connectionLock lock];
    
    @try {
        // 检查MobileSync连接
        if (!_mobilesync) {
            [self logMessage:@"MobileSync未连接，跳过检测"];
            return NO;
        }
        
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // 立即结束会话，避免状态残留
        if (supported && _mobilesync) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        if (anchors) {
            mobilesync_anchors_free(anchors);
        }
        
        // 休息避免设备过载
        if (!_isDeallocation) {
            [NSThread sleepForTimeInterval:0.2];
        }
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"检测异常: %@", exception.reason]];
        return NO;
    } @finally {
        [_connectionLock unlock];
    }
}

// ✅ 新增：稳定的连接确保方法
- (BOOL)ensureStableConnection:(NSError **)error {
    // 检查连接状态
    if (![self isConnected]) {
        [self logMessage:@"Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // 重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // ✅ 验证连接质量：尝试简单的lockdown操作
    if (_lockdown) {
        char *device_name = NULL;
        lockdownd_error_t ldret = lockdownd_get_device_name(_lockdown, &device_name);
        
        if (ldret == LOCKDOWN_E_SUCCESS && device_name) {
            free(device_name);
            [self logMessage:@"Connection quality verified"];
            return YES;
        } else {
            [self logMessage:[NSString stringWithFormat:@"Connection quality check failed: %d", ldret]];
            
            // 连接质量不好，尝试重连
            [self disconnectDevice];
            [NSThread sleepForTimeInterval:0.5];
            return [self connectToDeviceInternal:_deviceUDID error:error];
        }
    }
    
    return YES;
}


// ✅ 增强的数据获取方法
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"增强方法获取 %@ 的真实数据", typeName);
    
    // ✅ 连接状态检查
    if (![self isConnected]) {
        NSLog(@"❌ 设备未连接，无法获取 %@ 数据", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // ✅ 多次尝试获取数据
    int maxAttempts = 3;
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
        if (attempt > 0) {
            NSLog(@"重试获取 %@ 数据 (第 %d 次尝试)", typeName, attempt + 1);
            [NSThread sleepForTimeInterval:0.5];
        }
        
        items = [self getDataItemsForType:dataType error:&error];
        
        if (items && items.count > 0) {
            NSLog(@"✅ 第 %d 次尝试成功获取 %@ 数据: %lu 项",
                  attempt + 1, typeName, (unsigned long)items.count);
            break;
        }
        
        if (error) {
            NSLog(@"❌ 第 %d 次尝试获取 %@ 数据失败: %@",
                  attempt + 1, typeName, error.localizedDescription);
            error = nil; // 清除错误以便下次尝试
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"❌ %@ 最终无法获取到数据", typeName);
    return nil;
}




#pragma mark - 数据查询

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // 检查缓存
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // 使用真实的数据获取方法
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // 缓存结果
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - 真实数据获取实现

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"🔧 使用修复版获取 %@ 数据", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // 添加设备兼容性检查
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // ✅ 关键修复：每次数据获取前都重新建立 MobileSync 连接
        [self logMessage:@"🔄 重新建立 MobileSync 连接以确保数据获取稳定性"];
        
        // 强制断开并重建 MobileSync 连接
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // 短暂等待，让设备重置状态
        [NSThread sleepForTimeInterval:0.5];
        
        // 重新启动 MobileSync 服务
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"❌ 重新启动 MobileSync 服务失败: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"✅ MobileSync 连接已重新建立"];
        
        // ✅ 关键修复2：使用与检测时相同的参数
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"❌ 创建anchors失败"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // ✅ 关键修复3：使用检测时完全相同的参数
        uint64_t data_class_version = 106;  // 与检测时保持一致
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"🔧 使用干净连接启动同步会话: %@", syncClass]];
        
        // ✅ 关键修复4：启动同步会话
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"✅ %@ 同步会话启动成功（干净连接）", syncClass]];
            
            // ✅ 使用更稳定的数据获取方法
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"✅ 成功请求 %@ 的所有记录", syncClass]];
                
                // ✅ 改进的数据接收逻辑 - 处理超时和多批次数据
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // 减少最大批次数量
                int timeoutCount = 0;
                int maxTimeouts = 2; // 允许的最大超时次数
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"📦 mobilesync_receive_changes 返回状态: %d (批次 %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // 重置超时计数器
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"📦 处理 %@ 第 %d 批数据",
                                            syncClass, batchCount]];
                            
                            // 🔍 详细分析接收到的数据类型
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"📊 接收到的数据类型: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // 🔧 改进的数据处理：支持多种数据类型
                            NSArray<SyncDataItem *> *batchItems = [self processReceivedDataEnhanced:entities
                                                                                            dataType:dataType
                                                                                           syncClass:syncClass
                                                                                          batchIndex:batchCount];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"✅ 从第 %d 批获取到 %lu 项数据",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"📋 第 %d 批数据为空或处理失败", batchCount]];
                            }
                            
                            // 清理resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"📭 第 %d 批 %@ 返回空数据", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // 🔧 改进的超时处理
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"⏰ %@ 接收超时 (第 %d 次，共 %d 次)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 超时次数达到上限，停止接收", syncClass]];
                            break;
                        }
                        
                        // 如果已经获取到数据，超时可能是正常的结束信号
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"💡 %@ 已获取到数据，超时可能是正常结束", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"❌ 接收 %@ 数据时出错: %d",
                                        syncClass, receive_err]];
                        
                        // 🔧 增强的错误处理
                        [self handleReceiveError:receive_err forSyncClass:syncClass];
                        break;
                    }
                    
                    // 防止无限循环
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 达到最大批次限制(%d)，停止接收",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // 如果标记为最后一条记录，直接退出
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"🏁 %@ 接收到最后记录标记，正常结束", syncClass]];
                        break;
                    }
                    
                    // 添加小延迟，避免过度请求
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // 使用内部逻辑控制循环
                
                [self logMessage:[NSString stringWithFormat:@"📊 %@ 数据接收完成: %d 批次, %lu 项",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"❌ %@ get_all_records失败: %d",
                                syncClass, get_all_err]];
                [self handleSyncError:get_all_err forDataType:dataType operation:@"get_all_records"];
                
                // 🔧 为某些错误提供更好的错误信息
                if (error) {
                    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:get_all_err];
                    *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                     description:errorDesc];
                }
            }
            
            // ✅ 确保会话正确结束
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"✅ %@ 同步会话已结束", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"❌ %@ mobilesync_start失败（干净连接后）: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"错误详情: %s", error_description]];
            }
            
            // ✅ 关键修复5：如果还是失败，说明是真正的不兼容
            [self handleStartSyncError:start_err forSyncClass:syncClass error:error];
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // ✅ 即使没有获取到数据也不算错误
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"📋 %@ 没有可用数据（使用干净连接后确认）", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"📊 %@ 最终获取到 %lu 项真实数据（干净连接）",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 数据获取异常: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}


- (NSArray<SyncDataItem *> *)processReceivedDataEnhanced:(plist_t)entities
                                                dataType:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                              batchIndex:(int)batchIndex {
    
    if (!entities) {
        [self logMessage:[NSString stringWithFormat:@"第 %d 批 %@ 数据为空", batchIndex, syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(entities);
    
    // 🔧 处理不同的数据类型
    switch (type) {
        case PLIST_ARRAY: {
            // 标准数组处理
            [self logMessage:[NSString stringWithFormat:@"📋 处理 %@ 数组数据", syncClass]];
            return [self processRealDataForType:dataType dataArray:entities syncClass:syncClass];
        }
        
        case PLIST_BOOLEAN: {
            // 布尔值可能表示同步状态或空数据
            uint8_t bool_val = 0;
            plist_get_bool_val(entities, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"📤 %@ 返回布尔值: %s",
                             syncClass, bool_val ? "true" : "false"]];
            
            if (bool_val) {
                [self logMessage:[NSString stringWithFormat:@"💡 %@ 同步成功但无数据项", syncClass]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"💡 %@ 同步失败或不支持", syncClass]];
            }
            return @[];
        }
        
        case PLIST_DICT: {
            // 字典可能包含错误信息或状态
            [self logMessage:[NSString stringWithFormat:@"📋 %@ 返回字典数据，尝试解析", syncClass]];
            
            // 先检查字典中的内容
            uint32_t dict_size = plist_dict_get_size(entities);
            [self logMessage:[NSString stringWithFormat:@"📊 字典包含 %u 个键值对", dict_size]];
            
            // 检查是否包含错误信息
            plist_t error_node = plist_dict_get_item(entities, "Error");
            if (error_node) {
                char *error_msg = NULL;
                if (plist_get_node_type(error_node) == PLIST_STRING) {
                    plist_get_string_val(error_node, &error_msg);
                    if (error_msg) {
                        [self logMessage:[NSString stringWithFormat:@"❌ %@ 错误: %s", syncClass, error_msg]];
                        free(error_msg);
                    }
                }
                return @[];
            }
            
            // 检查是否包含状态信息
            plist_t status_node = plist_dict_get_item(entities, "Status");
            if (status_node && plist_get_node_type(status_node) == PLIST_STRING) {
                char *status_msg = NULL;
                plist_get_string_val(status_node, &status_msg);
                if (status_msg) {
                    [self logMessage:[NSString stringWithFormat:@"📋 %@ 状态: %s", syncClass, status_msg]];
                    free(status_msg);
                }
            }
            
            // 如果字典为空或包含有用数据，尝试处理为单个项目
            if (dict_size > 0) {
                [self logMessage:[NSString stringWithFormat:@"💡 尝试将 %@ 字典作为数据项处理", syncClass]];
                SyncDataItem *item = [self createSyncItemFromPlist:entities dataType:dataType index:0];
                if (item) {
                    [self logMessage:[NSString stringWithFormat:@"✅ 成功创建 %@ 数据项: %@", syncClass, item.name ?: @"未命名"]];
                    return @[item];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"❌ 无法从 %@ 字典创建数据项", syncClass]];
                }
            }
            
            return @[];
        }
        
        case PLIST_STRING: {
            // 字符串可能是错误消息
            char *str_val = NULL;
            plist_get_string_val(entities, &str_val);
            if (str_val) {
                [self logMessage:[NSString stringWithFormat:@"📤 %@ 返回字符串: %s", syncClass, str_val]];
                free(str_val);
            }
            return @[];
        }
        
        case PLIST_UINT: {
            // 数字可能是状态码
            uint64_t uint_val = 0;
            plist_get_uint_val(entities, &uint_val);
            [self logMessage:[NSString stringWithFormat:@"📤 %@ 返回数字: %llu", syncClass, uint_val]];
            return @[];
        }
        
        default: {
            [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 返回未知数据类型 %@ (%d)",
                             syncClass, [self stringForPlistType:type], type]];
            return @[];
        }
    }
}

// 🔧 增强的错误处理 - 改进超时处理
- (void)handleReceiveError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass {
    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
    
    switch (error) {
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:[NSString stringWithFormat:@"⏰ %@ 数据接收超时，这可能是正常的结束信号", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:[NSString stringWithFormat:@"🔌 %@ 连接中断，设备可能断开连接", syncClass]];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:[NSString stringWithFormat:@"📋 %@ 数据格式错误，plist解析失败", syncClass]];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"📤 %@ 接收错误: %@", syncClass, errorDesc]];
            break;
    }
}

- (void)handleStartSyncError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass error:(NSError **)outError {
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:[NSString stringWithFormat:@"💡 %@ 在干净连接后仍然参数无效，该设备确实不支持此数据类型的数据获取", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"💡 连接错误，设备可能已断开"];
            if (outError) {
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                    description:@"Device connection lost during sync"];
            }
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"💡 %@ 启动同步失败，错误码: %d", syncClass, error]];
            if (outError) {
                NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                    description:errorDesc];
            }
            break;
    }
    
    [self handleSyncError:error forDataType:0 operation:@"start_sync"];
}


// 🔧 获取MobileSync错误的描述
- (NSString *)getErrorDescriptionForMobileSyncError:(mobilesync_error_t)error {
    switch (error) {
        case MOBILESYNC_E_SUCCESS:
            return @"Success";
        case MOBILESYNC_E_INVALID_ARG:
            return @"Invalid argument - check sync class name and parameters";
        case MOBILESYNC_E_PLIST_ERROR:
            return @"Plist parsing error - data format issue";
        case MOBILESYNC_E_MUX_ERROR:
            return @"Connection error - device may have disconnected";
        case MOBILESYNC_E_SSL_ERROR:
            return @"SSL error - secure connection failed";
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            return @"Receive timeout - device not responding";
        case MOBILESYNC_E_BAD_VERSION:
            return @"Version mismatch - sync protocol version not supported";
        default:
            return [NSString stringWithFormat:@"Unknown sync error: %d", error];
    }
}

// ✅ 新增：改进的数据处理方法，更好地处理空数据情况
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"📋 %@ 数据为空，创建空数据字典", typeName]];
        
        // ✅ 即使没有数据也创建一个有效的字典
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ 支持但当前无数据", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // 计算统计信息
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

// ✅ 新增：改进的增强数据扫描方法
- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== 🔧 开始修复版设备真实数据扫描 ===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // ✅ 首先获取支持的数据类型
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"❌ 获取支持的数据类型失败: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"❌ 设备不支持任何数据类型的选择性同步");
        return @{};
    }
    
    NSLog(@"✅ 设备支持的数据类型掩码: %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // 逐个处理支持的数据类型
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // 只处理设备支持的数据类型
        if (!(supportedTypes & dataType)) {
            NSLog(@"⏭️ 跳过不支持的数据类型: %@", typeName);
            continue;
        }
        
        NSLog(@"🔍 正在获取 %@ 的真实数据...", typeName);
        
        // ✅ 使用改进的数据获取方法
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"📋 %@ 支持但无数据: %@ 项", typeName, itemCount);
            } else {
                NSLog(@"✅ %@ 获取成功: %@ 项", typeName, itemCount);
            }
        } else {
            NSLog(@"❌ %@ 获取失败或无响应", typeName);
        }
        
        // 添加延迟避免过度请求
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== 🔧 修复版数据扫描完成，共处理 %lu 种数据类型 ===",
          (unsigned long)realData.count);
    return [realData copy];
}

#pragma mark - 真实数据处理方法

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 处理非数组类型的情况
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"💡 %@ 返回非数组数据，可能表示空数据集", syncClass]];
        
        // 如果是布尔类型，可能表示同步状态
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ 同步状态: %s",
                             syncClass, bool_val ? "成功" : "失败"]];
        }
        
        return @[]; // 返回空数组而不是失败
    }
    
    // 继续处理数组数据...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}


- (BOOL)checkDeviceCompatibility:(NSError **)error {
    if (![self isConnected]) {
        return NO;
    }
    
    // 获取设备信息
    char *device_name = NULL;
    plist_t product_version_plist = NULL;
    
    // 获取设备名称
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"设备名称: %s", device_name]];
        free(device_name);
    }
    
    // 获取iOS版本
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &product_version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && product_version_plist) {
        char *product_version = NULL;
        plist_get_string_val(product_version_plist, &product_version);
        
        if (product_version) {
            [self logMessage:[NSString stringWithFormat:@"iOS版本: %s", product_version]];
            
            // 检查iOS版本兼容性
            NSString *versionStr = [NSString stringWithUTF8String:product_version];
            NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
            
            if (versionComponents.count > 0) {
                NSInteger majorVersion = [versionComponents[0] integerValue];
                
                if (majorVersion < 9) {
                    [self logMessage:@"⚠️ iOS版本过低，可能不支持选择性同步"];
                } else if (majorVersion >= 15) {
                    [self logMessage:@"💡 iOS 15+设备，可能需要特殊处理"];
                }
            }
            
            free(product_version);
        }
        
        plist_free(product_version_plist);
    }
    
    return YES;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // 提取通用字段
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // 根据数据类型提取特定字段
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // 如果没有标识符，使用索引
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // 如果没有名称，使用默认名称
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // 提取记录ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // 提取修改时间
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // 估算数据大小
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // 默认大小
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 姓名字段
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 电话号码
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // 邮箱地址
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 日历标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 开始时间
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // 结束时间
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 书签标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 备忘录标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 内容
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // 大概估算
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 提醒事项标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 完成状态
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // 优先级
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 尝试各种可能的名称字段
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 添加一些通用元数据
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

#pragma mark - 选择性同步操作

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // 异步执行同步操作
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // 分解数据类型为单独的类型
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // 按数据类型分组
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // 对每种数据类型执行同步
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // 这里可以实现更细粒度的项目同步逻辑
        // 目前先使用数据类型级别的同步
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // 创建备份目录
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - 操作控制

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - 同步操作实现

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // 根据方向执行不同的操作
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // 双向同步暂时不实现
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 获取数据项
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // 创建数据类型目录
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // 保存数据项信息
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // 保存备份元数据
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - 数据类型工具方法

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // 这里可以根据需要添加本地化支持
    // 目前返回英文版本
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
}

#pragma mark - 便捷方法

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // 设置完成回调来捕获结果
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - 数据验证和恢复

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // 尝试读取文件以验证格式
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // 参数验证
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查路径是否存在
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // 确保是目录而不是文件
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // 获取基本信息 - 添加错误处理
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // 设置默认值
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // 扫描数据类型
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // 自动释放池，避免内存累积
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // 检查items.plist是否存在
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // 尝试读取items数据
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // 计算该数据类型的大小
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // 设置汇总信息
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // 添加备份统计信息
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - 验证和错误处理

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 增强的类型检查和日志
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // 如果不是数组，尝试处理其他可能的类型
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // 可能表示没有数据或操作失败
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // 如果是true，可能表示成功但无数据
        }
        
        [self logMessage:[NSString stringWithFormat:@"⚠️ Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

#pragma mark - 新增的辅助方法

// 🔧 设备兼容性检查 - 修复版本
- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"📱 设备未连接或lockdown未初始化"];
        return;
    }
    
    // 修复1：正确获取设备名称
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"📱 设备名称: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"📱 获取设备名称失败: %d", ret]];
    }
    
    // 修复2：正确获取iOS版本
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"📱 iOS版本: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"⚠️ iOS版本过低，可能不支持选择性同步"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"💡 iOS 15+设备，数据格式可能有变化"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"💡 iOS %ld 设备，兼容性良好", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"📱 获取iOS版本失败: %d", ret]];
    }
    
    // 修复3：正确获取设备型号
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"📱 设备型号: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"📱 获取设备型号失败: %d", ret]];
    }
}

// 🔧 Plist类型转换为可读字符串
- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}


- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // 根据错误类型采取不同的处理策略
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // 尝试重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // 快速检查是否支持此数据类型
    return [self isDataTypeSupported:dataType];
}

#pragma mark - 调试和诊断工具

- (void)diagnoseDeviceSyncCapabilities {
    [self logMessage:@"=== Device Sync Capabilities Diagnosis ==="];
    
    if (![self isConnected]) {
        [self logMessage:@"❌ Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"📱 Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"✅" : @"❌";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"📊 Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
    [self logMessage:@"=== End Diagnosis ==="];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount)
            };
        }
    }
    
    return info;
}

#pragma mark - 私有方法实现

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - 工具方法

- (void)logMessage:(NSString *)message {
    NSString *timestamp = [self getCurrentTimestamp];
    NSString *logMessage = [NSString stringWithFormat:@"[%@] [BackupOptionTask] %@", timestamp, message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}



// ✅ 格式化文件大小方法 - 如果不存在的话
- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}



// getDataItemsSimplified 方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"获取简化数据项 - 类型: %@, 同步类: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // 验证参数
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"同步类参数不能为空"];
        }
        return @[];
    }
    
    // 确保设备连接
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"设备未连接"];
        }
        return @[];
    }
    
    // ✅ 关键修复：移除重复的支持检查
    // 上层代码已经通过 getSupportedDataTypes 验证过支持性，避免重复检查导致状态冲突
    [self logMessage:[NSString stringWithFormat:@"跳过重复支持检查，直接获取 %@ 数据", syncClass]];
    
    // 直接调用数据获取方法
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"✅ 成功获取 %@ 数据: %lu 项",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"📋 %@ 数据为空或获取失败", syncClass]];
    }
    
    return items ?: @[];
}

@end




//
//  DeviceBackupRestore.m
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import "DeviceBackupRestore.h"
#import "DefaultBackupViewController.h"
#import "BackupProgressViewController.h"
#import "EncryptedSettingsViewController.h"
#import "RestoreProgressViewController.h"
#import "DeviceManager.h" // 引入设备管理模块
#import "DatalogsSettings.h"//日志保存路径全局
#import "LanguageManager.h" //语言
#import "CurrentHistoryController.h" //历史操作记录
#import "SidebarViewController.h"
#import "LogUtility.h" // 自定义日志函数LogWithTimestamp，自动添加时间戳
#import "LogManager.h" //全局日志区域
#import "UserManager.h" //登录
#import "DataBaseManager.h" //数据储存管理
#import "BackupTask.h"
#import "BackupOptionTask.h"

@interface DeviceBackupRestore () <NSTableViewDataSource, NSTableViewDelegate>

// 子视图控制器
@property (strong) DefaultBackupViewController *defaultBackupViewController;
@property (strong) BackupProgressViewController *backupProgressViewController;
@property (strong) EncryptedSettingsViewController *encryptedSettingsViewController;
@property (strong) RestoreProgressViewController *restoreProgressViewController;
@property (strong) NSViewController *currentViewController;

// 进度属性的私有设置器
@property (nonatomic, readwrite) double backupProgress;
@property (nonatomic, readwrite) double restoreProgress;
@property (nonatomic, readwrite, getter=isBackupInProgress) BOOL backupInProgress;
@property (nonatomic, readwrite, getter=isRestoreInProgress) BOOL restoreInProgress;

// 备份相关配置
@property (nonatomic, strong) NSString *backupLocationPath;
@property (nonatomic, assign) BOOL backupIsEncrypted;

// 备份数据
@property (nonatomic, strong) NSMutableArray *backupItems;

// ✅ 新增：选择性备份相关属性
@property (nonatomic, strong) BackupOptionTask *backupOptionTask;
@property (nonatomic, strong) NSWindow *selectiveBackupWindow;
@property (nonatomic, strong) NSMutableArray<NSButton *> *dataTypeCheckboxes;
@property (nonatomic, assign) BackupDataType selectedDataTypes;
@property (nonatomic, strong) NSMutableArray<SyncDataItem *> *availableDataItems;


@property (nonatomic, assign) BackupDataType supportedDataTypes;

// ✅ 选择性备份UI控件
@property (nonatomic, strong) NSButton *selectiveBackupButton;
@property (nonatomic, strong) NSProgressIndicator *selectiveBackupProgress;
@property (nonatomic, strong) NSTextField *selectiveBackupStatusLabel;

// ✅ 新增：保存选择性备份前的设备信息
@property (nonatomic, strong) NSString *savedDeviceIDForSelectiveBackup;
@property (nonatomic, strong) NSDictionary *savedDeviceInfoForSelectiveBackup;


// 选择性恢复相关属性
@property (nonatomic, strong) NSWindow *selectiveRestoreWindow;
@property (nonatomic, strong) NSTabView *restoreTabView;
@property (nonatomic, strong) NSTableView *backupListTableView;
@property (nonatomic, strong) NSTableView *dataTypeTableView;
@property (nonatomic, strong) NSMutableArray *availableBackups;
@property (nonatomic, strong) NSMutableArray *restoreableDataTypes;
@property (nonatomic, strong) NSDictionary *selectedBackupInfo;
@property (nonatomic, strong) NSProgressIndicator *restoreProgressBar;
@property (nonatomic, strong) NSTextField *restoreStatusLabel;
@property (nonatomic, assign) BackupDataType selectedRestoreDataTypes;
@property (nonatomic, strong) NSMutableDictionary *deviceScannedData;

@end

@implementation DeviceBackupRestore


#pragma mark - 单例实现

+ (instancetype)sharedInstance {
    static DeviceBackupRestore *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}


#pragma mark - 初始化方法

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"DeviceBackupRestore: viewDidLoad");
    
    // 初始化当前备份文件列表
    self.currentBackupFiles = [NSMutableArray array];
        
    // 初始化 NSPopUpButton
    [self populateDevicePopUpButton];

    //当前设备列表信息
    [self getCurrentConnectedDevicesFromHistorylist];
    
    // 初始化数据
    self.backupItems = [NSMutableArray array];

    NSLog(@"DeviceBackupRestore: 已加载样本备份项目: %lu个", (unsigned long)self.backupItems.count);
    
    // 初始化属性
    self.backupProgress = 0.0;
    self.restoreProgress = 0.0;
    self.backupInProgress = NO;
    self.restoreInProgress = NO;
    
    // 初始化备份设置
    self.backupLocationPath = NSHomeDirectory();
    self.backupIsEncrypted = NO;
    NSLog(@"DeviceBackupRestore: 默认备份位置: %@", self.backupLocationPath);
    
    // 初始化视图控制器
    [self initializeViewControllers];
    
    // 显示默认视图
    [self displayContentController:self.defaultBackupViewController];
    
    self.collectedLogs = [[NSMutableString alloc] init]; // 初始化日志缓存
    
    // ✅ 新增：初始化选择性备份功能
    [self initializeSelectiveBackupFeatures];
    
    NSLog(@"DeviceBackupRestore: 已显示默认备份视图");
}

- (void)viewDidAppear {
    [super viewDidAppear];
    NSLog(@"DeviceBackupRestore: viewDidAppear");
}


#pragma mark - 填充 NSPopUpButton 表头当前连接的设备列表
- (void)populateDevicePopUpButton {
    NSLog(@"[DEBUG] 开始执行 populateDevicePopUpButton 方法");
    
    NSLog(@"[DEBUG] FlasherTabsController 的 deviceUDID: %@, deviceECID: %@", self.deviceUDID, self.deviceECID);
    
    NSDictionary *allDevicesData = [self getCurrentConnectedDevicesFromHistorylist];
    if (!allDevicesData) {
        NSLog(@"[ERROR] 无法提取设备信息，因为 Plist 文件读取失败。");
        return;
    }
    
    // 清空当前的菜单项
    [self.devicePopUpButton removeAllItems];
    
    // 添加一个默认的选项
    NSString *pleaseSelectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseSelectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Select Device"];
    [self.devicePopUpButton addItemWithTitle:pleaseSelectDeviceTitle];
    
    BOOL hasAvailableDevices = NO;
    
    // 确保 NSPopUpButton 已布局完成，以获取正确的宽度
    [self.devicePopUpButton layoutSubtreeIfNeeded];
    
    // 获取 NSPopUpButton 的宽度
    CGFloat popupWidth = self.devicePopUpButton.bounds.size.width;
    
    // 设定制表符在宽度的85%，留出15%的边距
    CGFloat tabLocation = popupWidth * 0.90;
    
    // 创建段落样式并设置制表符位置
    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    NSTextTab *rightTab = [[NSTextTab alloc] initWithType:NSRightTabStopType location:tabLocation];
    [paragraphStyle setTabStops:@[rightTab]];
    [paragraphStyle setDefaultTabInterval:tabLocation];
    
    // 设置字体大小
    CGFloat fontSize = 12.0;
    
    // 遍历所有设备数据
    for (NSString *key in allDevicesData) {
        NSDictionary *device = allDevicesData[key];
        
        // 获取设备连接状态和模式
        BOOL isConnected = [device[@"IsConnected"] boolValue];
        NSString *deviceMode = device[@"Mode"];
        
        // 排除未连接的设备或模式为 "-" 的设备
        if (!isConnected || [deviceMode isEqualToString:@"-"]) {
            NSLog(@"[INFO] 排除设备 - OfficialName: %@, IsConnected: %@, Mode: %@",
                  device[@"OfficialName"] ?: @"Unknown Name",
                  isConnected ? @"YES" : @"NO",
                  deviceMode ?: @"Unknown Mode");
            continue; // 跳过当前循环，处理下一个设备
        }
        
        NSString *officialName = device[@"OfficialName"] ?: @"Unknown Name";
        NSString *udid = device[@"UDID"];
        NSString *ecid = device[@"ECID"] ?: @"Unknown ECID";
        NSString *type = device[@"TYPE"];
        
        NSString *idString;
        NSString *uniqueKey;
        
        if (udid && udid.length > 0) {
            idString = [NSString stringWithFormat:@"UDID: %@", [udid stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
            uniqueKey = udid;
        } else if (ecid && ecid.length > 0) {
            idString = [NSString stringWithFormat:@"ECID: %@", [ecid stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
            uniqueKey = ecid;
        } else {
            idString = @"Unknown ID";
            uniqueKey = key; // 使用 plist 中的 key 作为备用
        }
        
        // 获取本地化后的 mode
        NSString *localizedMode = [self getLocalizedDeviceModeForDevice:device];
        
        // 使用制表符分隔左侧和右侧内容，使用本地化后的 mode
        // 结构: 左侧信息 \t 右侧信息
        NSString *rawString = [NSString stringWithFormat:@"  %@  -  %@ \t  %@", localizedMode, officialName, type];
        
        // 创建属性字符串
        NSDictionary *attributes = @{
            NSParagraphStyleAttributeName: paragraphStyle,
            NSFontAttributeName: [NSFont systemFontOfSize:fontSize]
        };
        NSAttributedString *attrTitle = [[NSAttributedString alloc] initWithString:rawString attributes:attributes];
        
        // 创建 NSMenuItem 并设置 attributedTitle
        NSMenuItem *item = [[NSMenuItem alloc] initWithTitle:rawString action:nil keyEquivalent:@""];
        item.attributedTitle = attrTitle;
        item.representedObject = uniqueKey;
               
        // 检查当前设备是否为选中设备
        BOOL isSelected = ([uniqueKey isEqualToString:self.deviceUDID] || [uniqueKey isEqualToString:self.deviceECID]);
        if (isSelected) {
            [self.devicePopUpButton selectItem:item];
            self.currentDeviceType = type; // 设置当前 deviceType
            self.currentDeviceMode = deviceMode;
            NSLog(@"[DEBUG] 已选中设备信息: %@  Type: %@  Mode: %@",self.deviceOfficialName, self.currentDeviceType, self.currentDeviceMode);
            
            [self lockDeviceWithInfo:uniqueKey officialName:self.deviceOfficialName type:self.currentDeviceType mode:self.currentDeviceMode];
            NSLog(@"[DEBUG] 已选中设备并锁定: %@  Type: %@  Mode: %@",self.deviceOfficialName, self.currentDeviceType, self.currentDeviceMode);
        }
               
        // 添加到 NSPopUpButton
        [self.devicePopUpButton.menu addItem:item];
        
        hasAvailableDevices = YES;
    }
    
    // 如果没有可用设备，显示提示信息
    if (!hasAvailableDevices) {
        NSString *pleaseConnectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseConnectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Connect Device"];
        [self.devicePopUpButton addItemWithTitle:pleaseConnectDeviceTitle];
    }
    

    // 自动选中对应的设备项（根据 deviceUDID 或 deviceECID）
    [self AutoSelectDeviceInPopUpButton];
    
    NSLog(@"[DEBUG] populateDevicePopUpButton 方法执行完成");
}

#pragma mark - 手动选择后获取当前选择的设备信息
- (IBAction)devicePopUpButtonChanged:(id)sender {
    // 获取当前选中的 NSMenuItem
    NSMenuItem *selectedItem = [self.devicePopUpButton selectedItem];
    
    // 从 selectedItem 中获取对应的设备唯一标识符
    NSString *selectedDeviceID = selectedItem.representedObject;
    
    // 通过唯一标识符找到设备的详细信息（比如从缓存的数据中查找）
    NSDictionary *selectedDeviceInfo = [self getDeviceInfoByID:selectedDeviceID];
    
    // 打印设备信息或执行相关操作
    NSLog(@"[INFO] 手动选中设备的详细信息：%@ 选中的ID %@ ", selectedDeviceInfo, selectedDeviceID);

    NSString *deviceOfficialName = selectedDeviceInfo[@"OfficialName"] ?: @"Unknown Name";
    NSString *deviceUDID = selectedDeviceInfo[@"UDID"];
    NSString *deviceECID = selectedDeviceInfo[@"ECID"] ?: @"Unknown ECID";
    NSString *deviceTYPE = selectedDeviceInfo[@"TYPE"];
    NSString *devicePairStatus = selectedDeviceInfo[@"IsPair"];
    //NSString *deviceModel = selectedDeviceInfo[@"MODEL"];
    NSString *deviceMode = selectedDeviceInfo[@"Mode"];
    
    
    NSLog(@"[INFO] 手动选中设备的名称：%@ 模式：%@ 类型：%@ 匹配：%@", deviceOfficialName, deviceMode, deviceTYPE, devicePairStatus);
    
    NSString *idString;
    NSString *uniqueKey;
    
    if (deviceUDID && deviceUDID.length > 0) {
        idString = [NSString stringWithFormat:@"UDID: %@", [deviceUDID stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
        uniqueKey = deviceUDID;
    } else if (deviceECID && deviceECID.length > 0) {
        idString = [NSString stringWithFormat:@"ECID: %@", [deviceECID stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
        uniqueKey = deviceECID;
    } else {
        idString = @"Unknown ID";
        uniqueKey = selectedDeviceID; // 使用 plist 中的 key 作为备用
    }
    
    
    if (deviceTYPE) {
        // 更新当前设备的 deviceType
        self.currentDeviceType = deviceTYPE;
        NSLog(@"当前设备的 deviceType: %@", self.currentDeviceType);

        // 在选择新设备之前取消所有下载任务
      //  [self cancelAllDownloadTasks];

        
        // 锁定并持久化设备信息
        [self lockDeviceWithInfo:uniqueKey officialName:deviceOfficialName type:deviceTYPE mode:deviceMode];
        
        
        // ✅ 修改：直接传递设备信息给备份视图控制器
        if (self.backupProgressViewController) {
            NSLog(@"DeviceBackupRestore: 直接传递设备信息给备份视图控制器");
            
            // 创建设备信息字典
            NSDictionary *deviceInfoToPass = @{
                @"uniqueKey": uniqueKey,
                @"officialName": deviceOfficialName,
                @"type": deviceTYPE,
                @"mode": deviceMode,
                @"udid": deviceUDID ?: @"",
                @"ecid": deviceECID ?: @""
            };
            
            // 直接调用加载方法
            [self.backupProgressViewController loadBackupDataForDevice:uniqueKey deviceInfo:deviceInfoToPass];
        } else {
            NSLog(@"DeviceBackupRestore: 备份视图控制器为空");
        }
        
        // 示例操作：显示设备信息
        NSString *logdeviceOfficialName = [[LanguageManager sharedManager] localizedStringForKeys:@"CurrentDeviceSwitchedto" inModule:@"Flasher" defaultValue:@"The device has been switched to: %@, %@\n"];
        
        // 在 logdeviceOfficialName 前面追加 [warning]
        logdeviceOfficialName = [NSString stringWithFormat:@"[WAR] %@", logdeviceOfficialName];
       
        NSString *choosedDeviceMessage = [NSString stringWithFormat:logdeviceOfficialName, deviceOfficialName, deviceTYPE];
        
        [self showLogsWithMessage:choosedDeviceMessage];//设备切换日志

    } else {
        NSLog(@"[ERROR] 无法根据 uniqueKey 获取设备信息: %@", uniqueKey);
    }
    
    //判断按钮显示状态
    NSLog(@"手动选择后当前设备模式: %@", deviceMode);

    if ([deviceMode isEqualToString:@"Normal"]) {
        [self.backupProgressViewController checkAndLoadExistingBackupData];
    }
    
    // 根据设备类型判断 如果是Watch / Mac 类型 则作相关判断
    if ([deviceTYPE.lowercaseString containsString:@"watch"]) {
        
        /*
        // 如果设备类型为 "watch"，禁用 autoOfficialFirmwareCheckbox
        if (self.autoOfficialFirmwareCheckbox.state == NSControlStateValueOn) {
            // 如果复选框已经选中，取消选择
            self.autoOfficialFirmwareCheckbox.state = NSControlStateValueOff;
        }
        self.autoOfficialFirmwareCheckbox.enabled = NO;
        [self.autoOfficialFirmwareCheckbox setNeedsDisplay:YES]; // 强制刷新*/
    } else {
        /*
        // 如果设备类型不是 "watch"，启用 autoOfficialFirmwareCheckbox
        self.autoOfficialFirmwareCheckbox.enabled = YES;
        [self.autoOfficialFirmwareCheckbox setNeedsDisplay:YES]; // 强制刷新*/
    }
}

- (NSDictionary *)getDeviceInfoByID:(NSString *)deviceID {
    // 示例：从当前已加载的设备列表中找到设备详情
    NSDictionary *allDevicesData = [self getCurrentConnectedDevicesFromHistorylist];
    return allDevicesData[deviceID];
}

#pragma mark - 获取/ 读取当前设备的文件
- (NSDictionary *)getCurrentConnectedDevicesFromHistorylist {
    NSLog(@"[DEBUG] 加载 CurrentDevices.plist");
    NSString *mfcDataPath = [DatalogsSettings mfcDataDirectory];
    NSString *cachesDirectory = [mfcDataPath stringByAppendingPathComponent:@"Caches"];
    NSString *plistPath = [cachesDirectory stringByAppendingPathComponent:@"CurrentDevices.plist"];
   
    // 检查 Plist 文件是否存在
    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) {
        NSLog(@"[ERROR] Plist 文件不存在: %@", plistPath);
        return nil;
    }
    
    // 读取 Plist 文件内容
    NSDictionary *allDevicesData = [NSDictionary dictionaryWithContentsOfFile:plistPath];
    if (!allDevicesData) {
        NSLog(@"[ERROR] 无法读取 Plist 文件内容: %@", plistPath);
        return nil;
    }
    
    return allDevicesData;
}

#pragma mark -  获取当前设备的模式，并返回本地化后的字符串
- (NSString *)getLocalizedDeviceModeForDevice:(NSDictionary *)device {
    LanguageManager *languageManager = [LanguageManager sharedManager];
    
    // 定义设备模式到本地化键的映射
    NSDictionary<NSString *, NSString *> *modeLocalizationKeys = @{
        @"Normal" : @"isNormalModeTitle",
        @"Recovery" : @"isRecoveryModeTitle",
        @"DFU" : @"isDFUModeTitle",
        @"WiFi" : @"isWiFiModeTitle",
        @"WTF" : @"isWTFModeTitle"
    };
    
    // 获取设备的原始模式
    NSString *originalMode = device[@"Mode"];
    
    // 获取对应的本地化键
    NSString *localizationKey = modeLocalizationKeys[originalMode];
    
    // 如果找到对应的本地化键，则进行本地化
    if (localizationKey) {
        NSString *localizedMode = [languageManager localizedStringForKeys:localizationKey inModule:@"DeviceModes" defaultValue:originalMode];
        
        // 检查本地化是否成功（即 localizedMode 不等于 defaultValue）
        if ([localizedMode isEqualToString:originalMode]) {
            NSLog(@"[DEBUG] 模式相同，无须进行本地化. 本地化模式: %@，使用设备原始模式: %@", localizedMode, originalMode);
        }
        
        return localizedMode;
    } else {
        // 如果没有找到对应的本地化键，返回原始模式并记录日志
        NSLog(@"[DEBUG] 未知模式，本地化失败，使用设备原始模式: %@", originalMode);
        return originalMode;
    }
}


#pragma mark -锁定设备并持久化设备信息 同步更新
- (void)lockDeviceWithInfo:(NSString *)uniqueKey officialName:(NSString *)officialName type:(NSString *)type mode:(NSString *)mode {
    // 更新锁定的设备信息
    self.lockedDeviceID = uniqueKey;
    self.deviceType = type;
    self.deviceMode = mode;

    // 创建设备信息字典
    NSDictionary *lockedDeviceInfo = @{
        @"uniqueKey": uniqueKey,
        @"officialName": officialName ?: @"",
        @"type": type ?: @"",
        @"mode": mode ?: @""
    };

    // 持久化锁定的设备信息
    [self setLockedDeviceInfo:lockedDeviceInfo];
    
    // 记录锁定设备的其他信息，如 officialName 和 type 等
    NSLog(@"[INFO] 设备已锁定 - uniqueKey: %@, officialName: %@, type: %@, 模式: %@", uniqueKey, officialName, type, mode);

    // 验证设备信息同步
    NSDictionary *syncedDeviceInfo = [self getLockedDeviceInfo];
    NSLog(@"[INFO] 锁定设备同步信息 - %@", syncedDeviceInfo);
}


#pragma mark - 从内存获取锁定的设备ID
- (NSString *)getLockedDeviceID {
    return self.lockedDeviceID;
}

#pragma mark - 设备锁定信息存入内存
- (void)setLockedDeviceID:(NSString *)lockedDeviceID {
    _lockedDeviceID = lockedDeviceID;
}

#pragma mark - 从内存获取已锁定的设备信息
- (NSDictionary *)getLockedDeviceInfo {
    return self.LockedDeviceInfo;
}

#pragma mark - 设备锁定信息存入内存（字典）
- (void)setLockedDeviceInfo:(NSDictionary *)LockedDeviceInfo {
    _LockedDeviceInfo = LockedDeviceInfo;
}


#pragma mark -  辅助方法：根据 deviceUDID 或 deviceECID 自动选中对应的设备项
- (void)AutoSelectDeviceInPopUpButton {
    BOOL found = NO;
    NSString *selectedDeviceID = nil;
    
    // 在执行固件操作之前移除 deviceListDidChange 监听
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"DeviceListChangedNotification" object:nil];
    
    // 优先根据 deviceUDID 进行匹配
    if (self.deviceUDID && self.deviceUDID.length > 0) {
        for (NSMenuItem *item in self.devicePopUpButton.menu.itemArray) {
            if ([item.representedObject isEqualToString:self.deviceUDID]) {
                [self.devicePopUpButton selectItem:item];
                selectedDeviceID = self.deviceUDID; //自动选中的
                found = YES;
                break;
            }
        }
    }

    // 如果未找到匹配的 deviceUDID，尝试根据 deviceECID 进行匹配
    if (!found && self.deviceECID && self.deviceECID.length > 0) {
        for (NSMenuItem *item in self.devicePopUpButton.menu.itemArray) {
            if ([item.representedObject isEqualToString:self.deviceECID]) {
                [self.devicePopUpButton selectItem:item];
                selectedDeviceID = self.deviceECID; //自动选中的
                found = YES;
                break;
            }
        }
    }
    

    if (found) {
        self.lockedDeviceID = selectedDeviceID;  // 锁定设备
        //[self setLockedDeviceID];
        
        [self setLockedDeviceID:selectedDeviceID]; // 持久化设备信息
        
        //判断按钮显示状态
        NSLog(@"自动选中后判断按钮显示状态: %@" , self.currentDeviceMode);
        BOOL isLoggedIn = [UserManager sharedManager].isUserLoggedIn;
        if ([self.currentDeviceMode isEqualToString:@"Normal"] && isLoggedIn) {
          //  self.eraseDevice.enabled = YES; //擦除内容
         //   self.triggerPairButton.enabled = YES;
           // self.triggerUnPairButton.enabled = YES;
        }else{
          //  self.eraseDevice.enabled = NO; //擦除内容
          //  self.triggerPairButton.enabled = NO;
          //  self.triggerUnPairButton.enabled = NO;
        }
        
        // 固件操作完成后开始定时每 3 秒监听一次
       // [self startDeviceListMonitoring];
        
    } else {
        // 未找到匹配设备，解除锁定
        self.lockedDeviceID = nil;
        [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"LockedDeviceID"];
    }
}

#pragma mark - 刷新日志显示

- (void)showLogsWithMessage:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        // 生成时间戳
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
        NSString *timestamp = [dateFormatter stringFromDate:[NSDate date]];

        // 手动生成带时间戳的日志
        NSString *formattedLog = [NSString stringWithFormat:@"[%@] %@", timestamp, message];

        // 获取日志显示的 NSTextView
        NSTextView *textView = (NSTextView *)[LogManager sharedManager].logScrollView.documentView;
        if (textView) {
            // ✅ 直接调用 AppendLogToTextView 追加日志（仍然是原始 message）
            AppendLogToTextView(textView, message);

            // 自动滚动到底部
            NSRange endRange = NSMakeRange(textView.string.length, 0);
            [textView scrollRangeToVisible:endRange];

            // ✅ 存入 collectedLogs，但加上时间戳，确保最终日志文件有完整格式
            [self.collectedLogs appendFormat:@"%@\n", formattedLog];
        } else {
            NSLog(@"[ERROR] Failed to access NSTextView.");
        }
    });
}

#pragma mark - 初始化视图控制器

- (void)initializeViewControllers {
    NSLog(@"DeviceBackupRestore: 初始化视图控制器");
    
    // 从Storyboard实例化子视图控制器
    self.defaultBackupViewController = [self.storyboard instantiateControllerWithIdentifier:@"DefaultBackupViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化DefaultBackupViewController");
    
    self.backupProgressViewController = [self.storyboard instantiateControllerWithIdentifier:@"BackupProgressViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化BackupProgressViewController");
    
    self.encryptedSettingsViewController = [self.storyboard instantiateControllerWithIdentifier:@"EncryptedSettingsViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化EncryptedSettingsViewController");
    
    self.restoreProgressViewController = [self.storyboard instantiateControllerWithIdentifier:@"RestoreProgressViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化RestoreProgressViewController");
    
    // 设置默认备份视图的数据源
    self.defaultBackupViewController.backupItems = self.backupItems;
    
    // 将自己设置为各个子视图控制器的代理
    self.backupProgressViewController.delegate = (id<BackupProgressDelegate>)self;
    self.encryptedSettingsViewController.delegate = (id<EncryptedSettingsDelegate>)self;
    self.restoreProgressViewController.delegate = (id<RestoreProgressDelegate>)self;
}

#pragma mark - 视图切换管理

- (void)displayContentController:(NSViewController *)content {
    NSLog(@"DeviceBackupRestore: 切换到视图控制器: %@", NSStringFromClass([content class]));
    
    // 检查新内容是否为空
    if (!content) {
        NSLog(@"DeviceBackupRestore: 错误 - 尝试显示空的视图控制器");
        return;
    }
    
    // 检查 contentView 是否存在
    if (!self.contentView) {
        NSLog(@"DeviceBackupRestore: 错误 - contentView 为空，无法添加子视图");
        return;
    }
    
    // 移除当前视图控制器
    if (self.currentViewController) {
        // 先从视图层级中移除视图
        [self.currentViewController.view removeFromSuperview];
        
        // 直接从父视图控制器中移除
        [self.currentViewController removeFromParentViewController];
        
        NSLog(@"DeviceBackupRestore: 已移除当前视图控制器: %@", NSStringFromClass([self.currentViewController class]));
    }
    
    // 添加新的视图控制器
    [self addChildViewController:content];
    
    // 添加视图
    NSView *contentView = content.view;
    [self.contentView addSubview:contentView];
    contentView.frame = self.contentView.bounds;
    contentView.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable;
    
    // 更新当前视图控制器引用
    self.currentViewController = content;
    NSLog(@"DeviceBackupRestore: 已添加新视图控制器: %@", NSStringFromClass([content class]));
}



#pragma mark - 按钮动作方法
- (IBAction)showBackupManageView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了备份管理按钮");
    [self displayContentController:self.defaultBackupViewController];
    [self updateButtonStates:self.backupManageButton];
}


- (IBAction)showBackupView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了立即备份按钮");
    [self displayContentController:self.backupProgressViewController];
    [self updateButtonStates:self.startBackupButton];
    
    // ✅ 在切换到备份视图时也传递当前设备信息
    if (self.lockedDeviceID && self.lockedDeviceID.length > 0) {
        NSLog(@"DeviceBackupRestore: 传递当前设备信息到备份视图");
        [self.backupProgressViewController loadBackupDataForDevice:self.lockedDeviceID deviceInfo:self.LockedDeviceInfo];
    }
    
    // 获取当前锁定的设备ID（UDID 或 ECID）
    NSString *lockedDeviceID = self.lockedDeviceID;
    if (!lockedDeviceID) {
        lockedDeviceID = [self getLockedDeviceID];
        NSLog(@"尝试从UserDefaults获取锁定的设备ID: %@", lockedDeviceID);
    }
    NSLog(@"当前获取到锁定的设备ID: %@", lockedDeviceID);
    
    // 自动开始备份
    [self triggerStartBackup:nil];
}

- (IBAction)showEncryptedSettingsView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了备份加密按钮");
    [self displayContentController:self.encryptedSettingsViewController];
    [self updateButtonStates:self.encryptedBackupButton];
    
    // 更新加密设置视图中的状态
    [self.encryptedSettingsViewController updateEncryptionStatus:self.backupIsEncrypted];
}

- (IBAction)showRestoreView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了恢复备份按钮");
    [self displayContentController:self.restoreProgressViewController];
    [self updateButtonStates:self.restoreButton];
    
    // 更新恢复视图的备份列表
    [self.restoreProgressViewController setBackupItems:self.backupItems];
}

- (void)updateButtonStates:(NSButton *)activeButton {
    if (!activeButton) {
        NSLog(@"DeviceBackupRestore: 警告 - 尝试更新按钮状态，但活动按钮为空");
        return;
    }
    
    NSLog(@"DeviceBackupRestore: 更新按钮状态，当前活动按钮: %@", activeButton.title);
    
    // 全面进行空指针检查
    if ([self.backupManageButton isKindOfClass:[NSButton class]]) {
        [self.backupManageButton setState:(activeButton == self.backupManageButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - backupManageButton 类型错误或为空");
    }
    
    if ([self.startBackupButton isKindOfClass:[NSButton class]]) {
        [self.startBackupButton setState:(activeButton == self.startBackupButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - startBackupButton 类型错误或为空");
    }
    
    if ([self.encryptedBackupButton isKindOfClass:[NSButton class]]) {
        [self.encryptedBackupButton setState:(activeButton == self.encryptedBackupButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - encryptedBackupButton 类型错误或为空");
    }
    
    if ([self.restoreButton isKindOfClass:[NSButton class]]) {
        [self.restoreButton setState:(activeButton == self.restoreButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - restoreButton 类型错误或为空");
    }
}

#pragma mark - 公开方法

// 备份调用方法
- (IBAction)triggerStartBackup:(NSButton *)sender {
    sender.enabled = NO; // 禁用按钮，防止重复点击
    
    NSString *deviceUDID = self.lockedDeviceID;
    
    if (!deviceUDID || deviceUDID.length == 0) {
        NSString *pleaseSelectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseSelectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Select Device"];
        pleaseSelectDeviceTitle = [NSString stringWithFormat:@"[WAR] %@", pleaseSelectDeviceTitle];
        [self showLogsWithMessage:pleaseSelectDeviceTitle];
        sender.enabled = YES;
        return;
    }

    [self showLogsWithMessage:[NSString stringWithFormat:@"将要备份的设备: %@ 模式: %@", self.lockedDeviceID, self.deviceMode]];
    
    // 清空当前备份文件列表
    [self.currentBackupFiles removeAllObjects];
    
    // 重置备份进度视图控制器的状态
    if (self.backupProgressViewController) {
        [self.backupProgressViewController startBackupWithInitialLog:@"准备开始备份...\n"];
        [self.backupProgressViewController updateProgress:0.0];
    }
    
    // 记录操作日志
    NSString *logRecord = [[LanguageManager sharedManager] localizedStringForKeys:@"HandleBackupDevice"
                                                                       inModule:@"OperationRecods"
                                                                  defaultValue:@"Handle Backup Device"];
    [[DataBaseManager sharedInstance] addOperationRecord:logRecord forDeviceECID:deviceUDID UDID:deviceUDID];
    
    if (![self.deviceMode isEqualToString:@"Normal"]) {
        NSString *logMessage = @"[WAR] 设备模式非正常，无法执行备份";
        [self showLogsWithMessage:logMessage];
        sender.enabled = YES;
        self.isWorking = NO;
        return;
    }
    
    // ✅ 创建带时间戳的备份目录
    NSString *timestampedBackupPath = [self createTimestampedBackupDirectoryForDevice:deviceUDID];
    if (!timestampedBackupPath) {
        NSString *errorMessage = @"[ERR] 无法创建备份目录";
        [self showLogsWithMessage:errorMessage];
        sender.enabled = YES;
        self.isWorking = NO;
        return;
    }
    
    [self showLogsWithMessage:[NSString stringWithFormat:@"备份目录已创建: %@", [timestampedBackupPath lastPathComponent]]];
    
    // 强引用保留自己，防止被释放
    __strong typeof(self) strongSelf = self;
    
    // 获取BackupTask实例并设置日志回调
    BackupTask *backupTask = [BackupTask sharedInstance];
    
    // 设置日志回调 - 关键修改
    backupTask.logCallback = ^(NSString *logMessage) {
        dispatch_async(dispatch_get_main_queue(), ^{
            // 格式化日志消息并显示
            NSString *formattedMessage = [NSString stringWithFormat:@"%@", logMessage];
            [strongSelf showLogsWithMessage:formattedMessage];
            
            // 解析文件信息并添加到列表
            [strongSelf parseAndAddBackupFileInfo:logMessage];
        });
    };
    
    // 预先检查设备连接性
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 初步测试设备连接性
        idevice_t testDevice = NULL;
        idevice_error_t ierr = idevice_new(&testDevice, [deviceUDID UTF8String]);
        
        if (ierr != IDEVICE_E_SUCCESS) {
            NSString *errorMsg = [NSString stringWithFormat:@"设备连接测试失败，错误码: %d", ierr];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@", errorMsg]];
                sender.enabled = YES;
                strongSelf.isWorking = NO;
            });
            
            if (testDevice) {
                idevice_free(testDevice);
            }
            return;
        }
        
        if (testDevice) {
            idevice_free(testDevice);
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [strongSelf showLogsWithMessage:@"设备连接测试成功，开始执行备份任务"];
        });
        
        // 使用新的方法：传递自定义备份路径
        [backupTask startBackupForDevice:deviceUDID
                       customBackupPath:timestampedBackupPath  // 传递时间戳备份路径
                               progress:^(double progress, NSString *message) {
            // 进度更新逻辑保持不变
            dispatch_async(dispatch_get_main_queue(), ^{
                // 更新备份进度视图控制器的进度
                if (strongSelf.backupProgressViewController) {
                    [strongSelf.backupProgressViewController updateProgress:progress * 100];
                }
                
                // 定期显示进度信息到日志
                static double lastLoggedProgress = -1;
                if (progress - lastLoggedProgress >= 0.10 || progress >= 1.0) { // 每10%显示一次
                    NSString *progressMessage = [NSString stringWithFormat:@"%@", message];
                    [strongSelf showLogsWithMessage:progressMessage];
                    lastLoggedProgress = progress;
                }
            });
        }
        completion:^(BOOL success, NSError *error) {
            dispatch_async(dispatch_get_main_queue(), ^{
                sender.enabled = YES;
                strongSelf.isWorking = NO;
                
                if (success) {
                    
                    // ✅ 计算当前备份的实际大小
                    uint64_t currentBackupSize = [strongSelf calculateDirectorySize:timestampedBackupPath];
                    NSString *currentBackupSizeFormatted = [strongSelf formatSize:currentBackupSize];
                    
                    
                    // 更新进度为完成状态
                    if (strongSelf.backupProgressViewController) {
                        [strongSelf.backupProgressViewController updateProgress:100.0];
                        // ✅ 备份完成后刷新当前设备的备份列表
                        [strongSelf.backupProgressViewController checkAndLoadExistingBackupData];
                    }
                    
                    NSString *logDeviceBackupCompletedMessage = [[LanguageManager sharedManager] localizedStringForKeys:@"DeviceBackupCompleted"
                                                                                   inModule:@"Backup"
                                                                              defaultValue:@"Device Backup completed successfully"];
                    
                    // ✅ 显示当前备份的大小而不是总大小
                    [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[SUC] %@ - 备份路径: %@, 备份大小: %@",
                                                   logDeviceBackupCompletedMessage,
                                                   [timestampedBackupPath lastPathComponent],
                                                   currentBackupSizeFormatted]];
                    
                    
                    // ✅ 延迟刷新备份列表，确保文件系统操作完成
                    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                        [strongSelf refreshBackupListAfterCompletion:timestampedBackupPath];
                    });
                    
                } else {
                    // 更新进度为失败状态
                    if (strongSelf.backupProgressViewController) {
                        [strongSelf.backupProgressViewController updateProgress:50.0];
                    }
                    
                    NSString *errorMessage = error ? error.localizedDescription : @"未知错误";
                    NSString *logDeviceBackupFailedMessage = [NSString stringWithFormat:@"设备备份失败: %@", errorMessage];
                    [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@", logDeviceBackupFailedMessage]];
                }
                
                // 清除日志回调，避免内存泄漏
                backupTask.logCallback = nil;
            });
        }];
    });
}

#pragma mark - 备份完成后刷新
// 计算目录大小的辅助方法
- (unsigned long long)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    unsigned long long totalSize = 0;
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedLongLongValue];
        }
    }
    return totalSize;
}

// 格式化文件大小的辅助方法
- (NSString *)formatSize:(uint64_t)size {
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)size];
}

- (void)refreshBackupListAfterCompletion:(NSString *)newBackupPath {
    NSLog(@"DeviceBackupRestore: 备份完成，刷新表格数据");
    if (self.backupProgressViewController) {
        // 获取当前设备信息
        NSString *currentDeviceID = self.lockedDeviceID;
        NSDictionary *deviceInfo = self.LockedDeviceInfo;
        
        if (currentDeviceID && currentDeviceID.length > 0) {
            NSLog(@"DeviceBackupRestore: 为设备 %@ 刷新备份列表", currentDeviceID);
            
            // 重新加载当前设备的备份数据
            [self.backupProgressViewController loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
            
            // 显示刷新成功消息
            NSString *refreshMessage = [NSString stringWithFormat:@"备份列表已刷新，新备份: %@", [newBackupPath lastPathComponent]];
            [self showLogsWithMessage:refreshMessage];
            
            // ✅ 可选：滚动到最新的备份项（如果需要的话）
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                [self.backupProgressViewController scrollToNewestBackup];
            });
        } else {
            NSLog(@"DeviceBackupRestore: 无法刷新 - 当前设备ID为空");
            [self showLogsWithMessage:@"[WAR] 无法刷新备份列表 - 设备信息缺失"];
        }
    }
}

#pragma mark - 时间戳备份目录创建

// 为设备创建带时间戳的备份目录
- (NSString *)createTimestampedBackupDirectoryForDevice:(NSString *)deviceUDID {
    NSLog(@"DeviceBackupRestore: 为设备 %@ 创建时间戳备份目录", deviceUDID);
    
    // 获取基础备份路径
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    
    // 创建设备专用目录路径
    NSString *deviceBackupPath = [defaultBackupPath stringByAppendingPathComponent:deviceUDID];
    
    // 生成时间戳字符串
    NSString *timestampString = [self generateBackupTimestamp];
    
    // 创建完整的备份目录路径：/BackupPath/[DeviceUDID]/[TimeStamp]/
    NSString *timestampedBackupPath = [deviceBackupPath stringByAppendingPathComponent:timestampString];
    
    NSLog(@"DeviceBackupRestore: 时间戳备份路径: %@", timestampedBackupPath);
    
    // 创建目录
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    
    BOOL success = [fileManager createDirectoryAtPath:timestampedBackupPath
                           withIntermediateDirectories:YES
                                            attributes:nil
                                                 error:&error];
    
    if (!success) {
        NSLog(@"DeviceBackupRestore: 创建备份目录失败: %@", error.localizedDescription);
        [self showLogsWithMessage:[NSString stringWithFormat:@"[ERR] 创建备份目录失败: %@", error.localizedDescription]];
        return nil;
    }
    
    NSLog(@"DeviceBackupRestore: 成功创建备份目录: %@", timestampedBackupPath);
    return timestampedBackupPath;
}

// 生成备份时间戳字符串
- (NSString *)generateBackupTimestamp {
    NSDate *now = [NSDate date];
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    
    // 设置时区为本地时区
    [formatter setTimeZone:[NSTimeZone localTimeZone]];
    
    // 创建年月日部分 (YYYYMMDD)
    [formatter setDateFormat:@"yyyyMMdd"];
    NSString *datePart = [formatter stringFromDate:now];
    
    // 创建时分部分 (HHMM)
    [formatter setDateFormat:@"HHmm"];
    NSString *timePart = [formatter stringFromDate:now];
    
    // 确定AM/PM
    [formatter setDateFormat:@"a"];
    NSString *ampmPart = [formatter stringFromDate:now];
    
    // 转换AM/PM为英文（防止本地化问题）
    if ([ampmPart containsString:@"上午"] || [ampmPart containsString:@"AM"]) {
        ampmPart = @"AM";
    } else {
        ampmPart = @"PM";
    }
    
    // 组合成最终的时间戳字符串
    NSString *timestamp = [NSString stringWithFormat:@"%@%@%@", datePart, timePart, ampmPart];
    
    NSLog(@"DeviceBackupRestore: 生成备份时间戳: %@", timestamp);
    return timestamp;
}

// 修改解析备份文件信息的方法，使用新的时间戳目录
- (void)parseAndAddBackupFileInfo:(NSString *)logMessage {
    // 解析不同类型的文件信息
    if ([logMessage containsString:@"Receiving file"] || [logMessage containsString:@"Sending file"]) {
        NSString *fileName = [self extractFileNameFromMessage:logMessage];
        NSString *fileSize = [self extractFileSizeFromMessage:logMessage];
                
        // ✅ 使用当前备份会话的路径而不是默认路径
        NSString *currentBackupPath = [self getCurrentBackupSessionPath];
        NSString *isEncrypted = [logMessage containsString:@"Encrypted"] ? @"Yes" : @"No";
        NSString *isImported = [logMessage containsString:@"Backuptype"] ? @"Import" : @"-";
        
        if (fileName && fileName.length > 0) {
            NSDictionary *fileInfo = @{
                @"fileName": fileName,
                @"backuplocation": currentBackupPath ?: [DatalogsSettings defaultBackupPath],
                @"backupfilesize": fileSize ?: @"-",
                @"backupencryptionstatus": isEncrypted ?: @"-",
                @"backuptype": isImported ?: @"-",
                @"backupdate": [NSDate date]
            };
            
            [self.currentBackupFiles addObject:fileInfo];
            
            // 限制列表长度，避免过多条目影响性能
            if (self.currentBackupFiles.count > 1000) {
                [self.currentBackupFiles removeObjectsInRange:NSMakeRange(0, 100)];
            }
            
            // 通知备份进度视图控制器更新文件列表
            if (self.backupProgressViewController) {
                [self.backupProgressViewController updateBackupFilesList:self.currentBackupFiles];
            }
        }
    }
}

// 获取当前备份会话的路径（如果需要跟踪当前备份路径）
- (NSString *)getCurrentBackupSessionPath {
    // 这里可以保存当前备份会话的路径，如果需要的话
    // 目前返回默认路径，可以根据需要进行扩展
    return nil; // 返回nil使用默认路径
}



- (NSString *)extractFileNameFromMessage:(NSString *)message {
    // 提取文件名的正则表达式
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"(?:Receiving|Sending) file (.+?)(?:\\s|$)"
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    
    if (error) {
        return nil;
    }
    
    NSTextCheckingResult *match = [regex firstMatchInString:message
                                                    options:0
                                                      range:NSMakeRange(0, message.length)];
    
    if (match && match.numberOfRanges > 1) {
        NSString *fullPath = [message substringWithRange:[match rangeAtIndex:1]];
        // 只返回文件名，不包含路径
        return [fullPath lastPathComponent];
    }
    
    return nil;
}

- (NSString *)extractFileSizeFromMessage:(NSString *)message {
    // 提取文件大小信息
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"(\\d+(?:\\.\\d+)?\\s*(?:KB|MB|GB|B))"
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    
    if (error) {
        return nil;
    }
    
    NSTextCheckingResult *match = [regex firstMatchInString:message
                                                    options:0
                                                      range:NSMakeRange(0, message.length)];
    
    if (match) {
        return [message substringWithRange:match.range];
    }
    
    return nil;
}

- (void)clearBackupFilesList {
    [self.currentBackupFiles removeAllObjects];
    if (self.backupProgressViewController) {
        [self.backupProgressViewController updateBackupFilesList:self.currentBackupFiles];
    }
}


- (void)startBackup {
    NSLog(@"DeviceBackupRestore: 开始备份");
    if (self.isBackupInProgress) {
        NSLog(@"DeviceBackupRestore: 备份已在进行中，忽略请求");
        return;
    }
    
    self.backupInProgress = YES;
    self.backupProgress = 0.0;
    
    // 通知备份进度视图控制器开始备份
    [self.backupProgressViewController startBackupWithInitialLog:@"开始备份...\n"];
}

#pragma mark - BackupProgressDelegate
- (void)cancelBackup {
    NSLog(@"DeviceBackupRestore: 取消备份");
    if (!self.isBackupInProgress) {
        NSLog(@"DeviceBackupRestore: 当前没有正在进行的备份，忽略请求");
        return;
    }
    
    self.backupInProgress = NO;
    [self.backupProgressViewController appendLog:@"备份已取消\n"];
    NSLog(@"DeviceBackupRestore: 备份已取消");
}

- (void)startRestore {
    NSLog(@"DeviceBackupRestore: 开始恢复");
    if (self.isRestoreInProgress) {
        NSLog(@"DeviceBackupRestore: 恢复已在进行中，忽略请求");
        return;
    }
    
    self.restoreInProgress = YES;
    self.restoreProgress = 0.0;
    
    // 通知恢复进度视图控制器开始恢复
    [self.restoreProgressViewController startRestoreWithInitialLog:@"开始恢复...\n"];
    
    // 模拟恢复进度
    [self simulateRestoreProcess];
}

- (void)cancelRestore {
    NSLog(@"DeviceBackupRestore: 取消恢复");
    if (!self.isRestoreInProgress) {
        NSLog(@"DeviceBackupRestore: 当前没有正在进行的恢复，忽略请求");
        return;
    }
    
    self.restoreInProgress = NO;
    [self.restoreProgressViewController appendLog:@"恢复已取消\n"];
    NSLog(@"DeviceBackupRestore: 恢复已取消");
}

- (void)setBackupLocation:(NSString *)location {
    NSLog(@"DeviceBackupRestore: 设置备份位置: %@", location);
    self.backupLocationPath = location;
}

- (NSString *)currentBackupLocation {
    NSLog(@"DeviceBackupRestore: 获取当前备份位置: %@", self.backupLocationPath);
    return self.backupLocationPath;
}

- (void)setBackupEncryption:(BOOL)encrypted {
    NSLog(@"DeviceBackupRestore: 设置备份加密状态: %@", encrypted ? @"已加密" : @"未加密");
    self.backupIsEncrypted = encrypted;
}

- (BOOL)isBackupEncrypted {
    NSLog(@"DeviceBackupRestore: 获取备份加密状态: %@", self.backupIsEncrypted ? @"已加密" : @"未加密");
    return self.backupIsEncrypted;
}

#pragma mark - 加密设置

- (void)changePassword:(NSString *)currentPassword newPassword:(NSString *)newPassword {
    NSLog(@"DeviceBackupRestore: 修改密码");
    
    // 在实际应用中，应该执行实际的密码验证和修改
    self.backupIsEncrypted = YES;
    NSLog(@"DeviceBackupRestore: 密码已更新");
    
    // 显示成功提示
    [self showAlert:@"密码已更新" informativeText:@"设备备份密码已成功更新"];
}

- (void)deletePassword:(NSString *)currentPassword {
    NSLog(@"DeviceBackupRestore: 删除密码");
    
    // 在实际应用中，应该执行实际的密码验证和删除
    self.backupIsEncrypted = NO;
    NSLog(@"DeviceBackupRestore: 密码已删除");
    
    // 显示成功提示
    [self showAlert:@"密码已删除" informativeText:@"设备备份密码已成功删除"];
}

#pragma mark - 帮助方法

- (void)showAlert:(NSString *)title informativeText:(NSString *)text {
    NSLog(@"DeviceBackupRestore: 显示警告: %@ - %@", title, text);
    NSAlert *alert = [[NSAlert alloc] init];
    [alert setMessageText:title];
    [alert setInformativeText:text];
    [alert addButtonWithTitle:@"确定"];
    [alert beginSheetModalForWindow:self.view.window completionHandler:nil];
}


// 模拟恢复过程
- (void)simulateRestoreProcess {
    NSLog(@"DeviceBackupRestore: 开始模拟恢复过程");
    __block double progress = 0.0;
    __block NSInteger step = 0;
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 0.2 * NSEC_PER_SEC, 0.05 * NSEC_PER_SEC);
    
    dispatch_source_set_event_handler(timer, ^{
        if (!self.isRestoreInProgress || progress >= 100.0) {
            NSLog(@"DeviceBackupRestore: 恢复进程将终止，状态: isRestoreInProgress=%d, progress=%.1f",
                  self.isRestoreInProgress, progress);
            dispatch_source_cancel(timer);
            
            if (progress >= 100.0) {
                NSLog(@"DeviceBackupRestore: 恢复完成");
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self.restoreProgressViewController appendLog:@"恢复完成!\n"];
                    self.restoreInProgress = NO;
                });
            }
            return;
        }
        
        progress += 2.0;
        step++;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self.restoreProgress = progress;
            [self.restoreProgressViewController updateProgress:progress];
            
            // 每5步添加一条日志
            if (step % 5 == 0) {
                NSString *logMessage = [NSString stringWithFormat:@"恢复进度: %.1f%%...\n", progress];
                NSLog(@"DeviceBackupRestore: %@", logMessage);
                [self.restoreProgressViewController appendLog:logMessage];
            }
        });
    });
    
    dispatch_resume(timer);
    NSLog(@"DeviceBackupRestore: 恢复进程计时器已启动");
}



#pragma mark - 统一权限管理
- (BOOL)validateForAction {
    if (!self.deviceUDID) {
        //NSLog(@"设备 UDID 无效或为空");
        // 可以在这里显示一个提示框给用户
        return NO;
    }
    
    UserManager *userManager = [UserManager sharedManager];
    if (!userManager.isUserLoggedIn) {
       // NSLog(@"没有登录");
        // 发送通知以触发登录流程
        [[NSNotificationCenter defaultCenter] postNotificationName:@"ShowLoginNotification" object:nil];
        return NO;
    }
    
    return YES;
}



#pragma mark - ✅ 选择性备份功能初始化
- (void)initializeSelectiveBackupFeatures {
    NSLog(@"DeviceBackupRestore: 初始化选择性备份功能");
    
    // 初始化BackupOptionTask实例
    self.backupOptionTask = [[BackupOptionTask alloc] init];
    
    // 初始化数据
    self.selectedDataTypes = BackupDataTypeNone;
    self.availableDataItems = [NSMutableArray array];
    self.dataTypeCheckboxes = [NSMutableArray array];
    
    // 设置BackupOptionTask的回调
    [self setupBackupOptionTaskCallbacks];
    
    NSLog(@"DeviceBackupRestore: 选择性备份功能初始化完成");
}

- (void)setupBackupOptionTaskCallbacks {
    // 设置进度回调
    __weak typeof(self) weakSelf = self;
    
    self.backupOptionTask.progressCallback = ^(float progress, NSString *operation, NSUInteger current, NSUInteger total) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf updateSelectiveBackupProgress:progress operation:operation current:current total:total];
            }
        });
    };
    
    // 设置状态回调
    self.backupOptionTask.statusCallback = ^(SyncTaskStatus status, NSString *description) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf updateSelectiveBackupStatus:status description:description];
            }
        });
    };
    
    // 设置完成回调
    self.backupOptionTask.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *error) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf handleSelectiveBackupCompletion:success completedTypes:completedTypes error:error];
            }
        });
    };
    
    // 设置日志回调
    self.backupOptionTask.logCallback = ^(NSString *logMessage) {
        dispatch_async(dispatch_get_main_queue(), ^{
            __strong typeof(weakSelf) strongSelf = weakSelf;
            if (strongSelf) {
                [strongSelf showLogsWithMessage:logMessage];
            }
        });
    };
}



#pragma mark - ✅ 选择性备份主要方法

- (IBAction)showSelectiveBackupOptions:(id)sender {
    NSLog(@"DeviceBackupRestore: 🔧 启动修复版选择性备份");
        
    // ✅ 关键修复：重置连接状态
    [self.backupOptionTask disconnectDevice];
    [NSThread sleepForTimeInterval:1.0];
    
    // 重新连接
    NSError *error = nil;
    BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
    
    if (!connected) {
        [self showAlert:@"连接失败" informativeText:error.localizedDescription];
        return;
    }
    
    [self showLogsWithMessage:@"✅ 设备重连成功，开始检测数据类型"];
    
    // 连接到设备并获取支持的数据类型
    [self connectToDeviceAndShowOptions];
}

- (void)connectToDeviceAndShowOptions {
    [self showLogsWithMessage:@"正在连接设备以获取支持的数据类型..."];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (connected) {
                [self showLogsWithMessage:@"设备连接成功，正在获取支持的数据类型..."];
                [self fetchSupportedDataTypesAndShowWindow];
            } else {
                NSString *errorMsg = [NSString stringWithFormat:@"[ERR] 设备连接失败: %@",
                                    error.localizedDescription ?: @"未知错误"];
                [self showLogsWithMessage:errorMsg];
                [self showAlert:@"连接失败" informativeText:error.localizedDescription ?: @"无法连接到设备"];
            }
        });
    });
}

#pragma mark - ✅ 数据类型信息定义
- (NSDictionary *)getDataTypeDisplayInfo {
    static NSDictionary *displayInfo = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        displayInfo = @{
            @(BackupDataTypeContacts): @{
                @"name": @"通讯录",
                @"icon": @"person.crop.circle.fill",
                @"description": @"联系人信息和通话记录",
                @"color": [NSColor systemBlueColor]
            },
            @(BackupDataTypeCalendars): @{
                @"name": @"日历",
                @"icon": @"calendar",
                @"description": @"日程安排和事件提醒",
                @"color": [NSColor systemRedColor]
            },
            @(BackupDataTypeBookmarks): @{
                @"name": @"书签",
                @"icon": @"book.closed.fill",
                @"description": @"Safari浏览器书签",
                @"color": [NSColor systemOrangeColor]
            },
            @(BackupDataTypeNotes): @{
                @"name": @"备忘录",
                @"icon": @"note.text",
                @"description": @"备忘录和笔记内容",
                @"color": [NSColor systemYellowColor]
            },
            @(BackupDataTypeReminders): @{
                @"name": @"提醒事项",
                @"icon": @"bell.fill",
                @"description": @"待办事项和提醒",
                @"color": [NSColor systemOrangeColor]
            },
            @(BackupDataTypeApplications): @{
                @"name": @"应用",
                @"icon": @"app.badge.fill",
                @"description": @"应用程序和数据",
                @"color": [NSColor systemBlueColor]
            },
            @(BackupDataTypeVoiceMemos): @{
                @"name": @"语音备忘录",
                @"icon": @"mic.circle.fill",
                @"description": @"录音文件",
                @"color": [NSColor systemGrayColor]
            },
            @(BackupDataTypeKeychain): @{
                @"name": @"钥匙串",
                @"icon": @"key.fill",
                @"description": @"密码和证书",
                @"color": [NSColor systemGrayColor]
            },
            @(BackupDataTypeWallpaper): @{
                @"name": @"壁纸",
                @"icon": @"photo.fill",
                @"description": @"系统壁纸设置",
                @"color": [NSColor systemPurpleColor]
            },
            @(BackupDataTypeConfiguration): @{
                @"name": @"设置",
                @"icon": @"gear",
                @"description": @"系统配置和偏好设置",
                @"color": [NSColor systemGrayColor]
            }
        };
    });
    return displayInfo;
}


#pragma mark - ✅ 修复的设备扫描方法 - 强制获取真实数据

- (void)fetchSupportedDataTypesAndShowWindow {
    [self showLogsWithMessage:@"正在从设备获取真实数据类型..."];
    
    __weak typeof(self) weakSelf = self;
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        __strong typeof(weakSelf) strongSelf = weakSelf;
        if (!strongSelf) return;
        
        // ✅ 步骤1：确保设备连接和初始化
        if (![strongSelf ensureDeviceConnectionAndInitialization]) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [strongSelf showAlert:@"设备连接失败" informativeText:@"无法建立与设备的连接，请检查设备状态"];
            });
            return;
        }
        
        // ✅ 步骤2：执行真实数据扫描
        NSDictionary *realDataResults = [strongSelf scanRealDeviceData];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [strongSelf handleRealDataScanResults:realDataResults];
        });
    });
}

// ✅ 确保设备连接和正确初始化
- (BOOL)ensureDeviceConnectionAndInitialization {
    NSLog(@"=== 确保设备连接和初始化 ===");
    
    // 1. 检查基本条件
    if (!self.lockedDeviceID || self.lockedDeviceID.length == 0) {
        NSLog(@"❌ 设备ID为空");
        return NO;
    }
    
    // 2. 重新初始化BackupOptionTask（如果需要）
    if (!self.backupOptionTask) {
        NSLog(@"创建新的BackupOptionTask实例");
        self.backupOptionTask = [[BackupOptionTask alloc] init];
        [self setupBackupOptionTaskCallbacks];
    }
    
    // 3. 强制断开现有连接
    [self.backupOptionTask disconnectDevice];
    [NSThread sleepForTimeInterval:0.5];
    
    // 4. 重新连接设备
    NSError *error = nil;
    BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
    
    if (!connected) {
        NSLog(@"❌ 设备连接失败: %@", error.localizedDescription);
        return NO;
    }
    
    NSLog(@"✅ 设备连接成功");
    
    // 5. 验证连接状态
    if (![self.backupOptionTask isConnected]) {
        NSLog(@"❌ 连接验证失败");
        return NO;
    }
    
    // 6. 执行设备诊断以初始化内部状态
    [self.backupOptionTask diagnoseDeviceSyncCapabilities];
    
    NSLog(@"✅ 设备连接和初始化完成");
    return YES;
}

// ✅ 扫描设备中的真实数据
- (NSDictionary *)scanRealDeviceData {
    // 使用增强的扫描方法
    return [self.backupOptionTask scanRealDeviceDataEnhanced];
}

#pragma mark - 🛠️ 调试和日志增强

- (void)performDetailedDiagnosticsEnhanced {
    NSLog(@"=== 执行增强的设备诊断 ===");
    [self showLogsWithMessage:@"🔍 正在执行增强的设备诊断..."];
    
    // 1. 基础连接状态
    BOOL isConnected = [self.backupOptionTask isConnected];
    NSString *connectionMsg = [NSString stringWithFormat:@"设备连接状态: %@",
                              isConnected ? @"✅ 已连接" : @"❌ 未连接"];
    [self showLogsWithMessage:connectionMsg];
    
    if (!isConnected) {
        [self showLogsWithMessage:@"❌ 设备未连接，停止诊断"];
        return;
    }
    
    // 2. 设备信息
    [self showLogsWithMessage:[NSString stringWithFormat:@"目标设备: %@", self.lockedDeviceID]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"设备模式: %@", self.deviceMode]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"设备类型: %@", self.deviceType]];
    
    // 3. 使用修复后的方法获取支持的数据类型
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BackupDataType supportedTypes = [self.backupOptionTask getSupportedDataTypes:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (error) {
                [self showLogsWithMessage:[NSString stringWithFormat:@"❌ 获取支持类型失败: %@",
                                         error.localizedDescription]];
            } else {
                [self showLogsWithMessage:[NSString stringWithFormat:@"✅ 设备支持的数据类型掩码: %lu",
                                         (unsigned long)supportedTypes]];
                
                if (supportedTypes != BackupDataTypeNone) {
                    [self showLogsWithMessage:@"📱 支持的数据类型详情:"];
                    
                    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
                    for (NSNumber *typeNumber in allDataTypes) {
                        BackupDataType dataType = [typeNumber unsignedIntegerValue];
                        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
                        
                        if (supportedTypes & dataType) {
                            [self showLogsWithMessage:[NSString stringWithFormat:@"  ✅ %@", typeName]];
                        }
                    }
                } else {
                    [self showLogsWithMessage:@"❌ 设备不支持任何选择性备份数据类型"];
                    [self showLogsWithMessage:@"💡 建议使用完整备份功能"];
                }
            }
            
            [self showLogsWithMessage:@"🔍 增强设备诊断完成"];
        });
    });
}

// ✅ 获取特定数据类型的真实数据
- (NSDictionary *)getRealDataForType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"获取 %@ 的真实数据", typeName);
    
    // 方法1：直接调用getDataItemsForType
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = [self.backupOptionTask getDataItemsForType:dataType error:&error];
    
    if (error) {
        NSLog(@"❌ 直接获取 %@ 数据出错: %@", typeName, error.localizedDescription);
    }
    
    if (items && items.count > 0) {
        NSLog(@"✅ 直接方法成功获取 %@ 数据: %lu 项", typeName, (unsigned long)items.count);
        return [self createDataDictionary:items forType:dataType];
    }
    
    // 方法2：通过统计信息检查是否有数据
    NSDictionary *stats = [self.backupOptionTask getDataTypeStatistics:dataType error:&error];
    if (stats) {
        NSNumber *itemCount = stats[@"itemCount"];
        NSLog(@"统计信息显示 %@ 有 %@ 项数据", typeName, itemCount);
        
        if ([itemCount integerValue] > 0) {
            // 统计显示有数据，但getDataItemsForType返回空，可能是缓存问题
            [self clearSpecificDataTypeCache:dataType];
            
            // 重新尝试获取
            items = [self.backupOptionTask getDataItemsForType:dataType error:&error];
            if (items && items.count > 0) {
                NSLog(@"✅ 清除缓存后成功获取 %@ 数据: %lu 项", typeName, (unsigned long)items.count);
                return [self createDataDictionary:items forType:dataType];
            }
        }
    }
    
    // 方法3：使用异步方法尝试获取
    return [self tryAsyncDataRetrieval:dataType];
}


// ✅ 创建数据字典
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    if (!items || items.count == 0) {
        return nil;
    }
    
    NSUInteger totalSize = 0;
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,  // 标记这是真实数据
        @"lastScanned": [NSDate date]
    };
}

// ✅ 清除特定数据类型的缓存
- (void)clearSpecificDataTypeCache:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"清除 %@ 的缓存", typeName);
    
    // 由于BackupOptionTask可能没有提供清除特定缓存的方法
    // 我们采用重连的方式来清除状态
    [self.backupOptionTask disconnectDevice];
    [NSThread sleepForTimeInterval:0.1];
    
    NSError *error = nil;
    [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
    
    if (error) {
        NSLog(@"重连设备时出错: %@", error.localizedDescription);
    }
}

// ✅ 尝试异步数据获取
- (NSDictionary *)tryAsyncDataRetrieval:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"尝试异步获取 %@ 数据", typeName);
    
    __block NSArray<SyncDataItem *> *asyncItems = nil;
    __block NSError *asyncError = nil;
    __block BOOL completed = NO;
    
    [self.backupOptionTask getDataItemsForTypeAsync:dataType completion:^(NSArray<SyncDataItem *> *items, NSError *error) {
        asyncItems = items;
        asyncError = error;
        completed = YES;
    }];
    
    // 等待异步完成（最多5秒）
    NSDate *timeout = [NSDate dateWithTimeIntervalSinceNow:5.0];
    while (!completed && [[NSDate date] compare:timeout] == NSOrderedAscending) {
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
    }
    
    if (!completed) {
        NSLog(@"❌ 异步获取 %@ 数据超时", typeName);
        return nil;
    }
    
    if (asyncError) {
        NSLog(@"❌ 异步获取 %@ 数据出错: %@", typeName, asyncError.localizedDescription);
        return nil;
    }
    
    if (asyncItems && asyncItems.count > 0) {
        NSLog(@"✅ 异步方法成功获取 %@ 数据: %lu 项", typeName, (unsigned long)asyncItems.count);
        return [self createDataDictionary:asyncItems forType:dataType];
    }
    
    NSLog(@"❌ %@ 确实没有数据", typeName);
    return nil;
}

// ✅ 处理真实数据扫描结果
- (void)handleRealDataScanResults:(NSDictionary *)realDataResults {
    if (realDataResults.count == 0) {
        [self handleNoRealDataFound];
        return;
    }
    
    // 保存真实数据结果
    self.deviceScannedData = [realDataResults mutableCopy];
    
    // 记录详细结果
    [self logRealDataResults:realDataResults];
    
    NSString *successMsg = [NSString stringWithFormat:@"✅ 成功获取设备真实数据：%lu 种数据类型",
                           (unsigned long)realDataResults.count];
    [self showLogsWithMessage:successMsg];
    
    // 显示选择界面
    [self createAndShowEnhancedSelectiveBackupWindow];
}

// ✅ 记录真实数据结果
- (void)logRealDataResults:(NSDictionary *)realDataResults {
    NSLog(@"=== 真实设备数据获取结果 ===");
    [self showLogsWithMessage:@"📊 设备真实数据统计:"];
    
    for (NSNumber *typeNumber in realDataResults.allKeys) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSDictionary *typeData = realDataResults[typeNumber];
        
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSNumber *itemCount = typeData[@"itemCount"];
        NSString *formattedSize = typeData[@"formattedSize"];
        
        NSString *logMsg = [NSString stringWithFormat:@"  📱 %@: %@ 项, %@ (真实数据)",
                           typeName, itemCount, formattedSize];
        [self showLogsWithMessage:logMsg];
    }
    
    NSLog(@"=== 结果记录完成 ===");
}

// ✅ 处理没有找到真实数据的情况
- (void)handleNoRealDataFound {
    NSLog(@"未找到任何真实设备数据，开始故障排除");
    
    [self showLogsWithMessage:@"❌ 未在设备中找到可备份的数据"];
    
    // 执行详细诊断
    [self performDetailedDiagnostics];
    
    NSString *troubleshootingMsg = @"故障排除建议：\n\n"
                                  @"1️⃣ 设备状态检查：\n"
                                  @"   • 确保设备已解锁\n"
                                  @"   • 确保已点击'信任此电脑'\n"
                                  @"   • 检查设备是否处于正常模式\n\n"
                                  @"2️⃣ 数据权限检查：\n"
                                  @"   • 设备中是否有联系人、日历等数据\n"
                                  @"   • 检查iCloud同步设置\n\n"
                                  @"3️⃣ 连接问题检查：\n"
                                  @"   • 尝试重新连接USB线\n"
                                  @"   • 关闭其他iOS管理软件\n\n"
                                  @"4️⃣ 系统兼容性：\n"
                                  @"   • 检查iOS版本兼容性\n"
                                  @"   • 尝试使用完整备份功能";
    
    [self showAlert:@"未找到可备份数据" informativeText:troubleshootingMsg];
}

// ✅ 执行详细诊断
- (void)performDetailedDiagnostics {
    NSLog(@"=== 执行详细设备诊断 ===");
    [self showLogsWithMessage:@"🔍 正在执行详细设备诊断..."];
    
    // 1. 连接状态诊断
    BOOL isConnected = [self.backupOptionTask isConnected];
    NSString *connectionMsg = [NSString stringWithFormat:@"设备连接状态: %@",
                              isConnected ? @"✅ 已连接" : @"❌ 未连接"];
    [self showLogsWithMessage:connectionMsg];
    
    // 2. 设备信息诊断
    [self showLogsWithMessage:[NSString stringWithFormat:@"目标设备: %@", self.lockedDeviceID]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"设备模式: %@", self.deviceMode]];
    [self showLogsWithMessage:[NSString stringWithFormat:@"设备类型: %@", self.deviceType]];
    
    // 3. 数据类型支持诊断
    NSError *error = nil;
    BackupDataType supportedTypes = [self.backupOptionTask getSupportedDataTypes:&error];
    
    if (error) {
        [self showLogsWithMessage:[NSString stringWithFormat:@"❌ 获取支持类型失败: %@", error.localizedDescription]];
    } else {
        [self showLogsWithMessage:[NSString stringWithFormat:@"✅ 设备支持的数据类型掩码: %lu", (unsigned long)supportedTypes]];
        
        // 列出具体支持的类型
        NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
        for (NSNumber *typeNumber in allDataTypes) {
            BackupDataType dataType = [typeNumber unsignedIntegerValue];
            NSString *typeName = [BackupOptionTask stringForDataType:dataType];
            
            if (supportedTypes & dataType) {
                [self showLogsWithMessage:[NSString stringWithFormat:@"  ✅ 支持: %@", typeName]];
            }
        }
    }
    
    // 4. 调用BackupOptionTask内置诊断
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [self.backupOptionTask diagnoseDeviceSyncCapabilities];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [self showLogsWithMessage:@"🔍 设备同步能力诊断完成，请查看详细日志"];
        });
    });
}
















#pragma mark - ✅ 创建美观的选择界面（类似截图效果）
- (void)createAndShowEnhancedSelectiveBackupWindow {
    NSLog(@"DeviceBackupRestore: 创建增强的选择性备份窗口");
    
    // 创建窗口
    NSRect windowFrame = NSMakeRect(0, 0, 480, 650);
    self.selectiveBackupWindow = [[NSWindow alloc] initWithContentRect:windowFrame
                                                             styleMask:NSWindowStyleMaskTitled | NSWindowStyleMaskClosable
                                                               backing:NSBackingStoreBuffered
                                                                 defer:NO];
    
    [self.selectiveBackupWindow setTitle:@"选择备份内容"];
    [self.selectiveBackupWindow center];
    
    // 创建主视图
    NSView *mainView = [[NSView alloc] initWithFrame:windowFrame];
    [mainView setWantsLayer:YES];
    [mainView.layer setBackgroundColor:[[NSColor controlBackgroundColor] CGColor]];
    [self.selectiveBackupWindow setContentView:mainView];
    
    // 创建标题区域
    [self createTitleSection:mainView];
    
    // 创建数据类型选择区域
    [self createDataTypeGrid:mainView];
    
    // 创建底部控制区域
    [self createBottomControls:mainView];
    
    // 显示窗口
    [self.selectiveBackupWindow makeKeyAndOrderFront:nil];
    
    NSLog(@"DeviceBackupRestore: 增强的选择性备份窗口已显示");
}

// 创建标题区域
- (void)createTitleSection:(NSView *)parentView {
    // 主标题
    NSTextField *titleLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(30, 580, 420, 35)];
    [titleLabel setBezeled:NO];
    [titleLabel setDrawsBackground:NO];
    [titleLabel setEditable:NO];
    [titleLabel setStringValue:@"备份内容"];
    [titleLabel setFont:[NSFont boldSystemFontOfSize:24]];
    [titleLabel setAlignment:NSTextAlignmentLeft];
    [parentView addSubview:titleLabel];
    
    // 副标题
    NSTextField *subtitleLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(30, 550, 420, 25)];
    [subtitleLabel setBezeled:NO];
    [subtitleLabel setDrawsBackground:NO];
    [subtitleLabel setEditable:NO];
    [subtitleLabel setStringValue:@"选择要备份的数据类型，可以节省时间和存储空间"];
    [subtitleLabel setFont:[NSFont systemFontOfSize:14]];
    [subtitleLabel setTextColor:[NSColor secondaryLabelColor]];
    [parentView addSubview:subtitleLabel];
    
    // 分隔线
    NSBox *separator = [[NSBox alloc] initWithFrame:NSMakeRect(30, 535, 420, 1)];
    [separator setBoxType:NSBoxSeparator];
    [parentView addSubview:separator];
}

// 创建数据类型网格
- (void)createDataTypeGrid:(NSView *)parentView {
    NSScrollView *scrollView = [[NSScrollView alloc] initWithFrame:NSMakeRect(20, 120, 440, 400)];
    [scrollView setHasVerticalScroller:YES];
    [scrollView setAutohidesScrollers:YES];
    [scrollView setBorderType:NSNoBorder];
    [scrollView setDrawsBackground:NO];
    [parentView addSubview:scrollView];
    
    // 创建网格容器
    NSView *gridView = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, 420, 0)];
    
    CGFloat yPosition = 10;
    [self.dataTypeCheckboxes removeAllObjects];
    
    NSDictionary *displayInfo = [self getDataTypeDisplayInfo];
    
    // 遍历扫描到的数据类型
    for (NSNumber *typeNumber in self.deviceScannedData.allKeys) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSDictionary *typeInfo = displayInfo[typeNumber];  // ✅ 修复：移除多余的@()
        NSDictionary *scanData = self.deviceScannedData[typeNumber];  // ✅ 修复：移除多余的@()
        
        if (!typeInfo || !scanData) continue;
        
        // 创建单个数据类型项
        NSView *itemView = [self createDataTypeItemCard:dataType
                                               typeInfo:typeInfo
                                               scanData:scanData
                                                  frame:NSMakeRect(10, yPosition, 400, 70)];
        [gridView addSubview:itemView];
        
        yPosition += 80; // 卡片间距
    }
    
    // 设置网格视图大小
    NSRect gridFrame = gridView.frame;
    gridFrame.size.height = MAX(yPosition + 20, 400);
    [gridView setFrame:gridFrame];
    
    [scrollView setDocumentView:gridView];
}


// 创建单个数据类型卡片
- (NSView *)createDataTypeItemCard:(BackupDataType)dataType
                          typeInfo:(NSDictionary *)typeInfo
                          scanData:(NSDictionary *)scanData
                             frame:(NSRect)frame {
    
    // 主容器
    NSView *cardView = [[NSView alloc] initWithFrame:frame];
    [cardView setWantsLayer:YES];
    [cardView.layer setBackgroundColor:[[NSColor controlColor] CGColor]];
    [cardView.layer setCornerRadius:12.0];
    [cardView.layer setBorderWidth:1.0];
    [cardView.layer setBorderColor:[[NSColor separatorColor] CGColor]];
    
    // 复选框
    NSButton *checkbox = [[NSButton alloc] initWithFrame:NSMakeRect(20, 25, 20, 20)];
    [checkbox setButtonType:NSButtonTypeSwitch];
    [checkbox setTarget:self];
    [checkbox setAction:@selector(dataTypeCheckboxChanged:)];
    [checkbox setTag:dataType];
    [cardView addSubview:checkbox];
    [self.dataTypeCheckboxes addObject:checkbox];
    
    // 图标
    NSImageView *iconView = [[NSImageView alloc] initWithFrame:NSMakeRect(55, 20, 30, 30)];
    NSString *iconName = typeInfo[@"icon"];
    if (@available(macOS 11.0, *)) {
        NSImage *icon = [NSImage imageWithSystemSymbolName:iconName accessibilityDescription:nil];
        if (icon) {
            [icon setTemplate:YES];
            [iconView setImage:icon];
            [iconView setContentTintColor:typeInfo[@"color"]];
        }
    } else {
        // 旧版本使用默认图标
        [iconView setImage:[NSImage imageNamed:NSImageNameFolder]];
    }
    [cardView addSubview:iconView];
    
    // 主标题（数据类型名称）
    NSTextField *nameLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(100, 35, 200, 20)];
    [nameLabel setBezeled:NO];
    [nameLabel setDrawsBackground:NO];
    [nameLabel setEditable:NO];
    [nameLabel setStringValue:typeInfo[@"name"]];
    [nameLabel setFont:[NSFont boldSystemFontOfSize:16]];
    [cardView addSubview:nameLabel];
    
    // 统计信息
    NSNumber *itemCount = scanData[@"itemCount"];
    NSString *formattedSize = scanData[@"formattedSize"];
    NSString *statsText = [NSString stringWithFormat:@"%@ 项 • %@", itemCount, formattedSize];
    
    NSTextField *statsLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(100, 15, 200, 18)];
    [statsLabel setBezeled:NO];
    [statsLabel setDrawsBackground:NO];
    [statsLabel setEditable:NO];
    [statsLabel setStringValue:statsText];
    [statsLabel setFont:[NSFont systemFontOfSize:13]];
    [statsLabel setTextColor:[NSColor secondaryLabelColor]];
    [cardView addSubview:statsLabel];
    
    // 右侧箭头（可选）
    if (@available(macOS 11.0, *)) {
        NSImageView *arrowView = [[NSImageView alloc] initWithFrame:NSMakeRect(350, 25, 20, 20)];
        NSImage *arrowIcon = [NSImage imageWithSystemSymbolName:@"chevron.right" accessibilityDescription:nil];
        if (arrowIcon) {
            [arrowIcon setTemplate:YES];
            [arrowView setImage:arrowIcon];
            [arrowView setContentTintColor:[NSColor tertiaryLabelColor]];
        }
        [cardView addSubview:arrowView];
    }
    
    return cardView;
}


// 创建底部控制区域
- (void)createBottomControls:(NSView *)parentView {
    // 进度条
    self.selectiveBackupProgress = [[NSProgressIndicator alloc] initWithFrame:NSMakeRect(30, 80, 420, 8)];
    [self.selectiveBackupProgress setStyle:NSProgressIndicatorStyleBar];
    [self.selectiveBackupProgress setMinValue:0.0];
    [self.selectiveBackupProgress setMaxValue:100.0];
    [self.selectiveBackupProgress setHidden:YES];
    [parentView addSubview:self.selectiveBackupProgress];
    
    // 状态标签
    self.selectiveBackupStatusLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(30, 95, 420, 20)];
    [self.selectiveBackupStatusLabel setBezeled:NO];
    [self.selectiveBackupStatusLabel setDrawsBackground:NO];
    [self.selectiveBackupStatusLabel setEditable:NO];
    [self.selectiveBackupStatusLabel setStringValue:@""];
    [self.selectiveBackupStatusLabel setFont:[NSFont systemFontOfSize:13]];
    [self.selectiveBackupStatusLabel setTextColor:[NSColor secondaryLabelColor]];
    [parentView addSubview:self.selectiveBackupStatusLabel];
    
    // 按钮区域
    // 取消按钮
    NSButton *cancelButton = [[NSButton alloc] initWithFrame:NSMakeRect(270, 25, 80, 32)];
    [cancelButton setTitle:@"取消"];
    [cancelButton setTarget:self];
    [cancelButton setAction:@selector(cancelSelectiveBackup:)];
    [cancelButton setBezelStyle:NSBezelStyleRounded];
    [parentView addSubview:cancelButton];
    
    // 开始备份按钮
    NSButton *startButton = [[NSButton alloc] initWithFrame:NSMakeRect(360, 25, 90, 32)];
    [startButton setTitle:@"开始备份"];
    [startButton setTarget:self];
    [startButton setAction:@selector(startSelectiveBackup:)];
    [startButton setBezelStyle:NSBezelStyleRounded];
    [startButton setKeyEquivalent:@"\r"]; // 回车键
    [parentView addSubview:startButton];
    
    // 全选/清空按钮
    NSButton *selectAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(30, 25, 60, 32)];
    [selectAllButton setTitle:@"全选"];
    [selectAllButton setTarget:self];
    [selectAllButton setAction:@selector(selectAllDataTypes:)];
    [selectAllButton setBezelStyle:NSBezelStyleRounded];
    [parentView addSubview:selectAllButton];
    
    NSButton *clearAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(100, 25, 60, 32)];
    [clearAllButton setTitle:@"清空"];
    [clearAllButton setTarget:self];
    [clearAllButton setAction:@selector(clearAllDataTypes:)];
    [clearAllButton setBezelStyle:NSBezelStyleRounded];
    [parentView addSubview:clearAllButton];
}



- (NSUInteger)countDataTypes:(BackupDataType)dataTypes {
    NSUInteger count = 0;
    NSArray<NSNumber *> *allTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNumber in allTypes) {
        BackupDataType type = [typeNumber unsignedIntegerValue];
        if (dataTypes & type) {
            count++;
        }
    }
    
    return count;
}

#pragma mark - ✅ 选择性备份窗口创建

- (void)createAndShowSelectiveBackupWindow {
    NSLog(@"DeviceBackupRestore: 创建选择性备份窗口");
    
    // 创建窗口
    NSRect windowFrame = NSMakeRect(0, 0, 500, 600);
    self.selectiveBackupWindow = [[NSWindow alloc] initWithContentRect:windowFrame
                                                             styleMask:NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable
                                                               backing:NSBackingStoreBuffered
                                                                 defer:NO];
    
    [self.selectiveBackupWindow setTitle:@"选择性备份"];
    [self.selectiveBackupWindow center];
    
    // 创建内容视图
    NSView *contentView = [[NSView alloc] initWithFrame:windowFrame];
    [self.selectiveBackupWindow setContentView:contentView];
    
    // 创建滚动视图用于数据类型选择
    NSScrollView *scrollView = [[NSScrollView alloc] initWithFrame:NSMakeRect(20, 100, 460, 400)];
    [scrollView setHasVerticalScroller:YES];
    [scrollView setAutohidesScrollers:YES];
    [contentView addSubview:scrollView];
    
    // 创建数据类型选择区域
    [self createDataTypeSelectionView:scrollView];
    
    // 创建底部按钮
    [self createSelectiveBackupButtons:contentView];
    
    // 创建顶部说明标签
    [self createSelectiveBackupInstructions:contentView];
    
    // 显示窗口
    [self.selectiveBackupWindow makeKeyAndOrderFront:nil];
    
    NSLog(@"DeviceBackupRestore: 选择性备份窗口已显示");
}

- (void)createDataTypeSelectionView:(NSScrollView *)scrollView {
    // 创建文档视图
    NSView *documentView = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, 440, 0)];
    
    // 清空之前的选择框
    [self.dataTypeCheckboxes removeAllObjects];
    
    CGFloat yPosition = 10;
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        
        // 检查是否支持此数据类型
        if (!(self.supportedDataTypes & dataType)) {
            continue;
        }
        
        // 创建复选框
        NSButton *checkbox = [[NSButton alloc] initWithFrame:NSMakeRect(20, yPosition, 400, 24)];
        [checkbox setButtonType:NSButtonTypeSwitch];
        [checkbox setTitle:[BackupOptionTask localizedStringForDataType:dataType]];
        [checkbox setTarget:self];
        [checkbox setAction:@selector(dataTypeCheckboxChanged:)];
        [checkbox setTag:dataType];
        
        // 添加到文档视图和数组
        [documentView addSubview:checkbox];
        [self.dataTypeCheckboxes addObject:checkbox];
        
        yPosition += 30;
        
        // 异步获取此数据类型的详细信息
        [self fetchDataItemsForType:dataType checkbox:checkbox];
    }
    
    // 设置文档视图大小
    NSRect docFrame = documentView.frame;
    docFrame.size.height = yPosition + 20;
    [documentView setFrame:docFrame];
    
    [scrollView setDocumentView:documentView];
}

- (void)fetchDataItemsForType:(BackupDataType)dataType checkbox:(NSButton *)checkbox {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self.backupOptionTask getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (items && items.count > 0) {
                NSString *detailText = [NSString stringWithFormat:@"%@ (%lu 项)",
                                      [BackupOptionTask localizedStringForDataType:dataType],
                                      (unsigned long)items.count];
                [checkbox setTitle:detailText];
                
                // 保存数据项到全局数组
                [self.availableDataItems addObjectsFromArray:items];
            } else if (error) {
                NSString *errorText = [NSString stringWithFormat:@"%@ (获取失败)",
                                     [BackupOptionTask localizedStringForDataType:dataType]];
                [checkbox setTitle:errorText];
                [checkbox setEnabled:NO];
            }
        });
    });
}

- (void)createSelectiveBackupButtons:(NSView *)contentView {
    // 开始备份按钮
    NSButton *startButton = [[NSButton alloc] initWithFrame:NSMakeRect(300, 20, 80, 32)];
    [startButton setTitle:@"开始备份"];
    [startButton setTarget:self];
    [startButton setAction:@selector(startSelectiveBackup:)];
    [startButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:startButton];
    
    // 取消按钮
    NSButton *cancelButton = [[NSButton alloc] initWithFrame:NSMakeRect(400, 20, 60, 32)];
    [cancelButton setTitle:@"取消"];
    [cancelButton setTarget:self];
    [cancelButton setAction:@selector(cancelSelectiveBackup:)];
    [cancelButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:cancelButton];
    
    // 全选按钮
    NSButton *selectAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(20, 20, 60, 32)];
    [selectAllButton setTitle:@"全选"];
    [selectAllButton setTarget:self];
    [selectAllButton setAction:@selector(selectAllDataTypes:)];
    [selectAllButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:selectAllButton];
    
    // 清空按钮
    NSButton *clearAllButton = [[NSButton alloc] initWithFrame:NSMakeRect(100, 20, 60, 32)];
    [clearAllButton setTitle:@"清空"];
    [clearAllButton setTarget:self];
    [clearAllButton setAction:@selector(clearAllDataTypes:)];
    [clearAllButton setButtonType:NSButtonTypeMomentaryPushIn];
    [contentView addSubview:clearAllButton];
    
    // 进度指示器
    self.selectiveBackupProgress = [[NSProgressIndicator alloc] initWithFrame:NSMakeRect(20, 60, 460, 20)];
    [self.selectiveBackupProgress setStyle:NSProgressIndicatorStyleBar];
    [self.selectiveBackupProgress setMinValue:0.0];
    [self.selectiveBackupProgress setMaxValue:100.0];
    [self.selectiveBackupProgress setHidden:YES];
    [contentView addSubview:self.selectiveBackupProgress];
    
    // 状态标签
    self.selectiveBackupStatusLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(20, 85, 460, 20)];
    [self.selectiveBackupStatusLabel setBezeled:NO];
    [self.selectiveBackupStatusLabel setDrawsBackground:NO];
    [self.selectiveBackupStatusLabel setEditable:NO];
    [self.selectiveBackupStatusLabel setStringValue:@""];
    [contentView addSubview:self.selectiveBackupStatusLabel];
}

- (void)createSelectiveBackupInstructions:(NSView *)contentView {
    NSTextField *instructionLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(20, 520, 460, 60)];
    [instructionLabel setBezeled:NO];
    [instructionLabel setDrawsBackground:NO];
    [instructionLabel setEditable:NO];
    [instructionLabel setStringValue:@"选择要备份的数据类型。系统将只备份您选择的数据类型，这可以节省时间和存储空间。\n\n注意：选择性备份可能不包含完整的设备还原信息。"];
    [instructionLabel setFont:[NSFont systemFontOfSize:12]];
    [instructionLabel setTextColor:[NSColor secondaryLabelColor]];
    [contentView addSubview:instructionLabel];
}

#pragma mark - ✅ 选择性备份操作方法

- (IBAction)dataTypeCheckboxChanged:(NSButton *)sender {
    BackupDataType dataType = (BackupDataType)sender.tag;
    
    if (sender.state == NSControlStateValueOn) {
        self.selectedDataTypes |= dataType;
        NSLog(@"选中数据类型: %@", [BackupOptionTask stringForDataType:dataType]);
    } else {
        self.selectedDataTypes &= ~dataType;
        NSLog(@"取消选中数据类型: %@", [BackupOptionTask stringForDataType:dataType]);
    }
    
    // 更新统计信息显示
    [self updateSelectionStatistics];
    
    [self updateSelectiveBackupButtonStates];
}

// 更新底部统计信息显示
- (void)updateSelectionStatistics {
    NSDictionary *stats = [self getSelectedDataTypesStatistics];
    NSUInteger typeCount = [stats[@"typeCount"] unsignedIntegerValue];
    
    if (typeCount > 0) {
        NSString *statsText = [NSString stringWithFormat:@"已选择 %lu 种数据类型，共 %@ 项，大小约 %@",
                              (unsigned long)typeCount,
                              stats[@"totalItems"],
                              stats[@"formattedSize"]];
        [self.selectiveBackupStatusLabel setStringValue:statsText];
    } else {
        [self.selectiveBackupStatusLabel setStringValue:@"请选择要备份的数据类型"];
    }
}

// 获取选中的数据类型统计
- (NSDictionary *)getSelectedDataTypesStatistics {
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    NSMutableArray *selectedTypeNames = [NSMutableArray array];
    
    for (NSButton *checkbox in self.dataTypeCheckboxes) {
        if (checkbox.state == NSControlStateValueOn) {
            BackupDataType dataType = (BackupDataType)checkbox.tag;
            NSNumber *dataTypeKey = @(dataType);  // ✅ 先创建NSNumber对象
            NSDictionary *scanData = self.deviceScannedData[dataTypeKey];  // ✅ 使用NSNumber对象作为key
            
            if (scanData) {
                totalItems += [scanData[@"itemCount"] unsignedIntegerValue];
                totalSize += [scanData[@"totalSize"] unsignedIntegerValue];
                
                NSString *typeName = [BackupOptionTask stringForDataType:dataType];
                [selectedTypeNames addObject:typeName];
            }
        }
    }
    
    return @{
        @"totalItems": @(totalItems),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatSize:totalSize],
        @"selectedTypes": [selectedTypeNames copy],
        @"typeCount": @(selectedTypeNames.count)
    };
}

- (IBAction)selectAllDataTypes:(id)sender {
    for (NSButton *checkbox in self.dataTypeCheckboxes) {
        if (checkbox.isEnabled) {
            [checkbox setState:NSControlStateValueOn];
            BackupDataType dataType = (BackupDataType)checkbox.tag;
            self.selectedDataTypes |= dataType;
        }
    }
    
    [self updateSelectiveBackupButtonStates];
    NSLog(@"已选择所有可用的数据类型");
}

- (IBAction)clearAllDataTypes:(id)sender {
    for (NSButton *checkbox in self.dataTypeCheckboxes) {
        [checkbox setState:NSControlStateValueOff];
    }
    
    self.selectedDataTypes = BackupDataTypeNone;
    [self updateSelectiveBackupButtonStates];
    NSLog(@"已清空所有数据类型选择");
}

- (void)updateSelectiveBackupButtonStates {
    // 这里可以根据选择状态更新按钮可用性
    // 例如：如果没有选择任何数据类型，禁用开始备份按钮
}

- (IBAction)startSelectiveBackup:(id)sender {
    NSLog(@"DeviceBackupRestore: 开始选择性备份");
    
    if (self.selectedDataTypes == BackupDataTypeNone) {
        [self showAlert:@"未选择数据类型" informativeText:@"请至少选择一种要备份的数据类型"];
        return;
    }
    
    // ✅ 关键修复：保存当前设备信息
    [self saveCurrentDeviceInfoForSelectiveBackup];
    
    // 显示进度指示器
    [self.selectiveBackupProgress setHidden:NO];
    [self.selectiveBackupProgress setDoubleValue:0.0];
    [self.selectiveBackupStatusLabel setStringValue:@"正在准备选择性备份..."];
    
    // 创建备份目录
    NSString *backupPath = [self createSelectiveBackupDirectory];
    if (!backupPath) {
        [self showAlert:@"创建备份目录失败" informativeText:@"无法创建选择性备份目录"];
        [self restoreDeviceInfoAfterSelectiveBackup]; // 恢复设备信息
        return;
    }
    
    // 显示日志
    NSString *startMessage = [NSString stringWithFormat:@"开始选择性备份，数据类型: %lu，备份路径: %@",
                            (unsigned long)self.selectedDataTypes, [backupPath lastPathComponent]];
    [self showLogsWithMessage:startMessage];
    
    // 开始备份
    NSError *error = nil;
    BOOL started = [self.backupOptionTask backupSelectedDataTypes:self.selectedDataTypes
                                                      toDirectory:backupPath
                                                            error:&error];
    
    if (!started) {
        NSString *errorMsg = [NSString stringWithFormat:@"[ERR] 选择性备份启动失败: %@",
                            error.localizedDescription ?: @"未知错误"];
        [self showLogsWithMessage:errorMsg];
        [self showAlert:@"备份启动失败" informativeText:error.localizedDescription ?: @"未知错误"];
        
        // 隐藏进度指示器并恢复设备信息
        [self.selectiveBackupProgress setHidden:YES];
        [self.selectiveBackupStatusLabel setStringValue:@""];
        [self restoreDeviceInfoAfterSelectiveBackup];
    }
}


#pragma mark - ✅ 新增：设备信息保存和恢复方法

- (void)saveCurrentDeviceInfoForSelectiveBackup {
    NSLog(@"DeviceBackupRestore: 保存选择性备份前的设备信息");
    
    // 保存当前的设备信息
    self.savedDeviceIDForSelectiveBackup = [self.lockedDeviceID copy];
    self.savedDeviceInfoForSelectiveBackup = [self.LockedDeviceInfo copy];
    
    NSLog(@"DeviceBackupRestore: 已保存设备信息 - ID: %@, Info: %@",
          self.savedDeviceIDForSelectiveBackup, self.savedDeviceInfoForSelectiveBackup);
}

- (void)restoreDeviceInfoAfterSelectiveBackup {
    NSLog(@"DeviceBackupRestore: 恢复选择性备份后的设备信息");
    
    if (self.savedDeviceIDForSelectiveBackup && self.savedDeviceInfoForSelectiveBackup) {
        // 恢复设备信息
        self.lockedDeviceID = self.savedDeviceIDForSelectiveBackup;
        self.LockedDeviceInfo = self.savedDeviceInfoForSelectiveBackup;
        
        NSLog(@"DeviceBackupRestore: 已恢复设备信息 - ID: %@", self.lockedDeviceID);
        
        // 清空保存的信息
        self.savedDeviceIDForSelectiveBackup = nil;
        self.savedDeviceInfoForSelectiveBackup = nil;
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - 没有保存的设备信息可恢复");
    }
}

- (NSString *)createSelectiveBackupDirectory {
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    NSString *deviceBackupPath = [defaultBackupPath stringByAppendingPathComponent:self.lockedDeviceID];
    
    // 创建选择性备份子目录
    NSString *timestamp = [self generateBackupTimestamp];
    NSString *selectiveBackupDir = [NSString stringWithFormat:@"%@", timestamp];
    NSString *fullBackupPath = [deviceBackupPath stringByAppendingPathComponent:selectiveBackupDir];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    
    BOOL success = [fileManager createDirectoryAtPath:fullBackupPath
                           withIntermediateDirectories:YES
                                            attributes:nil
                                                 error:&error];
    
    if (!success) {
        NSLog(@"创建选择性备份目录失败: %@", error.localizedDescription);
        return nil;
    }
    
    // ✅ 创建选择性备份标识文件，确保能被识别
    NSString *selectiveMetadataPath = [fullBackupPath stringByAppendingPathComponent:@"selective_backup_metadata.plist"];
    NSDictionary *selectiveMetadata = @{
        @"backupType": @"selective",
        @"deviceID": self.lockedDeviceID ?: @"",
        @"deviceName": self.LockedDeviceInfo[@"officialName"] ?: @"Unknown Device",
        @"deviceType": self.LockedDeviceInfo[@"type"] ?: @"iPhone",
        @"backupDate": [NSDate date],
        @"selectedDataTypes": @(self.selectedDataTypes)
    };
    
    [selectiveMetadata writeToFile:selectiveMetadataPath atomically:YES];
    NSLog(@"已创建选择性备份标识文件: %@", selectiveMetadataPath);
    
    return fullBackupPath;
}

#pragma mark - 取消选择性备份方法

- (IBAction)cancelSelectiveBackup:(id)sender {
    NSLog(@"DeviceBackupRestore: 取消选择性备份");
    
    // 取消正在进行的备份
    [self.backupOptionTask cancelCurrentOperation];
    
    // ✅ 恢复设备信息
    [self restoreDeviceInfoAfterSelectiveBackup];
    
    // 关闭窗口
    [self.selectiveBackupWindow close];
    self.selectiveBackupWindow = nil;
    
    [self showLogsWithMessage:@"选择性备份已取消"];
}

#pragma mark - ✅ 选择性备份回调处理

- (void)updateSelectiveBackupProgress:(float)progress
                            operation:(NSString *)operation
                              current:(NSUInteger)current
                                total:(NSUInteger)total {
    
    [self.selectiveBackupProgress setDoubleValue:progress];
    
    NSString *statusText = [NSString stringWithFormat:@"%@ (%.1f%%) - %lu/%lu",
                          operation ?: @"处理中", progress, (unsigned long)current, (unsigned long)total];
    [self.selectiveBackupStatusLabel setStringValue:statusText];
    
    // 也更新主进度视图
    if (self.backupProgressViewController) {
        [self.backupProgressViewController updateProgress:progress];
    }
}

- (void)updateSelectiveBackupStatus:(SyncTaskStatus)status description:(NSString *)description {
    NSString *statusMessage = [NSString stringWithFormat:@"状态: %@", description ?: @"处理中"];
    [self.selectiveBackupStatusLabel setStringValue:statusMessage];
    
    NSString *logMessage = [NSString stringWithFormat:@"选择性备份状态更新: %@", description];
    [self showLogsWithMessage:logMessage];
}

//选择性备份完成处理方法
- (void)handleSelectiveBackupCompletion:(BOOL)success
                         completedTypes:(BackupDataType)completedTypes
                                  error:(NSError *)error {
    
    NSLog(@"DeviceBackupRestore: 选择性备份完成处理开始");
    
    // 隐藏进度指示器
    [self.selectiveBackupProgress setHidden:YES];
    
    // ✅ 关键修复：先恢复设备信息，再处理后续逻辑
    [self restoreDeviceInfoAfterSelectiveBackup];
    
    if (success) {
        NSString *successMessage = [NSString stringWithFormat:@"[SUC] 选择性备份完成，已备份 %lu 种数据类型",
                                  (unsigned long)[self countDataTypes:completedTypes]];
        [self showLogsWithMessage:successMessage];
        [self.selectiveBackupStatusLabel setStringValue:@"备份完成"];
        
        // 显示完成对话框
        [self showAlert:@"备份完成" informativeText:@"选择性备份已成功完成"];
        
        // ✅ 修复：延迟刷新备份列表，确保设备信息已恢复
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            NSLog(@"DeviceBackupRestore: 开始刷新备份列表，当前设备ID: %@", self.lockedDeviceID);
            [self.backupProgressViewController checkAndLoadExistingBackupData];
        });
        
        // 延迟关闭窗口
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self.selectiveBackupWindow close];
            self.selectiveBackupWindow = nil;
        });
        
    } else {
        NSString *errorMessage = [NSString stringWithFormat:@"[ERR] 选择性备份失败: %@",
                                error.localizedDescription ?: @"未知错误"];
        [self showLogsWithMessage:errorMessage];
        [self.selectiveBackupStatusLabel setStringValue:@"备份失败"];
        
        [self showAlert:@"备份失败" informativeText:error.localizedDescription ?: @"选择性备份过程中发生错误"];
    }
    
    NSLog(@"DeviceBackupRestore: 选择性备份完成处理结束");
}

#pragma mark - ✅ 选择性恢复功能

- (IBAction)showSelectiveRestoreOptions:(id)sender {
    NSLog(@"DeviceBackupRestore: 显示选择性恢复选项");
    
    // 验证设备连接
    if (![self validateDeviceConnection]) {
        return;
    }
    
    // 获取可用的备份
    [self showSelectiveRestoreBackupSelection];
}

- (void)showSelectiveRestoreBackupSelection {
    // 这里可以实现选择性恢复的UI
    // 1. 列出可用的备份
    // 2. 让用户选择要恢复的备份
    // 3. 显示该备份中可用的数据类型
    // 4. 让用户选择要恢复的数据类型
    
    [self showAlert:@"功能开发中" informativeText:@"选择性恢复功能正在开发中，敬请期待"];
}

#pragma mark - ✅ 诊断和调试功能

- (IBAction)diagnoseSelectiveBackupCapabilities:(id)sender {
    NSLog(@"DeviceBackupRestore: 诊断选择性备份能力");
    
    if (![self validateDeviceConnection]) {
        return;
    }
    
    [self showLogsWithMessage:@"正在诊断设备的选择性备份能力..."];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (connected) {
                [self.backupOptionTask diagnoseDeviceSyncCapabilities];
                [self showLogsWithMessage:@"设备诊断完成，请查看日志详情"];
            } else {
                NSString *errorMsg = [NSString stringWithFormat:@"[ERR] 无法连接设备进行诊断: %@",
                                    error.localizedDescription ?: @"未知错误"];
                [self showLogsWithMessage:errorMsg];
            }
        });
    });
}

#pragma mark - ✅ 便捷备份方法

- (IBAction)quickBackupContacts:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeContacts typeName:@"联系人"];
}

- (IBAction)quickBackupCalendars:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeCalendars typeName:@"日历"];
}

- (IBAction)quickBackupBookmarks:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeBookmarks typeName:@"书签"];
}

- (IBAction)quickBackupNotes:(id)sender {
    [self performQuickBackupForDataType:BackupDataTypeNotes typeName:@"备忘录"];
}

- (void)performQuickBackupForDataType:(BackupDataType)dataType typeName:(NSString *)typeName {
    if (![self validateDeviceConnection]) {
        return;
    }
    
    [self showLogsWithMessage:[NSString stringWithFormat:@"开始快速备份%@...", typeName]];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        BOOL connected = [self.backupOptionTask connectToDevice:self.lockedDeviceID error:&error];
        
        if (connected) {
            // 创建备份目录
            NSString *backupPath = [self createSelectiveBackupDirectory];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                if (backupPath) {
                    NSError *backupError = nil;
                    BOOL started = [self.backupOptionTask backupSelectedDataTypes:dataType
                                                                      toDirectory:backupPath
                                                                            error:&backupError];
                    
                    if (started) {
                        [self showLogsWithMessage:[NSString stringWithFormat:@"正在备份%@，请等待完成...", typeName]];
                    } else {
                        NSString *errorMsg = [NSString stringWithFormat:@"[ERR] %@备份启动失败: %@",
                                            typeName, backupError.localizedDescription ?: @"未知错误"];
                        [self showLogsWithMessage:errorMsg];
                    }
                } else {
                    [self showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@备份目录创建失败", typeName]];
                }
            });
        } else {
            dispatch_async(dispatch_get_main_queue(), ^{
                NSString *errorMsg = [NSString stringWithFormat:@"[ERR] %@备份连接失败: %@",
                                    typeName, error.localizedDescription ?: @"未知错误"];
                [self showLogsWithMessage:errorMsg];
            });
        }
    });
}

- (BOOL)validateDeviceConnection {
    if (!self.lockedDeviceID || self.lockedDeviceID.length == 0) {
        [self showAlert:@"设备未选择"
         informativeText:@"请先选择要备份的设备"];
        return NO;
    }
    
   // if (![self.currentDeviceMode isEqualToString:@"Normal"]) {
       // [self showAlert:@"设备状态错误"
       //  informativeText:@"设备必须处于正常模式才能进行选择性备份"];
       // return NO;
   // }
    
    return YES;
}


@end



//
//  BackupProgressViewController.m
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import "BackupProgressViewController.h"
#import "DeviceManager.h" // 引入设备管理模块
#import "DatalogsSettings.h"//日志保存路径全局
#import "LanguageManager.h" //语言
#import "CurrentHistoryController.h" //历史操作记录
#import "SidebarViewController.h"
#import "LogUtility.h" // 自定义日志函数LogWithTimestamp，自动添加时间戳
#import "LogManager.h" //全局日志区域
#import "BackupTask.h"
#import "DeviceBackupRestore.h"
#import <sqlite3.h>


@interface BackupProgressViewController ()
@property (nonatomic, strong) NSArray *backupDirectories; // 改为备份目录列表
@end

@implementation BackupProgressViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"BackupProgressViewController: viewDidLoad");
    
    // 初始化备份目录列表
    self.backupDirectories = @[];
    
    // 设置表格视图
    [self.tableView setDataSource:self];
    [self.tableView setDelegate:self];
    
    // 设置进度条
    [self.progressBar setMinValue:0.0];
    [self.progressBar setMaxValue:100.0];
    [self.progressBar setDoubleValue:0.0];
    
    // 设置文本视图
    [self.logTextView setEditable:NO];
    [self.logTextView setFont:[NSFont fontWithName:@"Menlo" size:12.0]];
    self.collectedLogs = [[NSMutableString alloc] init]; // 初始化日志缓存
    
    NSLog(@"BackupProgressViewController: 控件已初始化");
    
    //------添加全局日志start-----------
    [[LogManager sharedManager] attachLogToViewController:self];

    NSScrollView *logScrollView = [LogManager sharedManager].logScrollView;

    // 设置布局
    logScrollView.frame = NSMakeRect(0, 3, 852, 360);

    // 确保先从之前的父视图移除（避免重复添加到多个父视图）
    [logScrollView removeFromSuperview];

    // 将 logScrollView 添加到当前视图并控制其层级
    [self.view addSubview:logScrollView positioned:NSWindowBelow relativeTo:nil]; // 添加到较低层级

    //------添加全局日志end-----------
}

- (void)viewWillAppear {
    [super viewWillAppear];
    NSLog(@"BackupProgressViewController: viewWillAppear");
    
    // 确保日志区域在正确位置（如果需要的话）
    NSScrollView *logScrollView = [LogManager sharedManager].logScrollView;
    if (logScrollView.superview != self.view) {
        // 如果日志区域不在当前视图中，重新添加
        [logScrollView removeFromSuperview];
        logScrollView.frame = NSMakeRect(0, -4, 1007, 293);
        [self.view addSubview:logScrollView positioned:NSWindowBelow relativeTo:nil];
        NSLog(@"BackupProgressViewController: 重新添加日志区域");
    }
    
    // 只在表格为空时才尝试加载数据
    if (self.backupDirectories.count == 0) {
        NSLog(@"BackupProgressViewController: 表格为空，尝试加载现有备份目录");
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self checkAndLoadExistingBackupData];
        });
    }
}

- (void)viewWillDisappear {
    [super viewWillDisappear];
    NSLog(@"BackupProgressViewController: viewWillDisappear");
    // 可以选择性地在这里做一些清理，但通常不需要
}

// 便捷的日志方法
- (void)addLogMessage:(NSString *)message {
    [[LogManager sharedManager] addLogMessage:message forViewController:self];
}

- (void)clearLogs {
    [[LogManager sharedManager] clearLogForViewController:self];
}

#pragma mark - 公共方法

// 直接接收设备信息并加载备份目录
- (void)loadBackupDataForDevice:(NSString *)deviceID deviceInfo:(NSDictionary *)deviceInfo {
    NSLog(@"BackupProgressViewController: 接收到设备信息 - ID: %@, Info: %@", deviceID, deviceInfo);
    
    // ✅ 增加详细的调试信息
    if (!deviceID || deviceID.length == 0) {
        NSLog(@"BackupProgressViewController: 设备ID为空，尝试获取备份数据管理器的设备信息");
        
        // 尝试从主控制器再次获取设备信息
        DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
        NSString *fallbackDeviceID = mainController.lockedDeviceID;
        NSDictionary *fallbackDeviceInfo = mainController.LockedDeviceInfo;
        
        NSLog(@"BackupProgressViewController: 备用设备信息 - ID: %@, Info: %@", fallbackDeviceID, fallbackDeviceInfo);
        
        if (fallbackDeviceID && fallbackDeviceID.length > 0) {
            NSLog(@"BackupProgressViewController: 使用备用设备信息");
            deviceID = fallbackDeviceID;
            deviceInfo = fallbackDeviceInfo;
        } else {
            NSLog(@"BackupProgressViewController: 设备ID确实为空，无法加载备份数据");
            dispatch_async(dispatch_get_main_queue(), ^{                
                // 清空表格
                self.backupDirectories = @[];
                [self.tableView reloadData];
            });
            return;
        }
    }
    
    // 继续原有的加载逻辑...
    NSString *deviceName = deviceInfo[@"officialName"] ?: @"Unknown Device";
    NSString *deviceType = deviceInfo[@"type"] ?: @"Unknown Type";
    
    // 获取当前设备的备份基础目录路径
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    NSString *deviceBackupBasePath = [defaultBackupPath stringByAppendingPathComponent:deviceID];
    
    NSLog(@"BackupProgressViewController: 当前设备备份基础路径: %@", deviceBackupBasePath);
    
    // 显示设备信息
    dispatch_async(dispatch_get_main_queue(), ^{
        NSString *deviceMessage = [NSString stringWithFormat:@"当前设备: %@ (%@)\n", deviceName, deviceType];
        [self appendLog:deviceMessage];
    });
    
    // 只加载当前设备的备份目录
    NSMutableArray *currentDeviceBackups = [NSMutableArray array];
    [self loadCurrentDeviceBackupDirectories:deviceBackupBasePath
                                    deviceID:deviceID
                                  deviceName:deviceName
                                     toArray:currentDeviceBackups];
    
    NSLog(@"BackupProgressViewController: 当前设备备份目录数量: %lu", (unsigned long)currentDeviceBackups.count);
    
    if (currentDeviceBackups.count > 0) {
        NSLog(@"BackupProgressViewController: 找到 %lu 个当前设备的备份目录", (unsigned long)currentDeviceBackups.count);
        
        // 更新表格数据
        dispatch_async(dispatch_get_main_queue(), ^{
            self.backupDirectories = [currentDeviceBackups copy];
            [self.tableView reloadData];
            
            // ✅ 刷新完成后的附加操作
            [self onBackupListRefreshed:currentDeviceBackups.count];
            
            NSLog(@"BackupProgressViewController: 表格已重新加载，当前行数: %ld", [self.tableView numberOfRows]);
        });
    } else {
        NSLog(@"BackupProgressViewController: 当前设备没有找到备份目录");
        dispatch_async(dispatch_get_main_queue(), ^{
            self.backupDirectories = @[]; // 清空列表
            [self.tableView reloadData];
            [self appendLog:@"当前设备暂无备份数据\n"];
        });
    }
}

// 备份列表刷新完成后的回调
- (void)onBackupListRefreshed:(NSUInteger)backupCount {
    NSLog(@"BackupProgressViewController: 备份列表刷新完成，共 %lu 项", (unsigned long)backupCount);
    
    // 显示加载信息
    NSString *loadMessage = [NSString stringWithFormat:@"已刷新当前设备的 %lu 个备份目录\n", (unsigned long)backupCount];
    [self appendLog:loadMessage];
    
    // 如果有备份项，自动选中最新的
    if (backupCount > 0 && self.tableView.numberOfRows > 0) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self.tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:0] byExtendingSelection:NO];
            [self.tableView scrollRowToVisible:0];
        });
    }
}


- (IBAction)refreshBackupList:(id)sender {
    NSLog(@"BackupProgressViewController: 手动刷新备份列表");
    [self forceRefreshBackupList];
}

// 新方法：只加载当前设备的备份目录（支持时间戳子目录）
- (void)loadCurrentDeviceBackupDirectories:(NSString *)deviceBackupBasePath
                                  deviceID:(NSString *)deviceID
                                deviceName:(NSString *)deviceName
                                   toArray:(NSMutableArray *)backupDirs {
    NSLog(@"BackupProgressViewController: 开始加载当前设备备份目录: %@", deviceBackupBasePath);
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // 检查设备基础目录是否存在
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:deviceBackupBasePath isDirectory:&isDirectory] || !isDirectory) {
        NSLog(@"BackupProgressViewController: 设备备份基础目录不存在: %@", deviceBackupBasePath);
        return;
    }
    
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:deviceBackupBasePath error:&error];
    
    if (error || !contents) {
        NSLog(@"BackupProgressViewController: 无法读取设备备份目录: %@", error.localizedDescription);
        return;
    }
    
    NSLog(@"BackupProgressViewController: 在设备目录中找到 %lu 个项目", (unsigned long)contents.count);
    
    // 遍历设备目录下的所有时间戳目录
    for (NSString *item in contents) {
        NSString *itemPath = [deviceBackupBasePath stringByAppendingPathComponent:item];
        BOOL itemIsDirectory = NO;
        
        if ([fileManager fileExistsAtPath:itemPath isDirectory:&itemIsDirectory] && itemIsDirectory) {
            NSLog(@"BackupProgressViewController: 检查时间戳目录: %@", item);
            
            // 检查是否是时间戳格式的目录名（如202505271018AM）
            if ([self isTimestampDirectoryName:item]) {
                // 检查是否是有效的备份目录
                if ([self isValidBackupDirectory:itemPath]) {
                    // 获取目录信息
                    NSDictionary *dirInfo = [self getCurrentDeviceBackupDirectoryInfo:itemPath
                                                                             deviceID:deviceID
                                                                           deviceName:deviceName
                                                                        timestampDir:item];
                    if (dirInfo) {
                        [backupDirs addObject:dirInfo];
                        NSLog(@"BackupProgressViewController: 添加当前设备备份目录: %@", item);
                    }
                } else {
                    NSLog(@"BackupProgressViewController: 跳过无效的时间戳目录: %@", item);
                }
            } else {
                NSLog(@"BackupProgressViewController: 跳过非时间戳格式目录: %@", item);
            }
        }
    }
    
    // 按时间戳排序，最新的在前（根据目录名称的时间戳）
    [backupDirs sortUsingComparator:^NSComparisonResult(NSDictionary *obj1, NSDictionary *obj2) {
        NSString *timestamp1 = obj1[@"timestamp"];
        NSString *timestamp2 = obj2[@"timestamp"];
        return [timestamp2 compare:timestamp1]; // 倒序，最新的在前
    }];
    
    NSLog(@"BackupProgressViewController: 最终加载当前设备备份目录数量: %lu", (unsigned long)backupDirs.count);
}

// 检查目录名是否为时间戳格式
- (BOOL)isTimestampDirectoryName:(NSString *)dirName {
    // 检查格式：202505271018AM 或 202505271318PM
    if (dirName.length < 12) return NO;
    
    // 检查前12个字符是否都是数字
    NSString *numericPart = [dirName substringToIndex:12];
    NSCharacterSet *nonNumericSet = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
    if ([numericPart rangeOfCharacterFromSet:nonNumericSet].location != NSNotFound) {
        return NO;
    }
    
    // 检查是否以AM或PM结尾
    if (dirName.length >= 14) {
        NSString *ampmPart = [dirName substringFromIndex:12];
        if ([ampmPart isEqualToString:@"AM"] || [ampmPart isEqualToString:@"PM"]) {
            return YES;
        }
    }
    
    return NO;
}

// 获取当前设备备份目录信息
- (NSDictionary *)getCurrentDeviceBackupDirectoryInfo:(NSString *)dirPath
                                             deviceID:(NSString *)deviceID
                                           deviceName:(NSString *)deviceName
                                        timestampDir:(NSString *)timestampDir {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // 获取目录属性
    NSDictionary *dirAttributes = [fileManager attributesOfItemAtPath:dirPath error:nil];
    if (!dirAttributes) {
        return nil;
    }
    
    NSDate *modificationDate = dirAttributes[NSFileModificationDate];
    NSString *dateString = [dateFormatter stringFromDate:modificationDate];
    
    // 解析时间戳目录名获取备份时间
    NSString *backupTimeString = [self parseTimestampFromDirectoryName:timestampDir];
    if (backupTimeString) {
        dateString = [NSString stringWithFormat:@"%@", backupTimeString];
    }
    
    // 读取备份信息
    NSString *infoPath = [dirPath stringByAppendingPathComponent:@"Info.plist"];
    NSDictionary *backupInfo = [NSDictionary dictionaryWithContentsOfFile:infoPath];
    
    // 获取加密状态
    BOOL isEncrypted = NO;
    if (backupInfo) {
        isEncrypted = [backupInfo[@"IsEncrypted"] boolValue];
    }
    
    // 计算目录总大小
    unsigned long long totalSize = [self calculateDirectorySize:dirPath];
    NSString *sizeString = [self formatFileSize:totalSize];
    
    return @{
        @"backupitem": [NSString stringWithFormat:@"%@", timestampDir],
        @"backuplocation": dirPath,
        @"backupfilesize": sizeString,
        @"backupdate": dateString,
        @"backupdate_raw": modificationDate, // 用于排序
        @"backupencryptionstatus": isEncrypted ? @"Yes" : @"No",
        @"backuptype": @"Current Device",
        @"deviceid": deviceID,
        @"timestamp": timestampDir // 用于排序
    };
}

// 解析时间戳目录名获取可读的时间字符串
- (NSString *)parseTimestampFromDirectoryName:(NSString *)dirName {
    // 解析格式如 202505271018AM 或 202505271318PM
    if (dirName.length < 12) return nil;
    
    NSString *yearStr = [dirName substringWithRange:NSMakeRange(0, 4)];
    NSString *monthStr = [dirName substringWithRange:NSMakeRange(4, 2)];
    NSString *dayStr = [dirName substringWithRange:NSMakeRange(6, 2)];
    NSString *hourStr = [dirName substringWithRange:NSMakeRange(8, 2)];
    NSString *minuteStr = [dirName substringWithRange:NSMakeRange(10, 2)];
    
    NSString *ampmStr = @"";
    if (dirName.length >= 14) {
        ampmStr = [dirName substringFromIndex:12];
    }
    
    return [NSString stringWithFormat:@"%@-%@-%@ %@:%@ %@",
            yearStr, monthStr, dayStr, hourStr, minuteStr, ampmStr];
}

// ✅ 简化原有的方法，主要用于初始化时调用
- (void)checkAndLoadExistingBackupData {
    NSLog(@"BackupProgressViewController: 检查现有备份数据（通过获取主控制器信息）");
    
    // 获取当前选中的设备ID
    DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
    NSString *currentDeviceID = mainController.lockedDeviceID;
    NSDictionary *deviceInfo = mainController.LockedDeviceInfo;
    
    if (currentDeviceID && currentDeviceID.length > 0) {
        [self loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            // 即使没有选中设备，也显示所有备份目录
            [self loadBackupDataForDevice:@"" deviceInfo:@{}];
        });
    }
}

// 新方法：加载备份目录（而不是文件）
- (void)loadBackupDirectoriesFromPath:(NSString *)backupBasePath toArray:(NSMutableArray *)backupDirs currentDeviceID:(NSString *)currentDeviceID {
    NSLog(@"BackupProgressViewController: 开始从路径加载备份目录: %@", backupBasePath);
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:backupBasePath error:&error];
    
    if (error || !contents) {
        NSLog(@"BackupProgressViewController: 无法读取备份基础目录: %@", error.localizedDescription);
        return;
    }
    
    NSLog(@"BackupProgressViewController: 找到 %lu 个项目在备份目录中", (unsigned long)contents.count);
    
    // 遍历所有项目，查找备份目录
    for (NSString *item in contents) {
        NSString *itemPath = [backupBasePath stringByAppendingPathComponent:item];
        BOOL isDirectory = NO;
        
        if ([fileManager fileExistsAtPath:itemPath isDirectory:&isDirectory] && isDirectory) {
            NSLog(@"BackupProgressViewController: 检查目录: %@", item);
            
            // 检查是否是有效的备份目录
            if ([self isValidBackupDirectory:itemPath]) {
                // 获取目录信息
                NSDictionary *dirInfo = [self getBackupDirectoryInfo:itemPath deviceID:item currentDeviceID:currentDeviceID];
                if (dirInfo) {
                    [backupDirs addObject:dirInfo];
                    NSLog(@"BackupProgressViewController: 添加备份目录: %@", item);
                }
            } else {
                NSLog(@"BackupProgressViewController: 跳过无效目录: %@", item);
            }
        }
    }
    
    // 按修改时间排序，最新的在前
    [backupDirs sortUsingComparator:^NSComparisonResult(NSDictionary *obj1, NSDictionary *obj2) {
        NSDate *date1 = obj1[@"backupdate_raw"];
        NSDate *date2 = obj2[@"backupdate_raw"];
        return [date2 compare:date1];
    }];
    
    NSLog(@"BackupProgressViewController: 最终加载的备份目录数量: %lu", (unsigned long)backupDirs.count);
}


// 检查是否是有效的备份目录（支持选择性备份）
- (BOOL)isValidBackupDirectory:(NSString *)dirPath {
   
    // 检查标准备份格式
    if ([self isStandardBackupDirectory:dirPath]) {
        return YES;
    }
    
    // ✅ 新增：检查选择性备份格式
    if ([self isSelectiveBackupDirectory:dirPath]) {
        return YES;
    }
    
    return NO;
}

// 检查标准iTunes备份目录
- (BOOL)isStandardBackupDirectory:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查必要的备份文件是否存在
    NSArray *requiredFiles = @[@"Info.plist"];
    NSArray *optionalFiles = @[@"Status.plist", @"Manifest.plist", @"Manifest.db"];
    
    // 必须文件检查
    BOOL hasRequiredFiles = YES;
    for (NSString *file in requiredFiles) {
        NSString *filePath = [dirPath stringByAppendingPathComponent:file];
        if (![fileManager fileExistsAtPath:filePath]) {
            hasRequiredFiles = NO;
            break;
        }
    }
    
    if (!hasRequiredFiles) {
        return NO;
    }
    
    // 检查是否有至少一个可选文件
    BOOL hasOptionalFile = NO;
    for (NSString *file in optionalFiles) {
        NSString *filePath = [dirPath stringByAppendingPathComponent:file];
        if ([fileManager fileExistsAtPath:filePath]) {
            hasOptionalFile = YES;
            break;
        }
    }
    
    // 检查是否有哈希目录
    BOOL hasHashDirs = NO;
    for (int i = 0; i < 16; i++) {
        NSString *hashDir = [NSString stringWithFormat:@"%02x", i];
        NSString *hashDirPath = [dirPath stringByAppendingPathComponent:hashDir];
        if ([fileManager fileExistsAtPath:hashDirPath]) {
            hasHashDirs = YES;
            break;
        }
    }
    
    return hasOptionalFile || hasHashDirs;
}

// ✅ 新增：检查选择性备份目录
- (BOOL)isSelectiveBackupDirectory:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查选择性备份的特征文件/目录
    NSArray *selectiveBackupIndicators = @[
        @"Contacts",        // 联系人备份目录
        @"Calendars",       // 日历备份目录
        @"Bookmarks",       // 书签备份目录
        @"Notes",           // 备忘录备份目录
        @"Reminders",       // 提醒事项备份目录
        @"Applications",    // 应用备份目录
        @"metadata.plist",  // 选择性备份元数据文件
        @"items.plist"      // 选择性备份项目文件
    ];
    
    // 只要有其中一个特征文件/目录就认为是选择性备份
    for (NSString *indicator in selectiveBackupIndicators) {
        NSString *indicatorPath = [dirPath stringByAppendingPathComponent:indicator];
        if ([fileManager fileExistsAtPath:indicatorPath]) {
            NSLog(@"发现选择性备份特征: %@ 在 %@", indicator, [dirPath lastPathComponent]);
            return YES;
        }
    }
    
    // 检查是否有任何 .plist 文件（选择性备份可能创建的元数据文件）
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:dirPath error:&error];
    if (!error && contents) {
        for (NSString *item in contents) {
            if ([item.lowercaseString hasSuffix:@".plist"]) {
                NSLog(@"发现选择性备份plist文件: %@ 在 %@", item, [dirPath lastPathComponent]);
                return YES;
            }
        }
    }
    
    return NO;
}

// 获取备份目录信息（支持选择性备份）
- (NSDictionary *)getBackupDirectoryInfo:(NSString *)dirPath deviceID:(NSString *)deviceID currentDeviceID:(NSString *)currentDeviceID {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // 获取目录属性
    NSDictionary *dirAttributes = [fileManager attributesOfItemAtPath:dirPath error:nil];
    if (!dirAttributes) {
        return nil;
    }
    
    NSDate *modificationDate = dirAttributes[NSFileModificationDate];
    NSString *dateString = [dateFormatter stringFromDate:modificationDate];
    
    // 初始化默认值
    NSString *deviceName = @"Unknown Device";
    NSString *deviceModel = @"Unknown Model";
    BOOL isEncrypted = NO;
    NSString *backupType = @"Unknown";
    
    // ✅ 检查是否是标准备份还是选择性备份
    if ([self isStandardBackupDirectory:dirPath]) {
        // 处理标准备份
        NSString *infoPath = [dirPath stringByAppendingPathComponent:@"Info.plist"];
        NSDictionary *backupInfo = [NSDictionary dictionaryWithContentsOfFile:infoPath];
        
        if (backupInfo) {
            deviceName = backupInfo[@"Device Name"] ?: backupInfo[@"Display Name"] ?: @"Unknown Device";
            deviceModel = backupInfo[@"Product Type"] ?: @"Unknown Model";
            isEncrypted = [backupInfo[@"IsEncrypted"] boolValue];
        }
        
        backupType = @"Complete";
        
    } else if ([self isSelectiveBackupDirectory:dirPath]) {
        // ✅ 处理选择性备份
        backupType = @"Selective";
        
        // 尝试从选择性备份的元数据文件获取信息
        NSString *metadataPath = [dirPath stringByAppendingPathComponent:@"metadata.plist"];
        NSDictionary *metadata = [NSDictionary dictionaryWithContentsOfFile:metadataPath];
        
        if (metadata) {
            deviceName = metadata[@"deviceName"] ?: @"Current Device";
            deviceModel = metadata[@"deviceType"] ?: @"iPhone";
        } else {
            // 如果没有元数据文件，使用默认值表示选择性备份
            deviceName = @"Current Device";
            deviceModel = @"Selective Backup";
        }
        
        // 选择性备份通常不加密
        isEncrypted = NO;
    }
    
    // 计算目录总大小
    unsigned long long totalSize = [self calculateDirectorySize:dirPath];
    NSString *sizeString = [self formatFileSize:totalSize];
    
    // 判断是否是当前设备
    BOOL isCurrentDevice = [deviceID isEqualToString:currentDeviceID];
    NSString *statusString = isCurrentDevice ? @"Current" : @"Other";
    
    return @{
        @"backupitem": [NSString stringWithFormat:@"%@ (%@)", deviceName, deviceModel],
        @"backuplocation": dirPath,
        @"backupfilesize": sizeString,
        @"backupdate": dateString,
        @"backupdate_raw": modificationDate,
        @"backupencryptionstatus": isEncrypted ? @"Yes" : @"No",
        @"backuptype": [NSString stringWithFormat:@"%@ - %@", statusString, backupType], // 显示备份类型
        @"deviceid": deviceID
    };
}


// 计算目录总大小
- (unsigned long long)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    unsigned long long totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedLongLongValue];
        }
    }
    
    return totalSize;
}

// 格式化文件大小
- (NSString *)formatFileSize:(unsigned long long)bytes {
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    return [formatter stringFromByteCount:(long long)bytes];
}

// 修改：更新当前备份过程中的文件信息显示（如果需要的话）
- (void)updateBackupFilesList:(NSArray *)filesList {
    // 对于目录显示模式，我们可能不需要实时更新文件列表
    // 或者可以在这里更新当前正在备份的设备目录信息
    dispatch_async(dispatch_get_main_queue(), ^{
        // 可以在这里添加实时更新逻辑，比如更新当前设备的备份状态
        NSLog(@"BackupProgressViewController: 备份过程中，文件数量: %lu", (unsigned long)filesList.count);
        
        // 重新加载当前数据以反映备份进度
        [self checkAndLoadExistingBackupData];
    });
}

- (void)startBackupWithInitialLog:(NSString *)initialLog {
    NSLog(@"BackupProgressViewController: 开始备份，初始日志: %@", initialLog);
    
    // 重置进度条
    [self.progressBar setDoubleValue:0.0];
    
    // 设置初始日志
    [self.logTextView.textStorage setAttributedString:[[NSAttributedString alloc] initWithString:initialLog]];
}

- (void)updateProgress:(double)progress {
    NSLog(@"BackupProgressViewController: 更新进度: %.1f%%", progress);
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.progressBar setDoubleValue:progress];
    });
}

#pragma mark - 更新日志区域
- (void)appendLog:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        // 生成时间戳
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
        NSString *timestamp = [dateFormatter stringFromDate:[NSDate date]];

        // 手动生成带时间戳的日志
        NSString *formattedLog = [NSString stringWithFormat:@"[%@] %@", timestamp, message];

        // 获取日志显示的 NSTextView
        NSTextView *textView = (NSTextView *)[LogManager sharedManager].logScrollView.documentView;
        if (textView) {
            // ✅ 直接调用 AppendLogToTextView 追加日志（仍然是原始 message）
            AppendLogToTextView(textView, message);

            // 自动滚动到底部
            NSRange endRange = NSMakeRange(textView.string.length, 0);
            [textView scrollRangeToVisible:endRange];

            // ✅ 存入 collectedLogs，但加上时间戳，确保最终日志文件有完整格式
            [self.collectedLogs appendFormat:@"%@\n", formattedLog];
        } else {
            NSLog(@"[ERROR] Failed to access NSTextView.");
        }
    });
}

#pragma mark - 按钮动作

- (IBAction)cancelBackup:(id)sender {
    NSLog(@"BackupProgressViewController: 取消备份按钮被点击");
    if ([self.delegate respondsToSelector:@selector(cancelBackup)]) {
        [self.delegate cancelBackup];
    }
}

#pragma mark - NSTableViewDataSource

- (NSInteger)numberOfRowsInTableView:(NSTableView *)tableView {
    // 返回备份目录列表的行数
    return self.backupDirectories.count;
}

// 修改 viewForTableColumn 方法以显示目录信息
- (NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row {
    if (row < self.backupDirectories.count) {
        NSDictionary *dirInfo = self.backupDirectories[row];
        
        NSTableCellView *cellView = [tableView makeViewWithIdentifier:tableColumn.identifier owner:self];
        if (!cellView) {
            cellView = [[NSTableCellView alloc] init];
            cellView.identifier = tableColumn.identifier;
            
            NSTextField *textField = [[NSTextField alloc] init];
            textField.bordered = NO;
            textField.backgroundColor = [NSColor clearColor];
            textField.editable = NO;
            textField.font = [NSFont systemFontOfSize:11.0];
            [cellView addSubview:textField];
            cellView.textField = textField;
            
            // 设置约束
            textField.translatesAutoresizingMaskIntoConstraints = NO;
            [NSLayoutConstraint activateConstraints:@[
                [textField.leadingAnchor constraintEqualToAnchor:cellView.leadingAnchor constant:6],
                [textField.trailingAnchor constraintEqualToAnchor:cellView.trailingAnchor constant:-6],
                [textField.centerYAnchor constraintEqualToAnchor:cellView.centerYAnchor]
            ]];
        }
        
        // 根据列标识符设置内容
        if ([tableColumn.identifier isEqualToString:@"backupitem"]) {
            NSString *displayName = dirInfo[@"backupitem"] ?: @"";
            // 所有显示的都是当前设备的备份，用蓝色显示
           // cellView.textField.textColor = [NSColor systemBlueColor];
            cellView.textField.stringValue = displayName;
        } else if ([tableColumn.identifier isEqualToString:@"backuplocation"]) {
            cellView.textField.stringValue = dirInfo[@"backuplocation"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupfilesize"]) {
            cellView.textField.stringValue = dirInfo[@"backupfilesize"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupdate"]) {
            cellView.textField.stringValue = dirInfo[@"backupdate"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupencryptionstatus"]) {
            cellView.textField.stringValue = dirInfo[@"backupencryptionstatus"] ?: @"";
        }
        
        return cellView;
    }
    
    return nil;
}

- (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row {
    return 30.0; // 设置行高
}

#pragma mark - 表格操作辅助方法

- (void)scrollToNewestBackup {
    NSLog(@"BackupProgressViewController: 滚动到最新备份项");
    
    if (self.backupDirectories.count > 0) {
        // 滚动到第一行（最新的备份）
        [self.tableView scrollRowToVisible:0];
        
        // 可选：选中第一行
        [self.tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:0] byExtendingSelection:NO];
        
        NSLog(@"BackupProgressViewController: 已滚动并选中最新备份项");
    } else {
        NSLog(@"BackupProgressViewController: 没有备份项可滚动");
    }
}
// 添加一个强制刷新方法
- (void)forceRefreshBackupList {
    NSLog(@"BackupProgressViewController: 强制刷新备份列表");
    
    // 获取主控制器信息
    DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
    NSString *currentDeviceID = mainController.lockedDeviceID;
    NSDictionary *deviceInfo = mainController.LockedDeviceInfo;
    
    if (currentDeviceID && currentDeviceID.length > 0) {
        [self loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
        
        // 添加刷新日志
        dispatch_async(dispatch_get_main_queue(), ^{
            [self appendLog:@"备份列表已刷新\n"];
        });
    }
}

// 保持原有的方法用于兼容性
- (id)tableView:(NSTableView *)tableView objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row {
    if (row >= self.backupDirectories.count) {
        NSLog(@"BackupProgressViewController: 请求的行 %ld 超出范围", row);
        return nil;
    }
    
    NSDictionary *item = self.backupDirectories[row];
    NSString *identifier = tableColumn.identifier;
    id value = item[identifier];
    NSLog(@"BackupProgressViewController: 表格行 %ld, 列 %@, 值: %@", row, identifier, value);
    return value;
}

@end




------------操作日志---------------

2025-05-28 16:03:17.902377+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 🔧 启动修复版选择性备份
2025-05-28 16:03:17.903386+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:17] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:18.904491+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Connecting to device: 00008030-0008352034B9802E
2025-05-28 16:03:18.904790+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:18.905036+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Status changed: 0 -> 1
2025-05-28 16:03:18.905810+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Device connection established
2025-05-28 16:03:18.962105+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:18] [BackupOptionTask] Lockdown connection established
2025-05-28 16:03:19.061097+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:19] [BackupOptionTask] Successfully connected to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.061559+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:03:19] [BackupOptionTask] Status changed: 1 -> 0
2025-05-28 16:03:19.062325+0800 MFCTOOL.bin[53398:13803419] [2025-05-28 16:03:19] [BackupOptionTask] Connecting to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.062738+0800 MFCTOOL.bin[53398:13803419] [2025-05-28 16:03:19] [BackupOptionTask] Already connected to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.068042+0800 MFCTOOL.bin[53398:13803430] === 确保设备连接和初始化 ===
2025-05-28 16:03:19.068193+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:19.576103+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Connecting to device: 00008030-0008352034B9802E
2025-05-28 16:03:19.577190+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Safe disconnecting device
2025-05-28 16:03:19.577829+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Status changed: 0 -> 1
2025-05-28 16:03:19.580100+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Device connection established
2025-05-28 16:03:19.632064+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:19] [BackupOptionTask] Lockdown connection established
2025-05-28 16:03:59.717394+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:59] [BackupOptionTask] MobileSync client creation failed (attempt 1): -5
2025-05-28 16:03:59.718342+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:03:59] [BackupOptionTask] Retrying in 2 seconds...
2025-05-28 16:04:01.770246+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] Successfully connected to device: 00008030-0008352034B9802E
2025-05-28 16:04:01.771017+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] Status changed: 1 -> 0
2025-05-28 16:04:01.771105+0800 MFCTOOL.bin[53398:13803430] ✅ 设备连接成功
2025-05-28 16:04:01.771484+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] === Device Sync Capabilities Diagnosis ===
2025-05-28 16:04:01.771855+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] 📱 Device UDID: 00008030-0008352034B9802E
2025-05-28 16:04:01.807599+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ✅ Contacts (com.apple.Contacts)
2025-05-28 16:04:01.864026+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ✅ Calendars (com.apple.Calendars)
2025-05-28 16:04:01.869189+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Bookmarks (com.apple.WebBookmarks)
2025-05-28 16:04:01.869739+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Notes (com.apple.Notes)
2025-05-28 16:04:01.870022+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Reminders (com.apple.Reminders)
2025-05-28 16:04:01.870272+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Applications (com.apple.MobileApplication)
2025-05-28 16:04:01.870521+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Configuration (com.apple.SystemConfiguration)
2025-05-28 16:04:01.870760+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Keychain (com.apple.Keychain)
2025-05-28 16:04:01.871053+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Voice Memos (com.apple.VoiceMemos)
2025-05-28 16:04:01.871629+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] ❌ Wallpaper (com.apple.Wallpaper)
2025-05-28 16:04:01.877236+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] 📊 Total: 2/10 data types supported
2025-05-28 16:04:01.877495+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:01] [BackupOptionTask] === End Diagnosis ===
2025-05-28 16:04:01.877550+0800 MFCTOOL.bin[53398:13803430] ✅ 设备连接和初始化完成
2025-05-28 16:04:01.877634+0800 MFCTOOL.bin[53398:13803430] === 🔧 开始修复版设备真实数据扫描 ===
2025-05-28 16:04:02.484061+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:02] [BackupOptionTask] Getting supported data types with enhanced stability
2025-05-28 16:04:02.487403+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:02] [BackupOptionTask] Connection quality verified
2025-05-28 16:04:02.728539+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:02] [BackupOptionTask] ✅ Supported data type: Contacts
2025-05-28 16:04:03.091440+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:03] [BackupOptionTask] ✅ Supported data type: Calendars
2025-05-28 16:04:05.547565+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 📊 Final result: 2/10 data types supported
2025-05-28 16:04:05.547833+0800 MFCTOOL.bin[53398:13803430] ✅ 设备支持的数据类型掩码: 3
2025-05-28 16:04:05.547930+0800 MFCTOOL.bin[53398:13803430] 🔍 正在获取 Contacts 的真实数据...
2025-05-28 16:04:05.548009+0800 MFCTOOL.bin[53398:13803430] 增强方法获取 Contacts 的真实数据
2025-05-28 16:04:05.548828+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] Getting data items for type: Contacts
2025-05-28 16:04:05.549504+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 获取简化数据项 - 类型: Contacts, 同步类: com.apple.Contacts
2025-05-28 16:04:05.550031+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 跳过重复支持检查，直接获取 com.apple.Contacts 数据
2025-05-28 16:04:05.550565+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 🔧 使用修复版获取 com.apple.Contacts 数据
2025-05-28 16:04:05.555555+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 📱 设备名称:
2025-05-28 16:04:05.556812+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 📱 iOS版本: 18.4
2025-05-28 16:04:05.557203+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 💡 iOS 15+设备，数据格式可能有变化
2025-05-28 16:04:05.559233+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 📱 设备型号: iPhone12,3
2025-05-28 16:04:05.559559+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:05] [BackupOptionTask] 🔄 重新建立 MobileSync 连接以确保数据获取稳定性
2025-05-28 16:04:43.160945+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:43] [BackupOptionTask] MobileSync client creation failed (attempt 1): -5
2025-05-28 16:04:43.161855+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:43] [BackupOptionTask] Retrying in 2 seconds...
2025-05-28 16:04:45.245859+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ✅ MobileSync 连接已重新建立
2025-05-28 16:04:45.246490+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] 🔧 使用干净连接启动同步会话: com.apple.Contacts
2025-05-28 16:04:45.278015+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ✅ com.apple.Contacts 同步会话启动成功（干净连接）
2025-05-28 16:04:45.278828+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ✅ 成功请求 com.apple.Contacts 的所有记录
2025-05-28 16:04:45.285476+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] 📦 mobilesync_receive_changes 返回状态: 0 (批次 1)
2025-05-28 16:04:45.285871+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] 📦 处理 com.apple.Contacts 第 1 批数据
2025-05-28 16:04:45.286284+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] 📊 接收到的数据类型: DICT (5)
2025-05-28 16:04:45.286563+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] 📋 com.apple.Contacts 返回字典数据，尝试解析
2025-05-28 16:04:45.286995+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] 📊 字典包含 1 个键值对
2025-05-28 16:04:45.287305+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] 💡 尝试将 com.apple.Contacts 字典作为数据项处理
2025-05-28 16:04:45.287953+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ✅ 成功创建 com.apple.Contacts 数据项: Contacts Item 1
2025-05-28 16:04:45.288735+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:04:45] [BackupOptionTask] ✅ 从第 1 批获取到 1 项数据
2025-05-28 16:05:15.395590+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 📦 mobilesync_receive_changes 返回状态: -5 (批次 2)
2025-05-28 16:05:15.396432+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ⏰ com.apple.Contacts 接收超时 (第 1 次，共 2 次)
2025-05-28 16:05:15.396993+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 💡 com.apple.Contacts 已获取到数据，超时可能是正常结束
2025-05-28 16:05:15.397364+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 📊 com.apple.Contacts 数据接收完成: 1 批次, 1 项
2025-05-28 16:05:15.411306+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ✅ com.apple.Contacts 同步会话已结束
2025-05-28 16:05:15.411665+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 📊 com.apple.Contacts 最终获取到 1 项真实数据（干净连接）
2025-05-28 16:05:15.411941+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] ✅ 成功获取 com.apple.Contacts 数据: 1 项
2025-05-28 16:05:15.412199+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] Retrieved 1 data items
2025-05-28 16:05:15.412252+0800 MFCTOOL.bin[53398:13803430] ✅ 第 1 次尝试成功获取 Contacts 数据: 1 项
2025-05-28 16:05:15.412380+0800 MFCTOOL.bin[53398:13803430] ✅ Contacts 获取成功: 1 项
2025-05-28 16:05:15.717510+0800 MFCTOOL.bin[53398:13803430] 🔍 正在获取 Calendars 的真实数据...
2025-05-28 16:05:15.717787+0800 MFCTOOL.bin[53398:13803430] 增强方法获取 Calendars 的真实数据
2025-05-28 16:05:15.718701+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] Getting data items for type: Calendars
2025-05-28 16:05:15.719467+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 获取简化数据项 - 类型: Calendars, 同步类: com.apple.Calendars
2025-05-28 16:05:15.719998+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 跳过重复支持检查，直接获取 com.apple.Calendars 数据
2025-05-28 16:05:15.720503+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 🔧 使用修复版获取 com.apple.Calendars 数据
2025-05-28 16:05:15.724549+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 📱 设备名称:
2025-05-28 16:05:15.726989+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 📱 iOS版本: 18.4
2025-05-28 16:05:15.727514+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 💡 iOS 15+设备，数据格式可能有变化
2025-05-28 16:05:15.731166+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 📱 设备型号: iPhone12,3
2025-05-28 16:05:15.731436+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:15] [BackupOptionTask] 🔄 重新建立 MobileSync 连接以确保数据获取稳定性
2025-05-28 16:05:16.338705+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ✅ MobileSync 连接已重新建立
2025-05-28 16:05:16.339317+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] 🔧 使用干净连接启动同步会话: com.apple.Calendars
2025-05-28 16:05:16.369740+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ✅ com.apple.Calendars 同步会话启动成功（干净连接）
2025-05-28 16:05:16.370293+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ✅ 成功请求 com.apple.Calendars 的所有记录
2025-05-28 16:05:16.376168+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] 📦 mobilesync_receive_changes 返回状态: 0 (批次 1)
2025-05-28 16:05:16.376559+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] 📦 处理 com.apple.Calendars 第 1 批数据
2025-05-28 16:05:16.376875+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] 📊 接收到的数据类型: DICT (5)
2025-05-28 16:05:16.377178+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] 📋 com.apple.Calendars 返回字典数据，尝试解析
2025-05-28 16:05:16.377478+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] 📊 字典包含 1 个键值对
2025-05-28 16:05:16.377949+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] 💡 尝试将 com.apple.Calendars 字典作为数据项处理
2025-05-28 16:05:16.378265+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ✅ 成功创建 com.apple.Calendars 数据项: Calendars Item 1
2025-05-28 16:05:16.378503+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:16] [BackupOptionTask] ✅ 从第 1 批获取到 1 项数据
2025-05-28 16:05:46.485210+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] 📦 mobilesync_receive_changes 返回状态: -5 (批次 2)
2025-05-28 16:05:46.486091+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] ⏰ com.apple.Calendars 接收超时 (第 1 次，共 2 次)
2025-05-28 16:05:46.486650+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] 💡 com.apple.Calendars 已获取到数据，超时可能是正常结束
2025-05-28 16:05:46.487018+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] 📊 com.apple.Calendars 数据接收完成: 1 批次, 1 项
2025-05-28 16:05:46.505544+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] ✅ com.apple.Calendars 同步会话已结束
2025-05-28 16:05:46.505921+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] 📊 com.apple.Calendars 最终获取到 1 项真实数据（干净连接）
2025-05-28 16:05:46.506186+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] ✅ 成功获取 com.apple.Calendars 数据: 1 项
2025-05-28 16:05:46.506435+0800 MFCTOOL.bin[53398:13803430] [2025-05-28 16:05:46] [BackupOptionTask] Retrieved 1 data items
2025-05-28 16:05:46.506489+0800 MFCTOOL.bin[53398:13803430] ✅ 第 1 次尝试成功获取 Calendars 数据: 1 项
2025-05-28 16:05:46.506593+0800 MFCTOOL.bin[53398:13803430] ✅ Calendars 获取成功: 1 项
2025-05-28 16:05:46.811749+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Bookmarks
2025-05-28 16:05:46.812030+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Notes
2025-05-28 16:05:46.812109+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Reminders
2025-05-28 16:05:46.812182+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Applications
2025-05-28 16:05:46.812250+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Configuration
2025-05-28 16:05:46.812325+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Keychain
2025-05-28 16:05:46.812391+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Voice Memos
2025-05-28 16:05:46.812457+0800 MFCTOOL.bin[53398:13803430] ⏭️ 跳过不支持的数据类型: Wallpaper
2025-05-28 16:05:46.812529+0800 MFCTOOL.bin[53398:13803430] === 🔧 修复版数据扫描完成，共处理 2 种数据类型 ===
2025-05-28 16:05:46.812706+0800 MFCTOOL.bin[53398:13803416] === 真实设备数据获取结果 ===
2025-05-28 16:05:46.812834+0800 MFCTOOL.bin[53398:13803416] === 结果记录完成 ===
2025-05-28 16:05:46.813069+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 创建增强的选择性备份窗口
2025-05-28 16:05:46.842300+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 增强的选择性备份窗口已显示
2025-05-28 16:05:50.285009+0800 MFCTOOL.bin[53398:13803416] 已选择所有可用的数据类型
2025-05-28 16:05:51.925333+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 开始选择性备份
2025-05-28 16:05:51.925590+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 保存选择性备份前的设备信息
2025-05-28 16:05:51.925753+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 已保存设备信息 - ID: 00008030-0008352034B9802E, Info: {
    mode = Normal;
    officialName = "iPhone 11 Pro";
    type = "iPhone12,3";
    uniqueKey = "00008030-0008352034B9802E";
}
2025-05-28 16:05:51.927010+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 生成备份时间戳: 202505281605PM
2025-05-28 16:05:51.928544+0800 MFCTOOL.bin[53398:13803416] 已创建选择性备份标识文件: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM/selective_backup_metadata.plist
2025-05-28 16:05:51.929031+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Backing up selected data types to: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM
2025-05-28 16:05:51.929368+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Starting selective sync for types: 3, direction: 0
2025-05-28 16:05:51.929679+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Status changed: 0 -> 2
2025-05-28 16:05:51.930098+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Performing selective sync internally
2025-05-28 16:05:51.936062+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Status changed: 2 -> 3
2025-05-28 16:05:51.936388+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 0.00% - Starting selective sync (0/100)
2025-05-28 16:05:51.936657+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 0.00% - Syncing Contacts (0/2)
2025-05-28 16:05:51.936912+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Performing sync for data type: Contacts, direction: 0
2025-05-28 16:05:51.937166+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Backing up data type: Contacts to path: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM
2025-05-28 16:05:51.937407+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Getting data items for type: Contacts
2025-05-28 16:05:51.937668+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Returning cached data items: 1
2025-05-28 16:05:51.938542+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 更新进度: 0.0%
2025-05-28 16:05:51.938629+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 更新进度: 0.0%
2025-05-28 16:05:51.939258+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Successfully backed up 1 items of type: Contacts
2025-05-28 16:05:51.939622+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 50.00% - Syncing Calendars (1/2)
2025-05-28 16:05:51.939942+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Performing sync for data type: Calendars, direction: 0
2025-05-28 16:05:51.940319+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Backing up data type: Calendars to path: /Users/monterey/Library/Application Support/com.mfcbox.imfcdata/backups/00008030-0008352034B9802E/202505281605PM
2025-05-28 16:05:51.940589+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Getting data items for type: Calendars
2025-05-28 16:05:51.940835+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Returning cached data items: 1
2025-05-28 16:05:51.942280+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Successfully backed up 1 items of type: Calendars
2025-05-28 16:05:51.942582+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Progress: 100.00% - Selective sync completed (2/2)
2025-05-28 16:05:51.942837+0800 MFCTOOL.bin[53398:13804822] [2025-05-28 16:05:51] [BackupOptionTask] Selective sync completed successfully
2025-05-28 16:05:51.951924+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 更新进度: 50.0%
2025-05-28 16:05:51.952253+0800 MFCTOOL.bin[53398:13803416] [2025-05-28 16:05:51] [BackupOptionTask] Status changed: 3 -> 4
2025-05-28 16:05:51.952518+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 更新进度: 100.0%
2025-05-28 16:05:51.952777+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 选择性备份完成处理开始
2025-05-28 16:05:51.952839+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 恢复选择性备份后的设备信息
2025-05-28 16:05:51.952872+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 已恢复设备信息 - ID: 00008030-0008352034B9802E
2025-05-28 16:05:51.952926+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 显示警告: 备份完成 - 选择性备份已成功完成
2025-05-28 16:05:52.250695+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 选择性备份完成处理结束
2025-05-28 16:05:52.796761+0800 MFCTOOL.bin[53398:13803416] DeviceBackupRestore: 开始刷新备份列表，当前设备ID: 00008030-0008352034B9802E
2025-05-28 16:05:52.796926+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 检查现有备份数据（通过获取主控制器信息）
2025-05-28 16:05:52.797000+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 接收到设备信息 - ID: , Info: {
}
2025-05-28 16:05:52.797038+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 设备ID为空，尝试获取备份数据管理器的设备信息
2025-05-28 16:05:52.797077+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 备用设备信息 - ID: (null), Info: (null)
2025-05-28 16:05:52.797111+0800 MFCTOOL.bin[53398:13803416] BackupProgressViewController: 设备ID确实为空，无法加载备份数据





----------奔溃日志----------------

-------------------------------------
Translated Report (Full Report Below)
-------------------------------------

Process:               MFCTOOL.bin [53398]
Path:                  /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/MacOS/MFCTOOL.bin
Identifier:            MFCTOOL.bin
Version:               ???
Code Type:             ARM-64 (Native)
Parent Process:        launchd [1]
User ID:               501

Date/Time:             2025-05-28 16:05:54.4650 +0800
OS Version:            macOS 12.7.2 (21G1974)
Report Version:        12
Anonymous UUID:        57B94FB4-6A44-571C-3243-401813F68875


Time Awake Since Boot: 1900000 seconds

System Integrity Protection: disabled

Crashed Thread:        0  Dispatch queue: com.apple.main-thread

Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       KERN_INVALID_ADDRESS at 0x0000000000000020
Exception Codes:       0x0000000000000001, 0x0000000000000020
Exception Note:        EXC_CORPSE_NOTIFY

Termination Reason:    Namespace SIGNAL, Code 11 Segmentation fault: 11
Terminating Process:   exc handler [53398]

VM Region Info: 0x20 is not in any region.  Bytes before following region: 105553518919648
      REGION TYPE                    START - END         [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL
      UNUSED SPACE AT START
--->  
      MALLOC_NANO (reserved)   600018000000-600020000000 [128.0M] rw-/rwx SM=NUL  ...(unallocated)

Thread 0 Crashed::  Dispatch queue: com.apple.main-thread
0   libobjc.A.dylib                        0x18bae8540 objc_release + 16
1   libobjc.A.dylib                        0x18baecd44 AutoreleasePoolPage::releaseUntil(objc_object**) + 196
2   libobjc.A.dylib                        0x18bae96a4 objc_autoreleasePoolPop + 212
3   CoreFoundation                         0x18bcea12c _CFAutoreleasePoolPop + 32
4   CoreFoundation                         0x18be064d4 __CFRunLoopPerCalloutARPEnd + 48
5   CoreFoundation                         0x18bd2bb7c __CFRunLoopRun + 2600
6   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
7   HIToolbox                              0x194970338 RunCurrentEventLoopInMode + 292
8   HIToolbox                              0x1949700b4 ReceiveNextEventCommon + 564
9   HIToolbox                              0x19496fe68 _BlockUntilNextEventMatchingListInModeWithFilter + 72
10  AppKit                                 0x18e8934b8 _DPSNextEvent + 860
11  AppKit                                 0x18e891db0 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1328
12  AppKit                                 0x18e883f7c -[NSApplication run] + 596
13  AppKit                                 0x18e855698 NSApplicationMain + 1132
14  MFCTOOL.bin                            0x102dc4c14 main + 384 (main.m:300)
15  dyld                                   0x1034d108c start + 520

Thread 1::  Dispatch queue: com.apple.root.default-qos
0   libsystem_kernel.dylib                 0x18bc22890 mach_msg_trap + 8
1   libsystem_kernel.dylib                 0x18bc22d00 mach_msg + 76
2   CoreFoundation                         0x18bd2d140 __CFRunLoopServiceMachPort + 372
3   CoreFoundation                         0x18bd2b5f0 __CFRunLoopRun + 1180
4   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
5   CoreFoundation                         0x18bdb7bd8 CFRunLoopRun + 64
6   MFCTOOL.bin                            0x102e4b364 __51-[DeviceManager dfu_recovery_device_event_callback]_block_invoke + 452 (DeviceManager.m:5798)
7   libdispatch.dylib                      0x18ba9a5f0 _dispatch_call_block_and_release + 32
8   libdispatch.dylib                      0x18ba9c1b4 _dispatch_client_callout + 20
9   libdispatch.dylib                      0x18ba9f2c8 _dispatch_queue_override_invoke + 784
10  libdispatch.dylib                      0x18baad8e8 _dispatch_root_queue_drain + 396
11  libdispatch.dylib                      0x18baae104 _dispatch_worker_thread2 + 164
12  libsystem_pthread.dylib                0x18bc5c324 _pthread_wqthread + 228
13  libsystem_pthread.dylib                0x18bc5b080 start_wqthread + 8

Thread 2:
0   libsystem_kernel.dylib                 0x18bc2ae90 poll + 8
1   libimfccoreextra.dylib                 0x103a27998 socket_check_fd + 428
2   libimfccoreextra.dylib                 0x103a27c90 socket_receive_timeout + 52
3   libimfcusb.dylib                       0x1038df868 receive_packet + 108
4   libimfcusb.dylib                       0x1038e164c get_next_event + 68
5   libimfcusb.dylib                       0x1038de714 device_monitor + 104
6   libsystem_pthread.dylib                0x18bc6026c _pthread_start + 148
7   libsystem_pthread.dylib                0x18bc5b08c thread_start + 8

Thread 3:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 4:: com.apple.NSEventThread
0   libsystem_kernel.dylib                 0x18bc22890 mach_msg_trap + 8
1   libsystem_kernel.dylib                 0x18bc22d00 mach_msg + 76
2   CoreFoundation                         0x18bd2d140 __CFRunLoopServiceMachPort + 372
3   CoreFoundation                         0x18bd2b5f0 __CFRunLoopRun + 1180
4   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
5   AppKit                                 0x18ea0009c _NSEventThread + 196
6   libsystem_pthread.dylib                0x18bc6026c _pthread_start + 148
7   libsystem_pthread.dylib                0x18bc5b08c thread_start + 8

Thread 5:: com.apple.NSURLConnectionLoader
0   libsystem_kernel.dylib                 0x18bc22890 mach_msg_trap + 8
1   libsystem_kernel.dylib                 0x18bc22d00 mach_msg + 76
2   CoreFoundation                         0x18bd2d140 __CFRunLoopServiceMachPort + 372
3   CoreFoundation                         0x18bd2b5f0 __CFRunLoopRun + 1180
4   CoreFoundation                         0x18bd2a9b4 CFRunLoopRunSpecific + 600
5   CFNetwork                              0x190b22738 0x1908b8000 + 2533176
6   Foundation                             0x18cc0959c __NSThread__start__ + 808
7   libsystem_pthread.dylib                0x18bc6026c _pthread_start + 148
8   libsystem_pthread.dylib                0x18bc5b08c thread_start + 8

Thread 6:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 7:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 8:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 9:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 10:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 11:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0

Thread 12:
0   libsystem_pthread.dylib                0x18bc5b078 start_wqthread + 0


Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x00000001041159d0   x1: 0x0000600000dfa520   x2: 0x0000000000000002   x3: 0x000000018ba6f04c
    x4: 0x0000000000000001   x5: 0x0000000000000034   x6: 0x0000000000000000   x7: 0x0000000000000000
    x8: 0x2000000000000000   x9: 0x0000000000000000  x10: 0x08000001e46ada85  x11: 0x09000001e46ada85
   x12: 0x00000000000000c7  x13: 0x00000000fe4680cc  x14: 0x00000000fe668800  x15: 0x00000000000000d1
   x16: 0x000000018bae8530  x17: 0x00000001e5d991f8  x18: 0x0000000000000000  x19: 0x0000000128815000
   x20: 0x0000000128815048  x21: 0x00000001041159d0  x22: 0x00000000a1a1a1a1  x23: 0x0000000103544660
   x24: 0xa3a3a3a3a3a3a3a3  x25: 0x0000000000000001  x26: 0x0000000000000000  x27: 0x000000016d0bdc60
   x28: 0x0000000000000000   fp: 0x000000016d0bdad0   lr: 0x000000018baecd44
    sp: 0x000000016d0bda90   pc: 0x000000018bae8540 cpsr: 0x20001000
   far: 0x0000000000000020  esr: 0x92000006 (Data Abort) byte read Translation fault

Binary Images:
       0x18badf000 -        0x18bb1cfff libobjc.A.dylib (*) <44d5d68a-ad18-33b8-adea-eb65b4dc906c> /usr/lib/libobjc.A.dylib
       0x18bca8000 -        0x18c1eefff com.apple.CoreFoundation (6.9) <07e05b49-8c3c-354e-89a7-cc7994572dfe> /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
       0x19493e000 -        0x194c71fff com.apple.HIToolbox (2.1.1) <07987381-b579-3f72-8ba8-97fa5b5a3352> /System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/HIToolbox
       0x18e852000 -        0x18f70afff com.apple.AppKit (6.9) <2f9d63e8-f87c-3348-b5c5-39de32463324> /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit
       0x102d40000 -        0x102f63fff MFCTOOL.bin (*) <f0b329ab-7294-3ece-9e13-ec1e22473c83> /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/MacOS/MFCTOOL.bin
       0x1034cc000 -        0x10352bfff dyld (*) <0a55d424-2537-3f9b-ada1-ef612d185def> /usr/lib/dyld
       0x18bc21000 -        0x18bc58fff libsystem_kernel.dylib (*) <6e9cd1b1-2daa-3338-a85a-965721bcebdc> /usr/lib/system/libsystem_kernel.dylib
       0x18ba98000 -        0x18badefff libdispatch.dylib (*) <26532eb9-1697-3bcb-aa36-f07a3405770a> /usr/lib/system/libdispatch.dylib
       0x18bc59000 -        0x18bc65fff libsystem_pthread.dylib (*) <569fc817-bb09-3ef2-8b18-af7f7bd615ec> /usr/lib/system/libsystem_pthread.dylib
       0x103a24000 -        0x103a33fff libimfccoreextra.dylib (*) <f4558a88-ccf6-3de5-92cf-937c11037767> /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/Frameworks/libimfccoreextra.dylib
       0x1038dc000 -        0x1038e3fff libimfcusb.dylib (*) <19108f9b-0fcc-3b50-ac83-8fd75d2e78ea> /Users/USER/Library/Developer/Xcode/DerivedData/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp/Build/Products/Debug/MFCTOOL.app/Contents/Frameworks/libimfcusb.dylib
       0x1908b8000 -        0x190d6bfff com.apple.CFNetwork (1335.5) <46dc101d-2215-38ff-b769-f08335df88fc> /System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork
       0x18cbad000 -        0x18cf9efff com.apple.Foundation (6.9) <ed1a7ccd-78c8-37a7-a4fe-1e5051fcf967> /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
               0x0 - 0xffffffffffffffff ??? (*) <00000000-0000-0000-0000-000000000000> ???

External Modification Summary:
  Calls made by other processes targeting this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by all processes on this machine:
    task_for_pid: 4
    thread_create: 0
    thread_set_state: 0

VM Region Summary:
ReadOnly portion of Libraries: Total=1.1G resident=0K(0%) swapped_out_or_unallocated=1.1G(100%)
Writable regions: Total=1.6G written=0K(0%) resident=0K(0%) swapped_out=0K(0%) unallocated=1.6G(100%)

                                VIRTUAL   REGION 
REGION TYPE                        SIZE    COUNT (non-coalesced) 
===========                     =======  ======= 
Accelerate framework              1536K       12 
Activity Tracing                   256K        1 
CG backing stores                  768K        4 
CG image                          1088K       60 
ColorSync                          640K       28 
CoreAnimation                     19.0M      284 
CoreGraphics                        32K        2 
CoreImage                           96K        6 
CoreUI image data                 3904K       54 
Foundation                          48K        2 
Image IO                          1712K       11 
Kernel Alloc Once                   32K        1 
MALLOC                           294.5M       62 
MALLOC guard page                  288K       16 
MALLOC_MEDIUM (reserved)         960.0M        8         reserved VM address space (unallocated)
MALLOC_NANO (reserved)           384.0M        1         reserved VM address space (unallocated)
SQLite page cache                  256K        4 
STACK GUARD                       56.2M       13 
Stack                             14.4M       13 
VM_ALLOCATE                        272K       15 
__AUTH                            2494K      285 
__AUTH_CONST                      19.5M      470 
__CTF                               756        1 
__DATA                            15.4M      490 
__DATA_CONST                      18.4M      503 
__DATA_DIRTY                      1706K      200 
__FONT_DATA                          4K        1 
__LINKEDIT                       582.0M       33 
__OBJC_CONST                      3323K      257 
__OBJC_RO                         83.0M        1 
__OBJC_RW                         3168K        1 
__TEXT                           521.9M      522 
__UNICODE                          592K        1 
dyld private memory               1024K        1 
libnetwork                        1152K       16 
mapped file                      499.1M       65 
shared memory                      848K       12 
===========                     =======  ======= 
TOTAL                              3.4G     3456 
TOTAL, minus reserved VM space     2.1G     3456 



-----------
Full Report
-----------

{"app_name":"MFCTOOL.bin","timestamp":"2025-05-28 16:05:54.00 +0800","app_version":"","slice_uuid":"f0b329ab-7294-3ece-9e13-ec1e22473c83","build_version":"","platform":1,"share_with_app_devs":0,"is_first_party":1,"bug_type":"309","os_version":"macOS 12.7.2 (21G1974)","incident_id":"0596E158-05EA-4280-B1AA-F8B802B3B621","name":"MFCTOOL.bin"}
{
  "uptime" : 1900000,
  "procLaunch" : "2025-05-28 16:03:02.1275 +0800",
  "procRole" : "Foreground",
  "version" : 2,
  "userID" : 501,
  "deployVersion" : 210,
  "modelCode" : "Macmini9,1",
  "procStartAbsTime" : 47250022846578,
  "coalitionID" : 95803,
  "osVersion" : {
    "train" : "macOS 12.7.2",
    "build" : "21G1974",
    "releaseType" : "User"
  },
  "captureTime" : "2025-05-28 16:05:54.4650 +0800",
  "incident" : "0596E158-05EA-4280-B1AA-F8B802B3B621",
  "bug_type" : "309",
  "pid" : 53398,
  "procExitAbsTime" : 47254158396025,
  "translated" : false,
  "cpuType" : "ARM-64",
  "procName" : "MFCTOOL.bin",
  "procPath" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/MacOS\/MFCTOOL.bin",
  "parentProc" : "launchd",
  "parentPid" : 1,
  "coalitionName" : "com.apple.mfcbox",
  "crashReporterKey" : "57B94FB4-6A44-571C-3243-401813F68875",
  "sip" : "disabled",
  "vmRegionInfo" : "0x20 is not in any region.  Bytes before following region: 105553518919648\n      REGION TYPE                    START - END         [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->  \n      MALLOC_NANO (reserved)   600018000000-600020000000 [128.0M] rw-\/rwx SM=NUL  ...(unallocated)",
  "isCorpse" : 1,
  "exception" : {"codes":"0x0000000000000001, 0x0000000000000020","rawCodes":[1,32],"type":"EXC_BAD_ACCESS","signal":"SIGSEGV","subtype":"KERN_INVALID_ADDRESS at 0x0000000000000020"},
  "termination" : {"flags":0,"code":11,"namespace":"SIGNAL","indicator":"Segmentation fault: 11","byProc":"exc handler","byPid":53398},
  "vmregioninfo" : "0x20 is not in any region.  Bytes before following region: 105553518919648\n      REGION TYPE                    START - END         [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->  \n      MALLOC_NANO (reserved)   600018000000-600020000000 [128.0M] rw-\/rwx SM=NUL  ...(unallocated)",
  "extMods" : {"caller":{"thread_create":0,"thread_set_state":0,"task_for_pid":0},"system":{"thread_create":0,"thread_set_state":0,"task_for_pid":4},"targeted":{"thread_create":0,"thread_set_state":0,"task_for_pid":0},"warnings":0},
  "faultingThread" : 0,
  "threads" : [{"triggered":true,"id":13803416,"threadState":{"x":[{"value":4363213264},{"value":105553130923296},{"value":2},{"value":6637940812,"symbolLocation":0,"symbol":"nanov2_free_definite_size"},{"value":1},{"value":52},{"value":0},{"value":0},{"value":2305843009213693952},{"value":0},{"value":576460760430598789,"symbolLocation":576460752303423493,"symbol":"OBJC_CLASS_$_NSCGSWindow"},{"value":648518354468526725,"symbolLocation":648518346341351429,"symbol":"OBJC_CLASS_$_NSCGSWindow"},{"value":199},{"value":4266033356},{"value":4268132352},{"value":209},{"value":6638437680,"symbolLocation":0,"symbol":"objc_release"},{"value":8151208440},{"value":0},{"value":4974530560},{"value":4974530632},{"value":4363213264},{"value":2711724449},{"value":4350821984,"symbolLocation":224,"symbol":"_main_thread"},{"value":11791448172606497699},{"value":1},{"value":0},{"value":6124461152},{"value":0}],"flavor":"ARM_THREAD_STATE64","lr":{"value":6638456132},"cpsr":{"value":536875008},"fp":{"value":6124460752},"sp":{"value":6124460688},"esr":{"value":2449473542,"description":"(Data Abort) byte read Translation fault"},"pc":{"value":6638437696,"matchesCrashFrame":1},"far":{"value":32}},"queue":"com.apple.main-thread","frames":[{"imageOffset":38208,"symbol":"objc_release","symbolLocation":16,"imageIndex":0},{"imageOffset":56644,"symbol":"AutoreleasePoolPage::releaseUntil(objc_object**)","symbolLocation":196,"imageIndex":0},{"imageOffset":42660,"symbol":"objc_autoreleasePoolPop","symbolLocation":212,"imageIndex":0},{"imageOffset":270636,"symbol":"_CFAutoreleasePoolPop","symbolLocation":32,"imageIndex":1},{"imageOffset":1434836,"symbol":"__CFRunLoopPerCalloutARPEnd","symbolLocation":48,"imageIndex":1},{"imageOffset":539516,"symbol":"__CFRunLoopRun","symbolLocation":2600,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":205624,"symbol":"RunCurrentEventLoopInMode","symbolLocation":292,"imageIndex":2},{"imageOffset":204980,"symbol":"ReceiveNextEventCommon","symbolLocation":564,"imageIndex":2},{"imageOffset":204392,"symbol":"_BlockUntilNextEventMatchingListInModeWithFilter","symbolLocation":72,"imageIndex":2},{"imageOffset":267448,"symbol":"_DPSNextEvent","symbolLocation":860,"imageIndex":3},{"imageOffset":261552,"symbol":"-[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:]","symbolLocation":1328,"imageIndex":3},{"imageOffset":204668,"symbol":"-[NSApplication run]","symbolLocation":596,"imageIndex":3},{"imageOffset":13976,"symbol":"NSApplicationMain","symbolLocation":1132,"imageIndex":3},{"imageOffset":543764,"sourceLine":300,"sourceFile":"main.m","symbol":"main","imageIndex":4,"symbolLocation":384},{"imageOffset":20620,"symbol":"start","symbolLocation":520,"imageIndex":5}]},{"id":13803422,"queue":"com.apple.root.default-qos","frames":[{"imageOffset":6288,"symbol":"mach_msg_trap","symbolLocation":8,"imageIndex":6},{"imageOffset":7424,"symbol":"mach_msg","symbolLocation":76,"imageIndex":6},{"imageOffset":545088,"symbol":"__CFRunLoopServiceMachPort","symbolLocation":372,"imageIndex":1},{"imageOffset":538096,"symbol":"__CFRunLoopRun","symbolLocation":1180,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":1113048,"symbol":"CFRunLoopRun","symbolLocation":64,"imageIndex":1},{"imageOffset":1094500,"sourceLine":5798,"sourceFile":"DeviceManager.m","symbol":"__51-[DeviceManager dfu_recovery_device_event_callback]_block_invoke","imageIndex":4,"symbolLocation":452},{"imageOffset":9712,"symbol":"_dispatch_call_block_and_release","symbolLocation":32,"imageIndex":7},{"imageOffset":16820,"symbol":"_dispatch_client_callout","symbolLocation":20,"imageIndex":7},{"imageOffset":29384,"symbol":"_dispatch_queue_override_invoke","symbolLocation":784,"imageIndex":7},{"imageOffset":88296,"symbol":"_dispatch_root_queue_drain","symbolLocation":396,"imageIndex":7},{"imageOffset":90372,"symbol":"_dispatch_worker_thread2","symbolLocation":164,"imageIndex":7},{"imageOffset":13092,"symbol":"_pthread_wqthread","symbolLocation":228,"imageIndex":8},{"imageOffset":8320,"symbol":"start_wqthread","symbolLocation":8,"imageIndex":8}]},{"id":13803426,"frames":[{"imageOffset":40592,"symbol":"poll","symbolLocation":8,"imageIndex":6},{"imageOffset":14744,"symbol":"socket_check_fd","symbolLocation":428,"imageIndex":9},{"imageOffset":15504,"symbol":"socket_receive_timeout","symbolLocation":52,"imageIndex":9},{"imageOffset":14440,"symbol":"receive_packet","symbolLocation":108,"imageIndex":10},{"imageOffset":22092,"symbol":"get_next_event","symbolLocation":68,"imageIndex":10},{"imageOffset":10004,"symbol":"device_monitor","symbolLocation":104,"imageIndex":10},{"imageOffset":29292,"symbol":"_pthread_start","symbolLocation":148,"imageIndex":8},{"imageOffset":8332,"symbol":"thread_start","symbolLocation":8,"imageIndex":8}]},{"id":13803430,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13803434,"name":"com.apple.NSEventThread","frames":[{"imageOffset":6288,"symbol":"mach_msg_trap","symbolLocation":8,"imageIndex":6},{"imageOffset":7424,"symbol":"mach_msg","symbolLocation":76,"imageIndex":6},{"imageOffset":545088,"symbol":"__CFRunLoopServiceMachPort","symbolLocation":372,"imageIndex":1},{"imageOffset":538096,"symbol":"__CFRunLoopRun","symbolLocation":1180,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":1761436,"symbol":"_NSEventThread","symbolLocation":196,"imageIndex":3},{"imageOffset":29292,"symbol":"_pthread_start","symbolLocation":148,"imageIndex":8},{"imageOffset":8332,"symbol":"thread_start","symbolLocation":8,"imageIndex":8}]},{"id":13803458,"name":"com.apple.NSURLConnectionLoader","frames":[{"imageOffset":6288,"symbol":"mach_msg_trap","symbolLocation":8,"imageIndex":6},{"imageOffset":7424,"symbol":"mach_msg","symbolLocation":76,"imageIndex":6},{"imageOffset":545088,"symbol":"__CFRunLoopServiceMachPort","symbolLocation":372,"imageIndex":1},{"imageOffset":538096,"symbol":"__CFRunLoopRun","symbolLocation":1180,"imageIndex":1},{"imageOffset":534964,"symbol":"CFRunLoopRunSpecific","symbolLocation":600,"imageIndex":1},{"imageOffset":2533176,"imageIndex":11},{"imageOffset":378268,"symbol":"__NSThread__start__","symbolLocation":808,"imageIndex":12},{"imageOffset":29292,"symbol":"_pthread_start","symbolLocation":148,"imageIndex":8},{"imageOffset":8332,"symbol":"thread_start","symbolLocation":8,"imageIndex":8}]},{"id":13804631,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804818,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804820,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804821,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804822,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804823,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]},{"id":13804824,"frames":[{"imageOffset":8312,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":8}]}],
  "usedImages" : [
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6638399488,
    "size" : 253952,
    "uuid" : "44d5d68a-ad18-33b8-adea-eb65b4dc906c",
    "path" : "\/usr\/lib\/libobjc.A.dylib",
    "name" : "libobjc.A.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6640271360,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.CoreFoundation",
    "size" : 5533696,
    "uuid" : "07e05b49-8c3c-354e-89a7-cc7994572dfe",
    "path" : "\/System\/Library\/Frameworks\/CoreFoundation.framework\/Versions\/A\/CoreFoundation",
    "name" : "CoreFoundation",
    "CFBundleVersion" : "1866"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6787686400,
    "CFBundleShortVersionString" : "2.1.1",
    "CFBundleIdentifier" : "com.apple.HIToolbox",
    "size" : 3358720,
    "uuid" : "07987381-b579-3f72-8ba8-97fa5b5a3352",
    "path" : "\/System\/Library\/Frameworks\/Carbon.framework\/Versions\/A\/Frameworks\/HIToolbox.framework\/Versions\/A\/HIToolbox",
    "name" : "HIToolbox"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6686056448,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.AppKit",
    "size" : 15437824,
    "uuid" : "2f9d63e8-f87c-3348-b5c5-39de32463324",
    "path" : "\/System\/Library\/Frameworks\/AppKit.framework\/Versions\/C\/AppKit",
    "name" : "AppKit",
    "CFBundleVersion" : "2113.60.148"
  },
  {
    "source" : "P",
    "arch" : "arm64",
    "base" : 4342415360,
    "size" : 2244608,
    "uuid" : "f0b329ab-7294-3ece-9e13-ec1e22473c83",
    "path" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/MacOS\/MFCTOOL.bin",
    "name" : "MFCTOOL.bin"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 4350328832,
    "size" : 393216,
    "uuid" : "0a55d424-2537-3f9b-ada1-ef612d185def",
    "path" : "\/usr\/lib\/dyld",
    "name" : "dyld"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6639718400,
    "size" : 229376,
    "uuid" : "6e9cd1b1-2daa-3338-a85a-965721bcebdc",
    "path" : "\/usr\/lib\/system\/libsystem_kernel.dylib",
    "name" : "libsystem_kernel.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6638108672,
    "size" : 290816,
    "uuid" : "26532eb9-1697-3bcb-aa36-f07a3405770a",
    "path" : "\/usr\/lib\/system\/libdispatch.dylib",
    "name" : "libdispatch.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6639947776,
    "size" : 53248,
    "uuid" : "569fc817-bb09-3ef2-8b18-af7f7bd615ec",
    "path" : "\/usr\/lib\/system\/libsystem_pthread.dylib",
    "name" : "libsystem_pthread.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64",
    "base" : 4355932160,
    "size" : 65536,
    "uuid" : "f4558a88-ccf6-3de5-92cf-937c11037767",
    "path" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/Frameworks\/libimfccoreextra.dylib",
    "name" : "libimfccoreextra.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64",
    "base" : 4354588672,
    "size" : 32768,
    "uuid" : "19108f9b-0fcc-3b50-ac83-8fd75d2e78ea",
    "path" : "\/Users\/USER\/Library\/Developer\/Xcode\/DerivedData\/MFCTOOL-eulkxvnzunphqvgxtuodxclcwtkp\/Build\/Products\/Debug\/MFCTOOL.app\/Contents\/Frameworks\/libimfcusb.dylib",
    "name" : "libimfcusb.dylib"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6720028672,
    "CFBundleShortVersionString" : "1335.5",
    "CFBundleIdentifier" : "com.apple.CFNetwork",
    "size" : 4931584,
    "uuid" : "46dc101d-2215-38ff-b769-f08335df88fc",
    "path" : "\/System\/Library\/Frameworks\/CFNetwork.framework\/Versions\/A\/CFNetwork",
    "name" : "CFNetwork",
    "CFBundleVersion" : "1335.5"
  },
  {
    "source" : "P",
    "arch" : "arm64e",
    "base" : 6656020480,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.Foundation",
    "size" : 4136960,
    "uuid" : "ed1a7ccd-78c8-37a7-a4fe-1e5051fcf967",
    "path" : "\/System\/Library\/Frameworks\/Foundation.framework\/Versions\/C\/Foundation",
    "name" : "Foundation",
    "CFBundleVersion" : "1866"
  },
  {
    "size" : 0,
    "source" : "A",
    "base" : 0,
    "uuid" : "00000000-0000-0000-0000-000000000000"
  }
],
  "sharedCache" : {
  "base" : 6636650496,
  "size" : 3144597504,
  "uuid" : "5c4078a4-271a-3960-afba-5253d8f04519"
},
  "vmSummary" : "ReadOnly portion of Libraries: Total=1.1G resident=0K(0%) swapped_out_or_unallocated=1.1G(100%)\nWritable regions: Total=1.6G written=0K(0%) resident=0K(0%) swapped_out=0K(0%) unallocated=1.6G(100%)\n\n                                VIRTUAL   REGION \nREGION TYPE                        SIZE    COUNT (non-coalesced) \n===========                     =======  ======= \nAccelerate framework              1536K       12 \nActivity Tracing                   256K        1 \nCG backing stores                  768K        4 \nCG image                          1088K       60 \nColorSync                          640K       28 \nCoreAnimation                     19.0M      284 \nCoreGraphics                        32K        2 \nCoreImage                           96K        6 \nCoreUI image data                 3904K       54 \nFoundation                          48K        2 \nImage IO                          1712K       11 \nKernel Alloc Once                   32K        1 \nMALLOC                           294.5M       62 \nMALLOC guard page                  288K       16 \nMALLOC_MEDIUM (reserved)         960.0M        8         reserved VM address space (unallocated)\nMALLOC_NANO (reserved)           384.0M        1         reserved VM address space (unallocated)\nSQLite page cache                  256K        4 \nSTACK GUARD                       56.2M       13 \nStack                             14.4M       13 \nVM_ALLOCATE                        272K       15 \n__AUTH                            2494K      285 \n__AUTH_CONST                      19.5M      470 \n__CTF                               756        1 \n__DATA                            15.4M      490 \n__DATA_CONST                      18.4M      503 \n__DATA_DIRTY                      1706K      200 \n__FONT_DATA                          4K        1 \n__LINKEDIT                       582.0M       33 \n__OBJC_CONST                      3323K      257 \n__OBJC_RO                         83.0M        1 \n__OBJC_RW                         3168K        1 \n__TEXT                           521.9M      522 \n__UNICODE                          592K        1 \ndyld private memory               1024K        1 \nlibnetwork                        1152K       16 \nmapped file                      499.1M       65 \nshared memory                      848K       12 \n===========                     =======  ======= \nTOTAL                              3.4G     3456 \nTOTAL, minus reserved VM space     2.1G     3456 \n",
  "legacyInfo" : {
  "threadTriggered" : {
    "queue" : "com.apple.main-thread"
  }
},
  "trialInfo" : {
  "rollouts" : [
    {
      "rolloutId" : "61af99aeda72d16a4beb7756",
      "factorPackIds" : {

      },
      "deploymentId" : 240000409
    },
    {
      "rolloutId" : "6112e14f37f5d11121dcd519",
      "factorPackIds" : {
        "SIRI_TEXT_TO_SPEECH" : "634710168e8be655c1316aaa"
      },
      "deploymentId" : 240000231
    }
  ],
  "experiments" : [

  ]
}
}


