V0 的代码：


//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Created based on libimobiledevice mobilesync API
//  Provides selective backup functionality using mobilesync protocol
//
//  Final Version - 2025.01.27
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// 引入 libimobiledevice 相关头文件
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// 常量定义
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// 基于实际iOS同步类的数据类型映射
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        // 基于实际的iOS同步服务类标识符
        map = @{
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.Bookmarks",
            @(BackupDataTypeMailAccounts): @"com.apple.MailAccounts",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper"
        };
    });
    return map;
}

// 获取已知的同步类列表 - 用于检测支持的数据类型
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.Bookmarks",
            @"com.apple.MailAccounts",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - SyncDataItem 实现

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
            self.name, self.identifier, @(self.recordCount)];
}

@end

#pragma mark - BackupOptionTask 内部接口

@interface BackupOptionTask () {
    // libimobiledevice C API 指针
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // 操作状态
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // 同步上下文
    dispatch_queue_t _operationQueue;
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;

    
    // 当前操作参数
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // 内部状态
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
}

// 私有方法声明
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// 真实数据处理方法
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// 数据获取方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// 同步操作方法
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// 验证和错误处理
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;

// 工具方法
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;

@end

#pragma mark - BackupOptionTask 实现

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;

#pragma mark - 单例和初始化

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        
        // 设置默认数据存储路径
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        
        [self logMessage:[NSString stringWithFormat:@"BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}



#pragma mark - 设备连接和查询

- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
    
    if (!deviceUDID || deviceUDID.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Device UDID cannot be empty"];
        }
        return NO;
    }
    
    // 如果已经连接到同一设备，直接返回成功
    if ([_deviceUDID isEqualToString:deviceUDID] && _device && _lockdown && _mobilesync) {
        [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@", deviceUDID]];
        return YES;
    }
    
    // 先断开现有连接
    [self disconnectDevice];
    
    _deviceUDID = [deviceUDID copy];
    return [self connectToDeviceInternal:deviceUDID error:error];
}

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. 连接设备
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. 创建lockdown客户端
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // 3. 启动mobilesync服务
    if (![self startMobileSyncService:error]) {
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@", deviceUDID]];
    [self setInternalStatus:SyncTaskStatusIdle];
    return YES;
}

// 在 startMobileSyncService 方法中添加重试逻辑
- (BOOL)startMobileSyncService:(NSError **)error {
    int maxRetries = 3;
    int retryDelay = 2; // 秒
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            if (err == MOBILESYNC_E_SUCCESS) {
                return YES;  // 成功
            }
            
            [self logMessage:[NSString stringWithFormat:@"MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
        }
        
        // 如果不是最后一次尝试，等待后重试
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"Retrying in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // 所有尝试都失败
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                         description:@"Failed to create mobilesync client after multiple attempts"];
    }
    return NO;
}

- (void)disconnectDevice {
    [self logMessage:@"Disconnecting device"];
    
    if (_mobilesync) {
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
    }
    
    if (_afc) {
        afc_client_free(_afc);
        _afc = NULL;
    }
    
    if (_np) {
        np_client_free(_np);
        _np = NULL;
    }
    
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
    }
    
    if (_device) {
        idevice_free(_device);
        _device = NULL;
    }
    
    [self setInternalStatus:SyncTaskStatusIdle];
}

- (BOOL)isConnected {
    return (_device != NULL && _lockdown != NULL && _mobilesync != NULL);
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    @try {
        // 使用正确的API创建anchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // 准备正确的参数
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // 正确调用mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // 如果成功启动，需要结束会话
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    // ✅ 关键修复：重置MobileSync状态
    if (_mobilesync) {
        mobilesync_finish(_mobilesync);
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [NSThread sleepForTimeInterval:0.5]; // 让设备状态重置
    }
    
    // 重新启动MobileSync服务
    if (![self startMobileSyncService:error]) {
        return BackupDataTypeNone;
    }
    
    [self logMessage:@"Getting supported data types with enhanced stability"];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // ✅ 修复1：使用缓存机制避免重复检测
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    
    // 检查缓存是否有效（5分钟内且同一设备）
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                         (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // ✅ 修复2：确保连接稳定性
    if (![self ensureStableConnection:error]) {
        return BackupDataTypeNone;
    }
    
    NSArray *allDataTypes = @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
    
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    for (NSNumber *dataTypeNum in allDataTypes) {
        BackupDataType dataType = [dataTypeNum unsignedIntegerValue];
        
        // ✅ 修复3：使用改进的稳定检测方法
        BOOL isSupported = [self isDataTypeSupportedStable:dataType];
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
            [self logMessage:[NSString stringWithFormat:@"✅ Supported data type: %@",
                             [BackupOptionTask stringForDataType:dataType]]];
        } else {
            [self logMessage:[NSString stringWithFormat:@"❌ Unsupported data type: %@",
                             [BackupOptionTask stringForDataType:dataType]]];
        }
        
        // ✅ 修复4：添加延迟避免过度请求
        if (dataTypeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.1];
        }
    }
    
    // ✅ 修复5：更新缓存
    if (successCount > 0) {
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cacheTime = [NSDate date];
    }
    
    [self logMessage:[NSString stringWithFormat:@"📊 Final result: %lu/%lu data types supported",
                     (unsigned long)successCount, (unsigned long)totalCount]];
    
    return supportedTypes;
}


// ✅ 新增：稳定的连接确保方法
- (BOOL)ensureStableConnection:(NSError **)error {
    // 检查连接状态
    if (![self isConnected]) {
        [self logMessage:@"Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // 重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // ✅ 验证连接质量：尝试简单的lockdown操作
    if (_lockdown) {
        char *device_name = NULL;
        lockdownd_error_t ldret = lockdownd_get_device_name(_lockdown, &device_name);
        
        if (ldret == LOCKDOWN_E_SUCCESS && device_name) {
            free(device_name);
            [self logMessage:@"Connection quality verified"];
            return YES;
        } else {
            [self logMessage:[NSString stringWithFormat:@"Connection quality check failed: %d", ldret]];
            
            // 连接质量不好，尝试重连
            [self disconnectDevice];
            [NSThread sleepForTimeInterval:0.5];
            return [self connectToDeviceInternal:_deviceUDID error:error];
        }
    }
    
    return YES;
}

// ✅ 新增：稳定的数据类型检测方法
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    // ✅ 添加连接检查
    if (!_mobilesync) {
        [self logMessage:@"MobileSync未连接，跳过检测"];
        return NO;
    }
    
    @try {
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // ✅ 重要：立即结束会话，避免状态残留
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // ✅ 每次检测后休息，避免设备过载
        [NSThread sleepForTimeInterval:0.2];
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"检测异常: %@", exception.reason]];
        return NO;
    }
}


// ✅ 增强的数据获取方法
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"增强方法获取 %@ 的真实数据", typeName);
    
    // ✅ 连接状态检查
    if (![self isConnected]) {
        NSLog(@"❌ 设备未连接，无法获取 %@ 数据", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // ✅ 多次尝试获取数据
    int maxAttempts = 3;
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
        if (attempt > 0) {
            NSLog(@"重试获取 %@ 数据 (第 %d 次尝试)", typeName, attempt + 1);
            [NSThread sleepForTimeInterval:0.5];
        }
        
        items = [self getDataItemsForType:dataType error:&error];
        
        if (items && items.count > 0) {
            NSLog(@"✅ 第 %d 次尝试成功获取 %@ 数据: %lu 项",
                  attempt + 1, typeName, (unsigned long)items.count);
            break;
        }
        
        if (error) {
            NSLog(@"❌ 第 %d 次尝试获取 %@ 数据失败: %@",
                  attempt + 1, typeName, error.localizedDescription);
            error = nil; // 清除错误以便下次尝试
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"❌ %@ 最终无法获取到数据", typeName);
    return nil;
}




#pragma mark - 数据查询

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // 检查缓存
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // 使用真实的数据获取方法
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // 缓存结果
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - 真实数据获取实现

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"🔧 使用修复版获取 %@ 数据", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // 添加设备兼容性检查
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // ✅ 关键修复：每次数据获取前都重新建立 MobileSync 连接
        [self logMessage:@"🔄 重新建立 MobileSync 连接以确保数据获取稳定性"];
        
        // 强制断开并重建 MobileSync 连接
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // 短暂等待，让设备重置状态
        [NSThread sleepForTimeInterval:0.5];
        
        // 重新启动 MobileSync 服务
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"❌ 重新启动 MobileSync 服务失败: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"✅ MobileSync 连接已重新建立"];
        
        // ✅ 关键修复2：使用与检测时相同的参数
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"❌ 创建anchors失败"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // ✅ 关键修复3：使用检测时完全相同的参数
        uint64_t data_class_version = 106;  // 与检测时保持一致
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"🔧 使用干净连接启动同步会话: %@", syncClass]];
        
        // ✅ 关键修复4：启动同步会话
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"✅ %@ 同步会话启动成功（干净连接）", syncClass]];
            
            // ✅ 使用更稳定的数据获取方法
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"✅ 成功请求 %@ 的所有记录", syncClass]];
                
                // ✅ 改进的数据接收逻辑 - 处理超时和多批次数据
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // 减少最大批次数量
                int timeoutCount = 0;
                int maxTimeouts = 2; // 允许的最大超时次数
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"📦 mobilesync_receive_changes 返回状态: %d (批次 %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // 重置超时计数器
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"📦 处理 %@ 第 %d 批数据",
                                            syncClass, batchCount]];
                            
                            // 🔍 详细分析接收到的数据类型
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"📊 接收到的数据类型: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // 🔧 改进的数据处理：支持多种数据类型
                            NSArray<SyncDataItem *> *batchItems = [self processReceivedDataEnhanced:entities
                                                                                            dataType:dataType
                                                                                           syncClass:syncClass
                                                                                          batchIndex:batchCount];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"✅ 从第 %d 批获取到 %lu 项数据",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"📋 第 %d 批数据为空或处理失败", batchCount]];
                            }
                            
                            // 清理resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"📭 第 %d 批 %@ 返回空数据", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // 🔧 改进的超时处理
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"⏰ %@ 接收超时 (第 %d 次，共 %d 次)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 超时次数达到上限，停止接收", syncClass]];
                            break;
                        }
                        
                        // 如果已经获取到数据，超时可能是正常的结束信号
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"💡 %@ 已获取到数据，超时可能是正常结束", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"❌ 接收 %@ 数据时出错: %d",
                                        syncClass, receive_err]];
                        
                        // 🔧 增强的错误处理
                        [self handleReceiveError:receive_err forSyncClass:syncClass];
                        break;
                    }
                    
                    // 防止无限循环
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 达到最大批次限制(%d)，停止接收",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // 如果标记为最后一条记录，直接退出
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"🏁 %@ 接收到最后记录标记，正常结束", syncClass]];
                        break;
                    }
                    
                    // 添加小延迟，避免过度请求
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // 使用内部逻辑控制循环
                
                [self logMessage:[NSString stringWithFormat:@"📊 %@ 数据接收完成: %d 批次, %lu 项",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"❌ %@ get_all_records失败: %d",
                                syncClass, get_all_err]];
                [self handleSyncError:get_all_err forDataType:dataType operation:@"get_all_records"];
                
                // 🔧 为某些错误提供更好的错误信息
                if (error) {
                    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:get_all_err];
                    *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                     description:errorDesc];
                }
            }
            
            // ✅ 确保会话正确结束
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"✅ %@ 同步会话已结束", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"❌ %@ mobilesync_start失败（干净连接后）: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"错误详情: %s", error_description]];
            }
            
            // ✅ 关键修复5：如果还是失败，说明是真正的不兼容
            [self handleStartSyncError:start_err forSyncClass:syncClass error:error];
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // ✅ 即使没有获取到数据也不算错误
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"📋 %@ 没有可用数据（使用干净连接后确认）", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"📊 %@ 最终获取到 %lu 项真实数据（干净连接）",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 数据获取异常: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}


- (NSArray<SyncDataItem *> *)processReceivedDataEnhanced:(plist_t)entities
                                                dataType:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                              batchIndex:(int)batchIndex {
    
    if (!entities) {
        [self logMessage:[NSString stringWithFormat:@"第 %d 批 %@ 数据为空", batchIndex, syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(entities);
    
    // 🔧 处理不同的数据类型
    switch (type) {
        case PLIST_ARRAY: {
            // 标准数组处理
            [self logMessage:[NSString stringWithFormat:@"📋 处理 %@ 数组数据", syncClass]];
            return [self processRealDataForType:dataType dataArray:entities syncClass:syncClass];
        }
        
        case PLIST_BOOLEAN: {
            // 布尔值可能表示同步状态或空数据
            uint8_t bool_val = 0;
            plist_get_bool_val(entities, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"📤 %@ 返回布尔值: %s",
                             syncClass, bool_val ? "true" : "false"]];
            
            if (bool_val) {
                [self logMessage:[NSString stringWithFormat:@"💡 %@ 同步成功但无数据项", syncClass]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"💡 %@ 同步失败或不支持", syncClass]];
            }
            return @[];
        }
        
        case PLIST_DICT: {
            // 字典可能包含错误信息或状态
            [self logMessage:[NSString stringWithFormat:@"📋 %@ 返回字典数据，尝试解析", syncClass]];
            
            // 先检查字典中的内容
            uint32_t dict_size = plist_dict_get_size(entities);
            [self logMessage:[NSString stringWithFormat:@"📊 字典包含 %u 个键值对", dict_size]];
            
            // 检查是否包含错误信息
            plist_t error_node = plist_dict_get_item(entities, "Error");
            if (error_node) {
                char *error_msg = NULL;
                if (plist_get_node_type(error_node) == PLIST_STRING) {
                    plist_get_string_val(error_node, &error_msg);
                    if (error_msg) {
                        [self logMessage:[NSString stringWithFormat:@"❌ %@ 错误: %s", syncClass, error_msg]];
                        free(error_msg);
                    }
                }
                return @[];
            }
            
            // 检查是否包含状态信息
            plist_t status_node = plist_dict_get_item(entities, "Status");
            if (status_node && plist_get_node_type(status_node) == PLIST_STRING) {
                char *status_msg = NULL;
                plist_get_string_val(status_node, &status_msg);
                if (status_msg) {
                    [self logMessage:[NSString stringWithFormat:@"📋 %@ 状态: %s", syncClass, status_msg]];
                    free(status_msg);
                }
            }
            
            // 如果字典为空或包含有用数据，尝试处理为单个项目
            if (dict_size > 0) {
                [self logMessage:[NSString stringWithFormat:@"💡 尝试将 %@ 字典作为数据项处理", syncClass]];
                SyncDataItem *item = [self createSyncItemFromPlist:entities dataType:dataType index:0];
                if (item) {
                    [self logMessage:[NSString stringWithFormat:@"✅ 成功创建 %@ 数据项: %@", syncClass, item.name ?: @"未命名"]];
                    return @[item];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"❌ 无法从 %@ 字典创建数据项", syncClass]];
                }
            }
            
            return @[];
        }
        
        case PLIST_STRING: {
            // 字符串可能是错误消息
            char *str_val = NULL;
            plist_get_string_val(entities, &str_val);
            if (str_val) {
                [self logMessage:[NSString stringWithFormat:@"📤 %@ 返回字符串: %s", syncClass, str_val]];
                free(str_val);
            }
            return @[];
        }
        
        case PLIST_UINT: {
            // 数字可能是状态码
            uint64_t uint_val = 0;
            plist_get_uint_val(entities, &uint_val);
            [self logMessage:[NSString stringWithFormat:@"📤 %@ 返回数字: %llu", syncClass, uint_val]];
            return @[];
        }
        
        default: {
            [self logMessage:[NSString stringWithFormat:@"⚠️ %@ 返回未知数据类型 %@ (%d)",
                             syncClass, [self stringForPlistType:type], type]];
            return @[];
        }
    }
}

// 🔧 增强的错误处理 - 改进超时处理
- (void)handleReceiveError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass {
    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
    
    switch (error) {
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:[NSString stringWithFormat:@"⏰ %@ 数据接收超时，这可能是正常的结束信号", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:[NSString stringWithFormat:@"🔌 %@ 连接中断，设备可能断开连接", syncClass]];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:[NSString stringWithFormat:@"📋 %@ 数据格式错误，plist解析失败", syncClass]];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"📤 %@ 接收错误: %@", syncClass, errorDesc]];
            break;
    }
}

- (void)handleStartSyncError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass error:(NSError **)outError {
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:[NSString stringWithFormat:@"💡 %@ 在干净连接后仍然参数无效，该设备确实不支持此数据类型的数据获取", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"💡 连接错误，设备可能已断开"];
            if (outError) {
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                    description:@"Device connection lost during sync"];
            }
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"💡 %@ 启动同步失败，错误码: %d", syncClass, error]];
            if (outError) {
                NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                    description:errorDesc];
            }
            break;
    }
    
    [self handleSyncError:error forDataType:0 operation:@"start_sync"];
}


// 🔧 获取MobileSync错误的描述
- (NSString *)getErrorDescriptionForMobileSyncError:(mobilesync_error_t)error {
    switch (error) {
        case MOBILESYNC_E_SUCCESS:
            return @"Success";
        case MOBILESYNC_E_INVALID_ARG:
            return @"Invalid argument - check sync class name and parameters";
        case MOBILESYNC_E_PLIST_ERROR:
            return @"Plist parsing error - data format issue";
        case MOBILESYNC_E_MUX_ERROR:
            return @"Connection error - device may have disconnected";
        case MOBILESYNC_E_SSL_ERROR:
            return @"SSL error - secure connection failed";
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            return @"Receive timeout - device not responding";
        case MOBILESYNC_E_BAD_VERSION:
            return @"Version mismatch - sync protocol version not supported";
        default:
            return [NSString stringWithFormat:@"Unknown sync error: %d", error];
    }
}

// ✅ 新增：改进的数据处理方法，更好地处理空数据情况
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"📋 %@ 数据为空，创建空数据字典", typeName]];
        
        // ✅ 即使没有数据也创建一个有效的字典
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ 支持但当前无数据", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // 计算统计信息
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

// ✅ 新增：改进的增强数据扫描方法
- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== 🔧 开始修复版设备真实数据扫描 ===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // ✅ 首先获取支持的数据类型
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"❌ 获取支持的数据类型失败: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"❌ 设备不支持任何数据类型的选择性同步");
        return @{};
    }
    
    NSLog(@"✅ 设备支持的数据类型掩码: %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // 逐个处理支持的数据类型
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // 只处理设备支持的数据类型
        if (!(supportedTypes & dataType)) {
            NSLog(@"⏭️ 跳过不支持的数据类型: %@", typeName);
            continue;
        }
        
        NSLog(@"🔍 正在获取 %@ 的真实数据...", typeName);
        
        // ✅ 使用改进的数据获取方法
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"📋 %@ 支持但无数据: %@ 项", typeName, itemCount);
            } else {
                NSLog(@"✅ %@ 获取成功: %@ 项", typeName, itemCount);
            }
        } else {
            NSLog(@"❌ %@ 获取失败或无响应", typeName);
        }
        
        // 添加延迟避免过度请求
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== 🔧 修复版数据扫描完成，共处理 %lu 种数据类型 ===",
          (unsigned long)realData.count);
    return [realData copy];
}

#pragma mark - 真实数据处理方法

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 处理非数组类型的情况
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"💡 %@ 返回非数组数据，可能表示空数据集", syncClass]];
        
        // 如果是布尔类型，可能表示同步状态
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ 同步状态: %s",
                             syncClass, bool_val ? "成功" : "失败"]];
        }
        
        return @[]; // 返回空数组而不是失败
    }
    
    // 继续处理数组数据...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}


- (BOOL)checkDeviceCompatibility:(NSError **)error {
    if (![self isConnected]) {
        return NO;
    }
    
    // 获取设备信息
    char *device_name = NULL;
    plist_t product_version_plist = NULL;
    
    // 获取设备名称
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"设备名称: %s", device_name]];
        free(device_name);
    }
    
    // 获取iOS版本
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &product_version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && product_version_plist) {
        char *product_version = NULL;
        plist_get_string_val(product_version_plist, &product_version);
        
        if (product_version) {
            [self logMessage:[NSString stringWithFormat:@"iOS版本: %s", product_version]];
            
            // 检查iOS版本兼容性
            NSString *versionStr = [NSString stringWithUTF8String:product_version];
            NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
            
            if (versionComponents.count > 0) {
                NSInteger majorVersion = [versionComponents[0] integerValue];
                
                if (majorVersion < 9) {
                    [self logMessage:@"⚠️ iOS版本过低，可能不支持选择性同步"];
                } else if (majorVersion >= 15) {
                    [self logMessage:@"💡 iOS 15+设备，可能需要特殊处理"];
                }
            }
            
            free(product_version);
        }
        
        plist_free(product_version_plist);
    }
    
    return YES;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // 提取通用字段
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // 根据数据类型提取特定字段
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeMailAccounts:
            [self extractMailAccountSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // 如果没有标识符，使用索引
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // 如果没有名称，使用默认名称
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // 提取记录ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // 提取修改时间
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // 估算数据大小
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // 默认大小
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 姓名字段
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 电话号码
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // 邮箱地址
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 日历标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 开始时间
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // 结束时间
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 书签标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 书签标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 备忘录标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 内容
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // 大概估算
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 提醒事项标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 完成状态
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // 优先级
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 尝试各种可能的名称字段
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 添加一些通用元数据
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

#pragma mark - 选择性同步操作

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // 异步执行同步操作
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // 分解数据类型为单独的类型
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // 按数据类型分组
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // 对每种数据类型执行同步
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // 这里可以实现更细粒度的项目同步逻辑
        // 目前先使用数据类型级别的同步
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // 创建备份目录
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - 操作控制

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - 同步操作实现

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // 根据方向执行不同的操作
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // 双向同步暂时不实现
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 获取数据项
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // 创建数据类型目录
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // 保存数据项信息
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // 保存备份元数据
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - 数据类型工具方法

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeMailAccounts:
            return @"MailAccounts";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // 这里可以根据需要添加本地化支持
    // 目前返回英文版本
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeMailAccounts) [array addObject:@(BackupDataTypeMailAccounts)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
}

#pragma mark - 便捷方法

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *mailAccountsPath = [_dataStoragePath stringByAppendingPathComponent:@"MailAccounts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeMailAccounts
                                     toDirectory:mailAccountsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}



- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // 设置完成回调来捕获结果
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - 数据验证和恢复

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // 尝试读取文件以验证格式
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // 参数验证
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查路径是否存在
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // 确保是目录而不是文件
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // 获取基本信息 - 添加错误处理
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // 设置默认值
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // 扫描数据类型
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // 自动释放池，避免内存累积
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // 检查items.plist是否存在
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // 尝试读取items数据
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // 计算该数据类型的大小
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // 设置汇总信息
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // 添加备份统计信息
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - 验证和错误处理

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 增强的类型检查和日志
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // 如果不是数组，尝试处理其他可能的类型
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // 可能表示没有数据或操作失败
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // 如果是true，可能表示成功但无数据
        }
        
        [self logMessage:[NSString stringWithFormat:@"⚠️ Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

#pragma mark - 新增的辅助方法

// 🔧 设备兼容性检查 - 修复版本
- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"📱 设备未连接或lockdown未初始化"];
        return;
    }
    
    // 修复1：正确获取设备名称
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"📱 设备名称: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"📱 获取设备名称失败: %d", ret]];
    }
    
    // 修复2：正确获取iOS版本
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"📱 iOS版本: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"⚠️ iOS版本过低，可能不支持选择性同步"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"💡 iOS 15+设备，数据格式可能有变化"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"💡 iOS %ld 设备，兼容性良好", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"📱 获取iOS版本失败: %d", ret]];
    }
    
    // 修复3：正确获取设备型号
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"📱 设备型号: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"📱 获取设备型号失败: %d", ret]];
    }
}

// 🔧 Plist类型转换为可读字符串
- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}


- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // 根据错误类型采取不同的处理策略
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // 尝试重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // 快速检查是否支持此数据类型
    return [self isDataTypeSupported:dataType];
}

#pragma mark - 调试和诊断工具

- (void)diagnoseDeviceSyncCapabilities {
    
    if (![self isConnected]) {
        [self logMessage:@"Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"✅" : @"❌";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount)
            };
        }
    }
    
    return info;
}

#pragma mark - 私有方法实现

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - 工具方法

- (void)logMessage:(NSString *)message {
    NSString *timestamp = [self getCurrentTimestamp];
    NSString *logMessage = [NSString stringWithFormat:@"[%@] [BackupOptionTask] %@", timestamp, message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}



// ✅ 格式化文件大小方法 - 如果不存在的话
- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}



// getDataItemsSimplified 方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"获取简化数据项 - 类型: %@, 同步类: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // 验证参数
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"同步类参数不能为空"];
        }
        return @[];
    }
    
    // 确保设备连接
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"设备未连接"];
        }
        return @[];
    }
    
    // ✅ 关键修复：移除重复的支持检查
    // 上层代码已经通过 getSupportedDataTypes 验证过支持性，避免重复检查导致状态冲突
    [self logMessage:[NSString stringWithFormat:@"跳过重复支持检查，直接获取 %@ 数据", syncClass]];
    
    // 直接调用数据获取方法
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"✅ 成功获取 %@ 数据: %lu 项",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"📋 %@ 数据为空或获取失败", syncClass]];
    }
    
    return items ?: @[];
}



@end


-------------------------------------

V1的代码：

//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Complete Enhanced Version with Photos/Camera Support - 2025.01.27
//  Based on libimobiledevice mobilesync and AFC APIs
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// 引入 libimobiledevice 相关头文件
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// 常量定义
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// 🆕 照片相关常量
NSString * const kPhotoLibraryPath = @"/DCIM";
NSString * const kCameraRollPath = @"/DCIM/100APPLE";
NSString * const kPhotoStreamPath = @"/PhotoData";
NSString * const kThumbnailsPath = @"/PhotoData/Thumbnails";

// 支持的照片格式
static NSArray *SupportedPhotoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEIF", @"HEIC", @"JPEG", @"JPG", @"PNG", @"GIF", @"TIFF", @"BMP"];
    });
    return formats;
}

// 支持的视频格式
static NSArray *SupportedVideoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEVC", @"H264", @"MP4", @"MOV", @"M4V", @"3GP"];
    });
    return formats;
}

// 基于实际iOS同步类的数据类型映射 - 完整版本
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            // 原有的同步类
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.Bookmarks",
            @(BackupDataTypeMailAccounts): @"com.apple.MailAccounts",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper",
            
            // 🆕 照片和媒体相关的同步类
            @(BackupDataTypePhotos): @"com.apple.Photos",
            @(BackupDataTypeVideos): @"com.apple.MediaAssets",
            @(BackupDataTypeCameraRoll): @"com.apple.CameraRoll",
            @(BackupDataTypePhotoAlbums): @"com.apple.PhotoAlbums",
            @(BackupDataTypePhotoStream): @"com.apple.PhotoStream",
            @(BackupDataTypeScreenshots): @"com.apple.Screenshots",
            @(BackupDataTypeSlowMotion): @"com.apple.SlowMotion",
            @(BackupDataTypeTimelapses): @"com.apple.Timelapses",
            @(BackupDataTypeBurstPhotos): @"com.apple.BurstPhotos",
            @(BackupDataTypeLivePhotos): @"com.apple.LivePhotos"
        };
    });
    return map;
}

// 🆕 照片路径映射
static NSDictionary *PhotoTypeToPathMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            @(BackupDataTypePhotos): @"/DCIM",
            @(BackupDataTypeVideos): @"/DCIM",
            @(BackupDataTypeCameraRoll): @"/DCIM/100APPLE",
            @(BackupDataTypePhotoAlbums): @"/PhotoData/Albums",
            @(BackupDataTypePhotoStream): @"/PhotoData/PhotoStream",
            @(BackupDataTypeScreenshots): @"/DCIM/Screenshots",
            @(BackupDataTypeSlowMotion): @"/DCIM/SlowMotion",
            @(BackupDataTypeTimelapses): @"/DCIM/Timelapses",
            @(BackupDataTypeBurstPhotos): @"/DCIM/Bursts",
            @(BackupDataTypeLivePhotos): @"/DCIM/LivePhotos"
        };
    });
    return map;
}

// 获取已知的同步类列表 - 用于检测支持的数据类型
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.Bookmarks",
            @"com.apple.MailAccounts",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - PhotoInfo 实现

@implementation PhotoInfo

- (instancetype)init {
    self = [super init];
    if (self) {
        _isVideo = NO;
        _isLivePhoto = NO;
        _isBurst = NO;
        _isScreenshot = NO;
        _isFavorite = NO;
        _videoDuration = 0;
        _width = 0;
        _height = 0;
        _fileSize = 0;
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<PhotoInfo: %@ (%@) - %lux%lu, %@ KB>",
            self.filename, self.format,
            (unsigned long)self.width, (unsigned long)self.height,
            @(self.fileSize / 1024)];
}

@end

#pragma mark - SyncDataItem 完整实现

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
        _isMediaFile = NO;
    }
    return self;
}

- (NSString *)description {
    if (self.isMediaFile && self.photoInfo) {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (Media: %@) - %@ records>",
                self.name, self.photoInfo.filename, @(self.recordCount)];
    } else {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
                self.name, self.identifier, @(self.recordCount)];
    }
}

@end

#pragma mark - BackupOptionTask 内部接口

// 在类的内部接口中添加线程安全队列
@interface BackupOptionTask () {
    // libimobiledevice C API 指针
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // 🆕 AFC 连接 - 用于文件传输
    afc_client_t _afc_photos;  // 专用于照片传输的AFC连接
    
    // 操作状态
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // 同步上下文
    dispatch_queue_t _operationQueue;
    dispatch_queue_t _photoQueue;  // 🆕 专用于照片操作的队列
    dispatch_queue_t _connectionQueue;  // 🆕 专用于连接操作的队列，确保线程安全
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;
    NSMutableDictionary *_photoCache; // 🆕 照片缓存
    
    // 当前操作参数
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // 内部状态
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
    
    // 🆕 照片相关状态
    NSUInteger _totalPhotosToProcess;
    NSUInteger _processedPhotos;
    NSUInteger _photoDownloadedBytes;
    NSUInteger _photoTotalBytes;
    
    // 🆕 线程安全标志
    NSRecursiveLock *_connectionLock;
}

// 私有方法声明
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// 🆕 AFC 服务相关方法
- (BOOL)startAFCService:(NSError **)error;
- (BOOL)startPhotoAFCService:(NSError **)error;
- (void)closeAFCServices;

// 🆕 照片扫描和处理方法
- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error;
- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                               afcClient:(afc_client_t)afcClient
                                   error:(NSError **)error;
- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath
                            afcClient:(afc_client_t)afcClient;
- (BOOL)isPhotoFile:(NSString *)filename;
- (BOOL)isVideoFile:(NSString *)filename;
- (NSString *)getFileExtension:(NSString *)filename;

// 真实数据处理方法
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// 🆕 照片数据处理方法
- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error;
- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType;
- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType;

// 数据获取方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// 同步操作方法
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// 🆕 照片特定的备份和恢复方法
- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;

// 验证和错误处理
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;
- (BOOL)ensureStableConnection:(NSError **)error;
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType;

// 🆕 照片相关验证方法
- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error;
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error;

// 工具方法
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;
- (NSString *)stringForPlistType:(plist_type)type;
- (NSString *)formatDuration:(NSTimeInterval)duration;

// 🆕 内部连接方法（不使用锁，避免递归锁）
- (BOOL)isConnectedInternal;
- (void)disconnectDeviceInternal;


- (NSString *)generateThumbnailPath:(NSString *)originalPath;
- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize;
- (void)checkDeviceCompatibilityForSync;
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType;
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType;

@end

#pragma mark - BackupOptionTask 完整实现

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;

#pragma mark - 单例和初始化

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _photoQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.photo", DISPATCH_QUEUE_CONCURRENT);
        _connectionQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.connection", DISPATCH_QUEUE_SERIAL);
        _connectionLock = [[NSRecursiveLock alloc] init];
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        _photoCache = [NSMutableDictionary dictionary];
        
        // 🆕 照片传输设置默认值
        _photoTransferMode = PhotoTransferModeOriginal;
        _enableThumbnailGeneration = YES;
        _maxPhotoResolution = 0; // 无限制
        _preserveOriginalFormat = YES;
        _includeHiddenPhotos = NO;
        _includeLivePhotos = YES;
        _includeVideoFiles = YES;
        
        // 设置默认数据存储路径
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        _totalPhotosToProcess = 0;
        _processedPhotos = 0;
        _photoDownloadedBytes = 0;
        _photoTotalBytes = 0;
        
        [self logMessage:[NSString stringWithFormat:@"Complete Enhanced BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}

//- (void)dealloc {
//    [self disconnectDevice];
//}

#pragma mark - 设备连接和查询

- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [_connectionLock lock];
    @try {
        [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
        
        if (!deviceUDID || deviceUDID.length == 0) {
            [self logMessage:@"[ERR] Device UDID cannot be empty"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                                 description:@"Device UDID cannot be empty"];
            }
            return NO;
        }
        
        // 如果已经连接到同一设备，检查连接状态
        if ([_deviceUDID isEqualToString:deviceUDID] && [self isConnectedInternal]) {
            [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@ (MobileSync: %@, AFC: %@)",
                             deviceUDID,
                             _mobilesync ? @"Yes" : @"No",
                             _afc ? @"Yes" : @"No"]];
            return YES;
        }
        
        // 安全地断开现有连接
        if (_device || _lockdown || _mobilesync || _afc) {
            [self logMessage:@"[WAR] Disconnecting existing connection before reconnecting"];
            [self disconnectDeviceInternal];
            // 短暂等待确保清理完成
            [NSThread sleepForTimeInterval:0.2];
        }
        
        _deviceUDID = [deviceUDID copy];
        return [self connectToDeviceInternal:deviceUDID error:error];
        
    } @finally {
        [_connectionLock unlock];
    }
}

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. 连接设备
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. 创建lockdown客户端
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        // 清理已创建的设备连接
        if (_device) {
            idevice_free(_device);
            _device = NULL;
        }
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // 3. 启动mobilesync服务 - 添加更详细的错误处理
    NSError *syncError = nil;
    if (![self startMobileSyncService:&syncError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] MobileSync service failed to start: %@", syncError.localizedDescription]];
        [self logMessage:@"Continuing without MobileSync - photo features will still work via AFC"];
        // 不要因为MobileSync失败就完全失败，因为AFC还可以工作
        // 清除错误以便继续
        if (error) *error = nil;
    } else {
        [self logMessage:@"MobileSync service started successfully"];
    }
    
    // 🆕 4. 启动AFC服务（用于文件传输）
    NSError *afcError = nil;
    if (![self startAFCService:&afcError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] AFC service failed to start: %@", afcError.localizedDescription]];
        [self logMessage:@"[WAR] Photo features will be limited without AFC"];
        // AFC失败也不完全失败，因为MobileSync还可以工作
    } else {
        [self logMessage:@"AFC service started successfully"];
    }
    
    // 🆕 5. 启动照片专用AFC服务
    NSError *photoAfcError = nil;
    if (![self startPhotoAFCService:&photoAfcError]) {
        [self logMessage:@"Photo AFC service not available, using regular AFC for photos"];
        // 这个失败是正常的，很多设备没有专用的AFC2服务
    } else {
        [self logMessage:@"Photo AFC service started successfully"];
    }
    
    // 只要有AFC或MobileSync其中之一成功，就认为连接成功
    BOOL hasWorkingService = (_mobilesync != NULL) || (_afc != NULL);
    
    if (hasWorkingService) {
        [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@ (MobileSync: %@, AFC: %@)",
                         deviceUDID,
                         _mobilesync ? @"Yes" : @"No",
                         _afc ? @"Yes" : @"No"]];
        [self setInternalStatus:SyncTaskStatusIdle];
        return YES;
    } else {
        [self logMessage:@"[ERR] Neither MobileSync nor AFC services are available"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                             description:@"Neither MobileSync nor AFC services could be started"];
        }
        // 完全清理连接
        [self disconnectDevice];
        return NO;
    }
}

// 🆕 启动AFC服务
- (BOOL)startAFCService:(NSError **)error {
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to start AFC service: %d", ldret]];
        }
        return NO;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to create AFC client: %d", afc_err]];
        }
        return NO;
    }
    
    [self logMessage:@"AFC service started successfully"];
    return YES;
}

// 🆕 启动照片专用AFC服务
- (BOOL)startPhotoAFCService:(NSError **)error {
    // 尝试启动照片专用的AFC服务
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc2", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        // 如果没有afc2，尝试使用普通的afc
        [self logMessage:@"AFC2 service not available, using regular AFC for photos"];
        _afc_photos = _afc; // 使用同一个AFC客户端
        return YES;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc_photos);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:@"Failed to create photo AFC client, using regular AFC"];
        _afc_photos = _afc; // 回退到普通AFC
        return YES;
    }
    
    [self logMessage:@"Photo AFC service started successfully"];
    return YES;
}

- (BOOL)startMobileSyncService:(NSError **)error {
    [self logMessage:@"Starting MobileSync service..."];
    
    int maxRetries = 3;
    int retryDelay = 1; // 减少延迟时间
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        [self logMessage:[NSString stringWithFormat:@"MobileSync service start attempt %d: lockdownd_start_service returned %d",
                         attempt + 1, ldret]];
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            [self logMessage:[NSString stringWithFormat:@"MobileSync service descriptor created successfully (port: %d)", service->port]];
            
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            [self logMessage:[NSString stringWithFormat:@"mobilesync_client_new returned %d", err]];
            
            if (err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:@"MobileSync client created successfully"];
                return YES;  // 成功
            } else {
                [self logMessage:[NSString stringWithFormat:@"[ERR] MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"[ERR] Failed to start MobileSync service (attempt %d): ldret=%d, service=%p, port=%d",
                             attempt + 1, ldret, service, service ? service->port : 0]];
            
            if (service) {
                lockdownd_service_descriptor_free(service);
            }
        }
        
        // 如果不是最后一次尝试，等待后重试
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Retrying MobileSync in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // 所有尝试都失败
    NSString *errorDesc = [NSString stringWithFormat:@"Failed to create MobileSync client after %d attempts", maxRetries];
    [self logMessage:[NSString stringWithFormat:@"[ERR] %@", errorDesc]];
    
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
    }
    return NO;
}

- (void)disconnectDevice {
    [_connectionLock lock];
    @try {
        [self disconnectDeviceInternal];
        [self logMessage:@"Device disconnection completed"];
    } @finally {
        [_connectionLock unlock];
    }
}

// 🆕 关闭AFC服务 - 增强版本，确保安全清理
- (void)closeAFCServices {
    // 清理照片专用AFC服务
    if (_afc_photos && _afc_photos != _afc) {
        @try {
            afc_client_free(_afc_photos);
            [self logMessage:@"Photo AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing photo AFC: %@", exception.reason]];
        }
        _afc_photos = NULL;
    }
    
    // 清理普通AFC服务
    if (_afc) {
        @try {
            afc_client_free(_afc);
            [self logMessage:@"AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing AFC: %@", exception.reason]];
        }
        _afc = NULL;
    }
    
    // 如果照片AFC指向普通AFC，也清空
    if (_afc_photos == _afc) {
        _afc_photos = NULL;
    }
}

- (BOOL)isConnected {
    [_connectionLock lock];
    @try {
        // 只要有设备连接和lockdown，并且至少有一个服务（MobileSync或AFC）可用就认为已连接
        BOOL connected = (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
        return connected;
    } @finally {
        [_connectionLock unlock];
    }
}

#pragma mark - 🆕 内部连接管理方法

// 🆕 内部连接检查方法（不使用锁）
- (BOOL)isConnectedInternal {
    return (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
}

// 🆕 内部断开连接方法（不使用锁）
- (void)disconnectDeviceInternal {
    [self logMessage:@"Internal disconnecting device..."];
    
    // 设置状态为空闲
    [self setInternalStatus:SyncTaskStatusIdle];
    
    // 🆕 关闭AFC服务 - 安全地清理
    [self closeAFCServices];
    
    // 清理MobileSync连接
    if (_mobilesync) {
        @try {
            mobilesync_finish(_mobilesync);
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception during mobilesync_finish: %@", exception.reason]];
        }
        
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [self logMessage:@"MobileSync client freed"];
    }
    
    // 清理通知代理
    if (_np) {
        np_client_free(_np);
        _np = NULL;
        [self logMessage:@"Notification proxy freed"];
    }
    
    // 清理lockdown连接
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
        [self logMessage:@"Lockdown client freed"];
    }
    
    // 清理设备连接
    if (_device) {
        idevice_free(_device);
        _device = NULL;
        [self logMessage:@"Device connection freed"];
    }
}

#pragma mark - 🆕 照片库访问功能

- (BOOL)checkPhotoLibraryAccess:(NSError **)error {
    [self logMessage:@"Checking photo library access"];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Device not connected"];
        }
        return NO;
    }
    
    if (!_afc && !_afc_photos) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // 测试访问DCIM目录
    afc_client_t afc_client = _afc_photos ?: _afc;
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, "/DCIM", &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        [self logMessage:@"Photo library access confirmed"];
        return YES;
    } else if (afc_err == AFC_E_READ_ERROR) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoLibraryLocked
                             description:@"Photo library is locked or access denied"];
        }
        return NO;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to access photo library: %d", afc_err]];
        }
        return NO;
    }
}

- (NSArray<PhotoInfo *> *)scanPhotoLibrary:(NSArray<NSString *> *)albumNames error:(NSError **)error {
    [self logMessage:@"Starting photo library scan"];
    
    if (![self checkPhotoLibraryAccess:error]) {
        return nil;
    }
    
    NSMutableArray<PhotoInfo *> *allPhotos = [NSMutableArray array];
    
    if (!albumNames || albumNames.count == 0) {
        // 扫描所有默认目录
        NSArray *defaultPaths = @[@"/DCIM/100APPLE", @"/DCIM/101APPLE", @"/DCIM/102APPLE"];
        
        for (NSString *path in defaultPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    } else {
        // 扫描指定相册
        for (NSString *albumName in albumNames) {
            NSString *albumPath = [NSString stringWithFormat:@"/PhotoData/Albums/%@", albumName];
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:albumPath recursive:YES error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo library scan completed: %lu photos found", (unsigned long)allPhotos.count]];
    return [allPhotos copy];
}

- (void)scanPhotoLibraryAsync:(NSArray<NSString *> *)albumNames
                     progress:(PhotoScanProgressCallback)progressCallback
                   completion:(PhotoCompletionCallback)completion {
    
    dispatch_async(_photoQueue, ^{
        NSError *error = nil;
        NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:albumNames error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(photos, error);
            }
        });
    });
}

- (NSDictionary *)getPhotoLibraryStatistics:(NSError **)error {
    [self logMessage:@"Getting photo library statistics"];
    
    NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:nil error:error];
    if (!photos) {
        return nil;
    }
    
    NSUInteger photoCount = 0;
    NSUInteger videoCount = 0;
    NSUInteger livePhotoCount = 0;
    NSUInteger burstCount = 0;
    NSUInteger screenshotCount = 0;
    NSUInteger totalSize = 0;
    
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (PhotoInfo *photo in photos) {
        if (photo.isVideo) {
            videoCount++;
        } else {
            photoCount++;
        }
        
        if (photo.isLivePhoto) livePhotoCount++;
        if (photo.isBurst) burstCount++;
        if (photo.isScreenshot) screenshotCount++;
        
        totalSize += photo.fileSize;
        
        if (!oldestDate || [photo.dateCreated compare:oldestDate] == NSOrderedAscending) {
            oldestDate = photo.dateCreated;
        }
        if (!newestDate || [photo.dateCreated compare:newestDate] == NSOrderedDescending) {
            newestDate = photo.dateCreated;
        }
    }
    
    return @{
        @"totalItems": @(photos.count),
        @"photoCount": @(photoCount),
        @"videoCount": @(videoCount),
        @"livePhotoCount": @(livePhotoCount),
        @"burstCount": @(burstCount),
        @"screenshotCount": @(screenshotCount),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"averageFileSize": @(photos.count > 0 ? totalSize / photos.count : 0)
    };
}

- (BOOL)downloadPhoto:(PhotoInfo *)photoInfo
        toDestination:(NSString *)destinationPath
                error:(NSError **)error {
    
    if (!photoInfo || !destinationPath) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo info or destination path cannot be nil"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Downloading photo: %@", photoInfo.filename]];
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // 构建设备上的完整路径
    NSString *devicePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // 打开设备上的文件
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afc_client, [devicePath UTF8String], AFC_FOPEN_RDONLY, &handle);
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to open photo file: %d", afc_err]];
        }
        return NO;
    }
    
    // 创建本地文件
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *destDir = [destinationPath stringByDeletingLastPathComponent];
    if (![fileManager fileExistsAtPath:destDir]) {
        [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    NSFileHandle *destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    if (!destFile) {
        [fileManager createFileAtPath:destinationPath contents:nil attributes:nil];
        destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    }
    
    if (!destFile) {
        afc_file_close(afc_client, handle);
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to create destination file"];
        }
        return NO;
    }
    
    // 读取并写入文件
    const uint32_t bufferSize = 65536; // 64KB buffer
    uint32_t bytesRead = 0;
    NSUInteger totalBytesRead = 0;
    
    do {
        char buffer[bufferSize];
        afc_err = afc_file_read(afc_client, handle, buffer, bufferSize, &bytesRead);
        
        if (afc_err == AFC_E_SUCCESS && bytesRead > 0) {
            NSData *data = [NSData dataWithBytes:buffer length:bytesRead];
            [destFile writeData:data];
            totalBytesRead += bytesRead;
            
            // 报告进度
            if (self.photoDownloadCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.photoDownloadCallback(photoInfo.filename, totalBytesRead, photoInfo.fileSize);
                });
            }
        }
    } while (afc_err == AFC_E_SUCCESS && bytesRead > 0);
    
    [destFile closeFile];
    afc_file_close(afc_client, handle);
    
    if (afc_err == AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Successfully downloaded photo: %@ (%lu bytes)",
                         photoInfo.filename, (unsigned long)totalBytesRead]];
        return YES;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to read photo data: %d", afc_err]];
        }
        return NO;
    }
}

- (void)downloadPhotos:(NSArray<PhotoInfo *> *)photos
      toDestinationDir:(NSString *)destinationDir
              progress:(PhotoDownloadProgressCallback)progressCallback
            completion:(void (^)(NSUInteger successCount, NSUInteger failedCount, NSError *error))completion {
    
    dispatch_async(_photoQueue, ^{
        NSUInteger successCount = 0;
        NSUInteger failedCount = 0;
        NSError *lastError = nil;
        
        for (NSUInteger i = 0; i < photos.count; i++) {
            if (self->_cancelRequested) {
                break;
            }
            
            PhotoInfo *photo = photos[i];
            NSString *destPath = [destinationDir stringByAppendingPathComponent:photo.filename];
            
            NSError *downloadError = nil;
            BOOL success = [self downloadPhoto:photo toDestination:destPath error:&downloadError];
            
            if (success) {
                successCount++;
            } else {
                failedCount++;
                lastError = downloadError;
            }
            
            // 报告总体进度
            if (progressCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    progressCallback(photo.filename, i + 1, photos.count);
                });
            }
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(successCount, failedCount, lastError);
            }
        });
    });
}

#pragma mark - 🆕 照片扫描和处理实现

- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error {
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return @[];
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Failed to read directory %@: %d", directory, afc_err]];
        return @[];
    }
    
    NSMutableArray<PhotoInfo *> *photos = [NSMutableArray array];
    
    if (dir_list) {
        for (int i = 0; dir_list[i] != NULL; i++) {
            NSString *filename = [NSString stringWithUTF8String:dir_list[i]];
            
            // 跳过隐藏文件和目录
            if ([filename hasPrefix:@"."]) continue;
            
            NSString *fullPath = [directory stringByAppendingPathComponent:filename];
            
            // 检查是否是照片或视频文件
            if ([self isPhotoFile:filename] || [self isVideoFile:filename]) {
                PhotoInfo *photoInfo = [self createPhotoInfoFromPath:fullPath
                                                           afcClient:afc_client
                                                               error:nil];
                if (photoInfo) {
                    [photos addObject:photoInfo];
                }
            } else if (recursive) {
                // 递归扫描子目录
                char **subdir_info = NULL;
                afc_err = afc_get_file_info(afc_client, [fullPath UTF8String], &subdir_info);
                
                if (afc_err == AFC_E_SUCCESS && subdir_info) {
                    // 检查是否是目录
                    for (int j = 0; subdir_info[j] != NULL; j += 2) {
                        if (strcmp(subdir_info[j], "st_ifmt") == 0) {
                            if (strcmp(subdir_info[j + 1], "S_IFDIR") == 0) {
                                NSArray<PhotoInfo *> *subdirPhotos = [self scanPhotosInDirectory:fullPath
                                                                                     recursive:recursive
                                                                                         error:nil];
                                if (subdirPhotos) {
                                    [photos addObjectsFromArray:subdirPhotos];
                                }
                            }
                            break;
                        }
                    }
                    afc_dictionary_free(subdir_info);
                }
            }
        }
        afc_dictionary_free(dir_list);
    }
    
    [self logMessage:[NSString stringWithFormat:@"Found %lu photos in directory: %@",
                     (unsigned long)photos.count, directory]];
    return [photos copy];
}

- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                             afcClient:(afc_client_t)afcClient
                                 error:(NSError **)error {
    
    PhotoInfo *photoInfo = [[PhotoInfo alloc] init];
    photoInfo.filename = [photoPath lastPathComponent];
    photoInfo.format = [[self getFileExtension:photoInfo.filename] uppercaseString];
    photoInfo.isVideo = [self isVideoFile:photoInfo.filename];
    
    // 获取文件信息
    char **file_info = NULL;
    afc_error_t afc_err = afc_get_file_info(afcClient, [photoPath UTF8String], &file_info);
    
    if (afc_err == AFC_E_SUCCESS && file_info) {
        for (int i = 0; file_info[i] != NULL; i += 2) {
            NSString *key = [NSString stringWithUTF8String:file_info[i]];
            NSString *value = [NSString stringWithUTF8String:file_info[i + 1]];
            
            if ([key isEqualToString:@"st_size"]) {
                // 使用安全的转换方法
                photoInfo.fileSize = [self unsignedLongLongValueFromString:value];
            } else if ([key isEqualToString:@"st_mtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateModified = [NSDate dateWithTimeIntervalSince1970:timestamp];
            } else if ([key isEqualToString:@"st_birthtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateCreated = [NSDate dateWithTimeIntervalSince1970:timestamp];
            }
        }
        afc_dictionary_free(file_info);
    } else {
        [self logMessage:[NSString stringWithFormat:@"Failed to get file info for %@: %d", photoPath, afc_err]];
    }
    
    // 设置默认值
    if (!photoInfo.dateCreated) {
        photoInfo.dateCreated = photoInfo.dateModified ?: [NSDate date];
    }
    if (!photoInfo.dateModified) {
        photoInfo.dateModified = photoInfo.dateCreated;
    }
    
    // 生成唯一ID
    photoInfo.photoID = [NSString stringWithFormat:@"%@_%lu",
                        [[photoInfo.filename stringByDeletingPathExtension]
                         stringByReplacingOccurrencesOfString:@" " withString:@"_"],
                        (unsigned long)[photoInfo.dateCreated timeIntervalSince1970]];
    
    // 检测特殊类型
    NSString *lowercaseFilename = [photoInfo.filename lowercaseString];
    photoInfo.isLivePhoto = [lowercaseFilename containsString:@"live"];
    photoInfo.isBurst = [lowercaseFilename containsString:@"burst"];
    photoInfo.isScreenshot = [lowercaseFilename hasPrefix:@"img_"] && [lowercaseFilename containsString:@"screenshot"];
    
    // 尝试提取EXIF数据（简化版本）
    if (!photoInfo.isVideo) {
        photoInfo.exifData = [self extractEXIFFromPath:photoPath afcClient:afcClient];
        
        // 从EXIF提取尺寸信息
        if (photoInfo.exifData) {
            NSNumber *width = photoInfo.exifData[@"PixelXDimension"];
            NSNumber *height = photoInfo.exifData[@"PixelYDimension"];
            if (width && height) {
                photoInfo.width = [width unsignedIntegerValue];
                photoInfo.height = [height unsignedIntegerValue];
            }
        }
    }
    
    return photoInfo;
}

- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath afcClient:(afc_client_t)afcClient {
    // 这是一个简化的EXIF提取实现
    // 在真实实现中，你需要一个完整的EXIF解析库
    
    // 读取文件的前几个字节来检测格式和基本信息
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afcClient, [photoPath UTF8String], AFC_FOPEN_RDONLY, &handle);
    
    if (afc_err != AFC_E_SUCCESS) {
        return nil;
    }
    
    char header[1024];
    uint32_t bytesRead = 0;
    afc_err = afc_file_read(afcClient, handle, header, sizeof(header), &bytesRead);
    afc_file_close(afcClient, handle);
    
    if (afc_err != AFC_E_SUCCESS || bytesRead < 10) {
        return nil;
    }
    
    NSMutableDictionary *exifData = [NSMutableDictionary dictionary];
    
    // 检测JPEG格式
    if (bytesRead >= 2 && header[0] == (char)0xFF && header[1] == (char)0xD8) {
        exifData[@"Format"] = @"JPEG";
        // 这里可以添加更复杂的EXIF解析逻辑
    }
    // 检测HEIF格式
    else if (bytesRead >= 8 && strncmp(&header[4], "ftyp", 4) == 0) {
        exifData[@"Format"] = @"HEIF";
    }
    // 检测PNG格式
    else if (bytesRead >= 8 && strncmp(header, "\x89PNG\r\n\x1a\n", 8) == 0) {
        exifData[@"Format"] = @"PNG";
    }
    
    // 添加基本信息
    exifData[@"FileSize"] = @(photoPath.length);
    exifData[@"ExtractedAt"] = [NSDate date];
    
    return [exifData copy];
}

- (BOOL)isPhotoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedPhotoFormats() containsObject:extension];
}

- (BOOL)isVideoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedVideoFormats() containsObject:extension];
}

- (NSString *)getFileExtension:(NSString *)filename {
    return [[filename pathExtension] uppercaseString];
}

#pragma mark - 数据查询增强

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // 🆕 检查是否是照片/媒体类型
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self processPhotoDataForType:dataType error:error];
    }
    
    // 检查缓存
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // 使用真实的数据获取方法
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // 缓存结果
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - 🆕 照片数据处理方法

- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Processing photo data for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // 检查照片缓存
    NSString *cacheKey = [NSString stringWithFormat:@"photo_datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _photoCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached photo items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    // 根据数据类型确定扫描路径
    NSString *scanPath = PhotoTypeToPathMap()[@(dataType)];
    if (!scanPath) {
        scanPath = @"/DCIM"; // 默认路径
    }
    
    // 扫描照片
    NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:scanPath recursive:YES error:error];
    if (!photos) {
        return @[];
    }
    
    // 根据数据类型过滤照片
    NSPredicate *filter = [self createFilterPredicateForDataType:dataType];
    if (filter) {
        photos = [photos filteredArrayUsingPredicate:filter];
    }
    
    // 转换为SyncDataItem
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    for (PhotoInfo *photo in photos) {
        SyncDataItem *item = [self createSyncItemFromPhotoInfo:photo dataType:dataType];
        if (item) {
            [items addObject:item];
        }
    }
    
    // 缓存结果
    _photoCache[cacheKey] = items;
    
    [self logMessage:[NSString stringWithFormat:@"Processed %lu photo items for type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return [items copy];
}

- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypePhotos:
            return [NSPredicate predicateWithFormat:@"isVideo == NO"];
        case BackupDataTypeVideos:
            return [NSPredicate predicateWithFormat:@"isVideo == YES"];
        case BackupDataTypeScreenshots:
            return [NSPredicate predicateWithFormat:@"isScreenshot == YES"];
        case BackupDataTypeLivePhotos:
            return [NSPredicate predicateWithFormat:@"isLivePhoto == YES"];
        case BackupDataTypeBurstPhotos:
            return [NSPredicate predicateWithFormat:@"isBurst == YES"];
        default:
            return nil; // 无过滤器，返回所有照片
    }
}

- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    
    item.identifier = photoInfo.photoID;
    item.name = photoInfo.filename;
    item.dataType = dataType;
    item.modificationDate = photoInfo.dateModified;
    item.recordCount = 1;
    item.dataSize = photoInfo.fileSize;
    item.isSelected = NO;
    item.isMediaFile = YES;
    item.photoInfo = photoInfo;
    
    // 设置远程路径
    item.remotePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // 创建元数据
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    metadata[@"isPhoto"] = @(!photoInfo.isVideo);
    metadata[@"isVideo"] = @(photoInfo.isVideo);
    metadata[@"format"] = photoInfo.format ?: @"Unknown";
    metadata[@"fileSize"] = @(photoInfo.fileSize);
    metadata[@"formattedSize"] = [self formatFileSize:photoInfo.fileSize];
    
    if (photoInfo.width > 0 && photoInfo.height > 0) {
        metadata[@"dimensions"] = [NSString stringWithFormat:@"%lux%lu",
                                  (unsigned long)photoInfo.width, (unsigned long)photoInfo.height];
        metadata[@"width"] = @(photoInfo.width);
        metadata[@"height"] = @(photoInfo.height);
        metadata[@"megapixels"] = @((photoInfo.width * photoInfo.height) / 1000000.0);
    }
    
    if (photoInfo.isVideo && photoInfo.videoDuration > 0) {
        metadata[@"duration"] = @(photoInfo.videoDuration);
        metadata[@"formattedDuration"] = [self formatDuration:photoInfo.videoDuration];
    }
    
    if (photoInfo.isLivePhoto) metadata[@"isLivePhoto"] = @YES;
    if (photoInfo.isBurst) metadata[@"isBurst"] = @YES;
    if (photoInfo.isScreenshot) metadata[@"isScreenshot"] = @YES;
    if (photoInfo.isFavorite) metadata[@"isFavorite"] = @YES;
    
    item.metadata = [metadata copy];
    
    return item;
}

- (NSString *)formatDuration:(NSTimeInterval)duration {
    NSInteger hours = (NSInteger)duration / 3600;
    NSInteger minutes = ((NSInteger)duration % 3600) / 60;
    NSInteger seconds = (NSInteger)duration % 60;
    
    if (hours > 0) {
        return [NSString stringWithFormat:@"%ld:%02ld:%02ld", (long)hours, (long)minutes, (long)seconds];
    } else {
        return [NSString stringWithFormat:@"%ld:%02ld", (long)minutes, (long)seconds];
    }
}

#pragma mark - 获取支持的数据类型

- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    [self logMessage:@"Getting supported data types with enhanced stability (including photos)"];
    
    if (![self isConnected]) {
        [self logMessage:@"[ERR] Device not connected"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // ✅ 使用缓存机制避免重复检测
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    
    // 检查缓存是否有效（5分钟内且同一设备）
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                         (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // 📊 开始检测支持的数据类型
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    [self logMessage:[NSString stringWithFormat:@"Checking %lu data types for support...", (unsigned long)totalCount]];
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        BOOL isSupported = NO;
        
        // 🆕 照片类型使用AFC检查，其他类型使用MobileSync检查
        if ([BackupOptionTask isPhotoMediaType:dataType]) {
            // 照片类型：检查AFC访问能力
            if (_afc || _afc_photos) {
                NSString *testPath = PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM";
                isSupported = [self canAccessPhotoDirectory:testPath error:nil];
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ test (path: %@): %@",
                                 typeName, testPath, isSupported ? @"✅ Supported" : @"❌ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ skipped: AFC not available", typeName]];
                isSupported = NO;
            }
        } else {
            // 非照片类型：使用MobileSync检查（如果可用）
            if (_mobilesync) {
                isSupported = [self isDataTypeSupportedStable:dataType];
                [self logMessage:[NSString stringWithFormat:@"Data type %@ test: %@",
                                 typeName, isSupported ? @"✅ Supported" : @"❌ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Data type %@ skipped: MobileSync not available", typeName]];
                isSupported = NO;
            }
        }
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
        }
        
        // 添加小延迟避免过度请求
        if (typeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.05];  // 减少延迟时间
        }
    }
    
    // 更新缓存
    if (successCount > 0) {
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cacheTime = [NSDate date];
        
        [self logMessage:[NSString stringWithFormat:@"Detection complete: %lu/%lu data types supported (cached for 5 minutes)",
                         (unsigned long)successCount, (unsigned long)totalCount]];
    } else {
        [self logMessage:@"[WAR] No data types detected as supported"];
    }
    
    return supportedTypes;
}

// 🆕 检查照片目录访问能力
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error {
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        return NO;
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        return YES;
    }
    
    return NO;
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    // 🆕 照片类型使用AFC检查
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self canAccessPhotoDirectory:PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM" error:nil];
    }
    
    @try {
        // 使用正确的API创建anchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // 准备正确的参数
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // 正确调用mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // 如果成功启动，需要结束会话
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

// ✅ 新增：稳定的数据类型检测方法（保持原有逻辑）
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    // ✅ 添加连接检查
    if (!_mobilesync) {
        [self logMessage:@"MobileSync未连接，跳过检测"];
        return NO;
    }
    
    @try {
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // ✅ 重要：立即结束会话，避免状态残留
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // ✅ 每次检测后休息，避免设备过载
        [NSThread sleepForTimeInterval:0.2];
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"检测异常: %@", exception.reason]];
        return NO;
    }
}

// ✅ 新增：确保稳定连接方法（保持原有逻辑但避免过度重连）
- (BOOL)ensureStableConnection:(NSError **)error {
    // 检查连接状态
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            [self logMessage:@"[ERR] No device UDID for reconnection"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // 重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // ✅ 简化连接质量检查，避免不必要的重连
    if (_lockdown) {
        // 只做简单的连接测试，不要过度检查
        [self logMessage:@"Connection appears stable"];
        return YES;
    }
    
    [self logMessage:@"[WAR] Connection quality check failed, but not attempting risky reconnection"];
    return YES; // 返回YES避免触发重连循环
}

#pragma mark - 扫描设备数据增强版

- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== 🔧 开始增强版设备真实数据扫描（包含照片）===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // ✅ 首先获取支持的数据类型
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"[WAR] 获取支持的数据类型失败: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"[WAR] 设备不支持任何数据类型的选择性同步");
        return @{};
    }
    
    NSLog(@"设备支持的数据类型掩码: %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // 逐个处理支持的数据类型
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // 只处理设备支持的数据类型
        if (!(supportedTypes & dataType)) {
            NSLog(@"跳过不支持的数据类型: %@", typeName);
            continue;
        }
        
        NSLog(@"正在获取 %@ 的真实数据...", typeName);
        
        // ✅ 使用改进的数据获取方法
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"%@ 支持但无数据: %@ 项", typeName, itemCount);
            } else {
                NSLog(@"%@ 获取成功: %@ 项", typeName, itemCount);
            }
        } else {
            NSLog(@"[WAR] %@ 获取失败或无响应", typeName);
        }
        
        // 添加延迟避免过度请求
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== 🔧 增强版数据扫描完成，共处理 %lu 种数据类型（包含照片）===",
          (unsigned long)realData.count);
    return [realData copy];
}

// ✅ 增强的数据获取方法
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"增强方法获取 %@ 的真实数据", typeName);
    
    // ✅ 连接状态检查
    if (![self isConnected]) {
        NSLog(@"[WAR] 设备未连接，无法获取 %@ 数据", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // 🆕 根据数据类型选择获取方法
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        // 照片类型：使用AFC方法
        items = [self processPhotoDataForType:dataType error:&error];
    } else {
        // 非照片类型：使用MobileSync方法
        int maxAttempts = 3;
        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            if (attempt > 0) {
                NSLog(@"重试获取 %@ 数据 (第 %d 次尝试)", typeName, attempt + 1);
                [NSThread sleepForTimeInterval:0.5];
            }
            
            items = [self getDataItemsForType:dataType error:&error];
            
            if (items && items.count > 0) {
                NSLog(@"第 %d 次尝试成功获取 %@ 数据: %lu 项",
                      attempt + 1, typeName, (unsigned long)items.count);
                break;
            }
            
            if (error) {
                NSLog(@"[WAR] 第 %d 次尝试获取 %@ 数据失败: %@",
                      attempt + 1, typeName, error.localizedDescription);
                error = nil; // 清除错误以便下次尝试
            }
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"[WAR] %@ 最终无法获取到数据", typeName);
    return nil;
}

// ✅ 新增：改进的数据处理方法，更好地处理空数据情况
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"%@ 数据为空，创建空数据字典", typeName]];
        
        // ✅ 即使没有数据也创建一个有效的字典
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ 支持但当前无数据", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // 计算统计信息
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

#pragma mark - 🆕 数据类型工具方法增强

+ (BOOL)isPhotoMediaType:(BackupDataType)dataType {
    BackupDataType photoTypes = (BackupDataTypePhotos | BackupDataTypeVideos | BackupDataTypeCameraRoll |
                                BackupDataTypePhotoAlbums | BackupDataTypePhotoStream | BackupDataTypeScreenshots |
                                BackupDataTypeSlowMotion | BackupDataTypeTimelapses | BackupDataTypeBurstPhotos |
                                BackupDataTypeLivePhotos);
    return (dataType & photoTypes) != 0;
}

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeMailAccounts:
            return @"MailAccounts";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
            
        // 🆕 照片和媒体类型
        case BackupDataTypePhotos:
            return @"Photos";
        case BackupDataTypeVideos:
            return @"Videos";
        case BackupDataTypeCameraRoll:
            return @"Camera Roll";
        case BackupDataTypePhotoAlbums:
            return @"Photo Albums";
        case BackupDataTypePhotoStream:
            return @"Photo Stream";
        case BackupDataTypeScreenshots:
            return @"Screenshots";
        case BackupDataTypeSlowMotion:
            return @"Slow Motion";
        case BackupDataTypeTimelapses:
            return @"Time-lapses";
        case BackupDataTypeBurstPhotos:
            return @"Burst Photos";
        case BackupDataTypeLivePhotos:
            return @"Live Photos";
            
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // 这里可以根据需要添加本地化支持
    // 目前返回英文版本
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeMailAccounts) [array addObject:@(BackupDataTypeMailAccounts)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    // 🆕 照片和媒体类型
    if (dataTypes & BackupDataTypePhotos) [array addObject:@(BackupDataTypePhotos)];
    if (dataTypes & BackupDataTypeVideos) [array addObject:@(BackupDataTypeVideos)];
    if (dataTypes & BackupDataTypeCameraRoll) [array addObject:@(BackupDataTypeCameraRoll)];
    if (dataTypes & BackupDataTypePhotoAlbums) [array addObject:@(BackupDataTypePhotoAlbums)];
    if (dataTypes & BackupDataTypePhotoStream) [array addObject:@(BackupDataTypePhotoStream)];
    if (dataTypes & BackupDataTypeScreenshots) [array addObject:@(BackupDataTypeScreenshots)];
    if (dataTypes & BackupDataTypeSlowMotion) [array addObject:@(BackupDataTypeSlowMotion)];
    if (dataTypes & BackupDataTypeTimelapses) [array addObject:@(BackupDataTypeTimelapses)];
    if (dataTypes & BackupDataTypeBurstPhotos) [array addObject:@(BackupDataTypeBurstPhotos)];
    if (dataTypes & BackupDataTypeLivePhotos) [array addObject:@(BackupDataTypeLivePhotos)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        // 原有数据类型
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper),
        
        // 🆕 新增照片和媒体类型
        @(BackupDataTypePhotos),
        @(BackupDataTypeVideos),
        @(BackupDataTypeCameraRoll),
        @(BackupDataTypePhotoAlbums),
        @(BackupDataTypePhotoStream),
        @(BackupDataTypeScreenshots),
        @(BackupDataTypeSlowMotion),
        @(BackupDataTypeTimelapses),
        @(BackupDataTypeBurstPhotos),
        @(BackupDataTypeLivePhotos)
    ];
}

#pragma mark - 选择性同步操作

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // 异步执行同步操作
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // 分解数据类型为单独的类型
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // 按数据类型分组
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // 对每种数据类型执行同步
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // 这里可以实现更细粒度的项目同步逻辑
        // 目前先使用数据类型级别的同步
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // 创建备份目录
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - 操作控制

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - 同步操作实现

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // 根据方向执行不同的操作
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // 双向同步暂时不实现
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 🆕 检查是否是照片类型，使用不同的备份方法
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self backupPhotoDataType:dataType toPath:path error:error];
    }
    
    // 获取数据项
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // 创建数据类型目录
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // 保存数据项信息
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // 保存备份元数据
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 🆕 检查是否是照片类型，使用不同的恢复方法
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self restorePhotoDataType:dataType fromPath:path error:error];
    }
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - 🆕 照片特定的备份和恢复方法

- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up photo data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 获取照片数据项
    NSArray<SyncDataItem *> *items = [self processPhotoDataForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // 创建数据类型目录
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // 创建照片子目录
    NSString *photosDir = [dataTypeDir stringByAppendingPathComponent:@"Media"];
    NSString *thumbnailsDir = [dataTypeDir stringByAppendingPathComponent:@"Thumbnails"];
    
    [fileManager createDirectoryAtPath:photosDir withIntermediateDirectories:YES attributes:nil error:nil];
    if (self.enableThumbnailGeneration) {
        [fileManager createDirectoryAtPath:thumbnailsDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    // 下载照片文件
    NSUInteger successCount = 0;
    NSUInteger totalCount = items.count;
    
    for (NSUInteger i = 0; i < items.count; i++) {
        if (_cancelRequested) {
            break;
        }
        
        SyncDataItem *item = items[i];
        if (!item.isMediaFile || !item.photoInfo) {
            continue;
        }
        
        // 更新进度
        [self updateProgress:(i * 100.0 / totalCount)
                   operation:[NSString stringWithFormat:@"Downloading %@", item.photoInfo.filename]
                     current:i
                       total:totalCount];
        
        // 下载原始文件
        NSString *destPath = [photosDir stringByAppendingPathComponent:item.photoInfo.filename];
        NSError *downloadError = nil;
        BOOL success = [self downloadPhoto:item.photoInfo toDestination:destPath error:&downloadError];
        
        if (success) {
            successCount++;
            item.localPath = destPath;
            
            // 生成缩略图
            if (self.enableThumbnailGeneration && !item.photoInfo.isVideo) {
                NSString *thumbnailPath = [self generateThumbnailPath:destPath];
                [self createThumbnail:destPath destinationPath:thumbnailPath maxSize:200];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"Failed to download %@: %@",
                             item.photoInfo.filename, downloadError.localizedDescription]];
        }
    }
    
    // 保存照片项信息
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"isMediaFile": @(item.isMediaFile),
            @"localPath": item.localPath ?: @"",
            @"remotePath": item.remotePath ?: @"",
            @"metadata": item.metadata ?: @{},
            @"photoInfo": item.photoInfo ? @{
                @"filename": item.photoInfo.filename ?: @"",
                @"photoID": item.photoInfo.photoID ?: @"",
                @"format": item.photoInfo.format ?: @"",
                @"fileSize": @(item.photoInfo.fileSize),
                @"width": @(item.photoInfo.width),
                @"height": @(item.photoInfo.height),
                @"isVideo": @(item.photoInfo.isVideo),
                @"isLivePhoto": @(item.photoInfo.isLivePhoto),
                @"isBurst": @(item.photoInfo.isBurst),
                @"isScreenshot": @(item.photoInfo.isScreenshot),
                @"isFavorite": @(item.photoInfo.isFavorite),
                @"dateCreated": item.photoInfo.dateCreated ?: [NSDate date],
                @"dateModified": item.photoInfo.dateModified ?: [NSDate date]
            } : @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save photo items data"];
        }
        return NO;
    }
    
    // 保存备份元数据
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"successCount": @(successCount),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown",
        @"photoTransferMode": @(self.photoTransferMode),
        @"includeThumbnails": @(self.enableThumbnailGeneration),
        @"preserveOriginalFormat": @(self.preserveOriginalFormat)
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu/%lu photos of type: %@",
                     (unsigned long)successCount, (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    
    return successCount > 0;
}

- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring photo data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Photo backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Photo backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo restore not yet implemented for %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // TODO: 实现照片上传到设备的功能
    // 这需要使用AFC写入文件到设备的/DCIM目录
    
    return YES;
}

#pragma mark - 便捷方法

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *mailAccountsPath = [_dataStoragePath stringByAppendingPathComponent:@"MailAccounts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeMailAccounts
                                     toDirectory:mailAccountsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupPhotos:(PhotoTransferMode)transferMode
               completion:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *photosPath = [_dataStoragePath stringByAppendingPathComponent:@"Photos"];
    
    // 设置传输模式
    self.photoTransferMode = transferMode;
    
    // 开始备份
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypePhotos
                                     toDirectory:photosPath
                                           error:&error];
    
    if (completion) {
        // 获取照片数量
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypePhotos error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupCameraRoll:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *cameraRollPath = [_dataStoragePath stringByAppendingPathComponent:@"CameraRoll"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCameraRoll
                                     toDirectory:cameraRollPath
                                           error:&error];
    
    if (completion) {
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypeCameraRoll error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // 设置完成回调来捕获结果
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - 数据验证和恢复

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // 尝试读取文件以验证格式
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // 参数验证
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查路径是否存在
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // 确保是目录而不是文件
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // 获取基本信息 - 添加错误处理
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // 设置默认值
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // 扫描数据类型
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // 自动释放池，避免内存累积
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // 检查items.plist是否存在
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // 尝试读取items数据
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // 计算该数据类型的大小
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // 设置汇总信息
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // 添加备份统计信息
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - 调试和诊断工具

- (void)diagnoseDeviceSyncCapabilities {
    
    if (![self isConnected]) {
        [self logMessage:@"Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"✅" : @"❌";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    info[@"isPhotoMediaType"] = @([BackupOptionTask isPhotoMediaType:dataType]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount),
                @"isMediaFile": @(firstItem.isMediaFile)
            };
        }
    }
    
    return info;
}

- (void)diagnosePhotoLibraryAccess {
    [self logMessage:@"=== Photo Library Access Diagnosis ==="];
    
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Device not connected"];
        return;
    }
    
    // 检查AFC服务
    if (!_afc) {
        [self logMessage:@"[WAR] AFC service not available"];
    } else {
        [self logMessage:@"AFC service available"];
    }
    
    if (!_afc_photos) {
        [self logMessage:@"[WAR] Photo AFC service not available, using regular AFC"];
    } else if (_afc_photos == _afc) {
        [self logMessage:@"Using regular AFC for photo access"];
    } else {
        [self logMessage:@"Dedicated photo AFC service available"];
    }
    
    // 测试DCIM目录访问
    NSError *error = nil;
    BOOL hasAccess = [self checkPhotoLibraryAccess:&error];
    
    if (hasAccess) {
        [self logMessage:@"Photo library access confirmed"];
        
        // 扫描各个照片目录
        NSArray *testPaths = @[@"/DCIM", @"/DCIM/100APPLE", @"/PhotoData"];
        
        for (NSString *path in testPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            [self logMessage:[NSString stringWithFormat:@"%@: %lu items", path, (unsigned long)photos.count]];
        }
        
        // 获取统计信息
        NSDictionary *stats = [self getPhotoLibraryStatistics:nil];
        if (stats) {
            [self logMessage:[NSString stringWithFormat:@"Total photos: %@", stats[@"photoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total videos: %@", stats[@"videoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total size: %@", stats[@"formattedSize"]]];
        }
        
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] Photo library access failed: %@", error.localizedDescription]];
    }
    
    [self logMessage:@"=== Photo Library Diagnosis Complete ==="];
}

#pragma mark - 真实数据处理方法实现

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 处理非数组类型的情况
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 返回非数组数据，可能表示空数据集", syncClass]];
        
        // 如果是布尔类型，可能表示同步状态
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ 同步状态: %s",
                             syncClass, bool_val ? "成功" : "失败"]];
        }
        
        return @[]; // 返回空数组而不是失败
    }
    
    // 继续处理数组数据...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // 提取通用字段
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // 根据数据类型提取特定字段
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeMailAccounts:
            [self extractMailAccountSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // 如果没有标识符，使用索引
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // 如果没有名称，使用默认名称
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // 提取记录ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // 提取修改时间
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // 估算数据大小
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // 默认大小
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 姓名字段
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 电话号码
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // 邮箱地址
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 日历标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 开始时间
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // 结束时间
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 书签标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 账户名称
    plist_t account_name = plist_dict_get_item(item_dict, "AccountName");
    if (!account_name) account_name = plist_dict_get_item(item_dict, "EmailAddress");
    
    if (account_name && plist_get_node_type(account_name) == PLIST_STRING) {
        char *name_str = NULL;
        plist_get_string_val(account_name, &name_str);
        if (name_str) {
            item.name = [NSString stringWithUTF8String:name_str];
            free(name_str);
        }
    }
    
    // 服务器信息
    plist_t hostname = plist_dict_get_item(item_dict, "Hostname");
    if (hostname && plist_get_node_type(hostname) == PLIST_STRING) {
        char *host_str = NULL;
        plist_get_string_val(hostname, &host_str);
        if (host_str) {
            metadata[@"hostname"] = [NSString stringWithUTF8String:host_str];
            free(host_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 备忘录标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 内容
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // 大概估算
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 提醒事项标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 完成状态
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // 优先级
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 尝试各种可能的名称字段
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 添加一些通用元数据
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

// getDataItemsSimplified 方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"获取简化数据项 - 类型: %@, 同步类: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // 验证参数
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"同步类参数不能为空"];
        }
        return @[];
    }
    
    // 确保设备连接
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"设备未连接"];
        }
        return @[];
    }
    
    // ✅ 关键修复：移除重复的支持检查
    // 上层代码已经通过 getSupportedDataTypes 验证过支持性，避免重复检查导致状态冲突
    [self logMessage:[NSString stringWithFormat:@"跳过重复支持检查，直接获取 %@ 数据", syncClass]];
    
    // 直接调用数据获取方法
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"成功获取 %@ 数据: %lu 项",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"%@ 数据为空或获取失败", syncClass]];
    }
    
    return items ?: @[];
}

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"使用修复版获取 %@ 数据", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // 添加设备兼容性检查
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // ✅ 关键修复：每次数据获取前都重新建立 MobileSync 连接
        [self logMessage:@"重新建立 MobileSync 连接以确保数据获取稳定性"];
        
        // 强制断开并重建 MobileSync 连接
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // 短暂等待，让设备重置状态
        [NSThread sleepForTimeInterval:0.5];
        
        // 重新启动 MobileSync 服务
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] 重新启动 MobileSync 服务失败: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"MobileSync 连接已重新建立"];
        
        // ✅ 关键修复2：使用与检测时相同的参数
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"[ERR] 创建anchors失败"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // ✅ 关键修复3：使用检测时完全相同的参数
        uint64_t data_class_version = 106;  // 与检测时保持一致
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"使用干净连接启动同步会话: %@", syncClass]];
        
        // ✅ 关键修复4：启动同步会话
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"%@ 同步会话启动成功（干净连接）", syncClass]];
            
            // ✅ 使用更稳定的数据获取方法
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"成功请求 %@ 的所有记录", syncClass]];
                
                // ✅ 改进的数据接收逻辑 - 处理超时和多批次数据
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // 减少最大批次数量
                int timeoutCount = 0;
                int maxTimeouts = 2; // 允许的最大超时次数
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"mobilesync_receive_changes 返回状态: %d (批次 %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // 重置超时计数器
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"处理 %@ 第 %d 批数据",
                                            syncClass, batchCount]];
                            
                            // 🔍 详细分析接收到的数据类型
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"接收到的数据类型: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // 🔧 改进的数据处理：支持多种数据类型
                            NSArray<SyncDataItem *> *batchItems = [self processRealDataForType:dataType
                                                                                     dataArray:entities
                                                                                     syncClass:syncClass];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"从第 %d 批获取到 %lu 项数据",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"第 %d 批数据为空或处理失败", batchCount]];
                            }
                            
                            // 清理resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"第 %d 批 %@ 返回空数据", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // 🔧 改进的超时处理
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"%@ 接收超时 (第 %d 次，共 %d 次)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 超时次数达到上限，停止接收", syncClass]];
                            break;
                        }
                        
                        // 如果已经获取到数据，超时可能是正常的结束信号
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"%@ 已获取到数据，超时可能是正常结束", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[ERR] 接收 %@ 数据时出错: %d",
                                        syncClass, receive_err]];
                        break;
                    }
                    
                    // 防止无限循环
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 达到最大批次限制(%d)，停止接收",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // 如果标记为最后一条记录，直接退出
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"%@ 接收到最后记录标记，正常结束", syncClass]];
                        break;
                    }
                    
                    // 添加小延迟，避免过度请求
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // 使用内部逻辑控制循环
                
                [self logMessage:[NSString stringWithFormat:@"%@ 数据接收完成: %d 批次, %lu 项",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"[WAR] %@ get_all_records失败: %d",
                                syncClass, get_all_err]];
            }
            
            // ✅ 确保会话正确结束
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"%@ 同步会话已结束", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ mobilesync_start失败（干净连接后）: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"错误详情: %s", error_description]];
            }
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // ✅ 即使没有获取到数据也不算错误
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"%@ 没有可用数据（使用干净连接后确认）", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"%@ 最终获取到 %lu 项真实数据（干净连接）",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 数据获取异常: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}

#pragma mark - 验证和错误处理

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 增强的类型检查和日志
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // 如果不是数组，尝试处理其他可能的类型
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // 可能表示没有数据或操作失败
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // 如果是true，可能表示成功但无数据
        }
        
        [self logMessage:[NSString stringWithFormat:@"[WAR] Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // 根据错误类型采取不同的处理策略
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // 尝试重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // 快速检查是否支持此数据类型
    return [self isDataTypeSupported:dataType];
}

- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error {
    if (!photoPath || photoPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo path cannot be empty"];
        }
        return NO;
    }
    
    NSString *filename = [photoPath lastPathComponent];
    if (![self isPhotoFile:filename] && ![self isVideoFile:filename]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoFormatUnsupported
                             description:[NSString stringWithFormat:@"Unsupported file format: %@", filename]];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - 私有方法实现

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
        case SyncTaskStatusScanningPhotos:
            return @"Scanning photos";
        case SyncTaskStatusDownloadingPhotos:
            return @"Downloading photos";
        case SyncTaskStatusProcessingMetadata:
            return @"Processing metadata";
        case SyncTaskStatusGeneratingThumbnails:
            return @"Generating thumbnails";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - 工具方法

- (void)logMessage:(NSString *)message {
    NSString *logMessage = [NSString stringWithFormat:@"%@", message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}

- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}

- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}

- (NSString *)sanitizeFilename:(NSString *)filename {
    NSMutableString *sanitized = [filename mutableCopy];
    NSArray *invalidChars = @[@"/", @"\\", @":", @"*", @"?", @"\"", @"<", @">", @"|"];
    
    for (NSString *invalidChar in invalidChars) {
        [sanitized replaceOccurrencesOfString:invalidChar
                                   withString:@"_"
                                      options:NSLiteralSearch
                                        range:NSMakeRange(0, sanitized.length)];
    }
    
    return [sanitized copy];
}

- (NSString *)generateThumbnailPath:(NSString *)originalPath {
    NSString *directory = [[originalPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"Thumbnails"];
    NSString *filename = [originalPath lastPathComponent];
    NSString *nameWithoutExt = [filename stringByDeletingPathExtension];
    NSString *extension = [filename pathExtension];
    
    NSString *thumbnailFilename = [NSString stringWithFormat:@"%@_thumb.%@", nameWithoutExt, extension];
    return [directory stringByAppendingPathComponent:thumbnailFilename];
}

- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize {
    // 这是一个简化的缩略图生成实现
    // 在真实应用中，你需要使用图像处理库（如CoreGraphics、ImageIO等）
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 创建目录
    NSString *destDir = [destPath stringByDeletingLastPathComponent];
    [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    
    // 简单的文件复制作为占位符
    // 在实际实现中，这里应该进行图像缩放
    NSError *error = nil;
    BOOL success = [fileManager copyItemAtPath:sourcePath toPath:destPath error:&error];
    
    if (!success) {
        [self logMessage:[NSString stringWithFormat:@"Failed to create thumbnail: %@", error.localizedDescription]];
    }
    
    return success;
}

// 🆕 安全的字符串转无符号长长整型方法
- (unsigned long long)unsignedLongLongValueFromString:(NSString *)string {
    if (!string || string.length == 0) {
        return 0;
    }
    
    // 方法1: 使用C函数strtoull（推荐）
    const char *cString = [string UTF8String];
    char *endPtr = NULL;
    unsigned long long result = strtoull(cString, &endPtr, 10);
    
    // 如果转换失败，使用备用方法
    if (endPtr == cString) {
        // 方法2: 使用NSScanner作为备用
        NSScanner *scanner = [NSScanner scannerWithString:string];
        unsigned long long scannerResult = 0;
        if ([scanner scanUnsignedLongLong:&scannerResult]) {
            return scannerResult;
        }
        
        // 方法3: 最后的备用方案，使用longLongValue
        long long signedValue = [string longLongValue];
        return (unsigned long long)MAX(0, signedValue);
    }
    
    return result;
}

- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"设备未连接或lockdown未初始化"];
        return;
    }
    
    // 修复1：正确获取设备名称
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"设备名称: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"获取设备名称失败: %d", ret]];
    }
    
    // 修复2：正确获取iOS版本
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"iOS版本: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"[WAR] iOS版本过低，可能不支持选择性同步"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"[WAR] iOS 15+设备，数据格式可能有变化"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] iOS %ld 设备，兼容性良好", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] 获取iOS版本失败: %d", ret]];
    }
    
    // 修复3：正确获取设备型号
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"设备型号: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"获取设备型号失败: %d", ret]];
    }
}

@end

-------------------------------

v2的代码：

//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Complete Enhanced Version with Photos/Camera Support - 2025.01.27
//  Based on libimobiledevice mobilesync and AFC APIs
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// 引入 libimobiledevice 相关头文件
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// 常量定义
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// 🆕 照片相关常量
NSString * const kPhotoLibraryPath = @"/DCIM";
NSString * const kCameraRollPath = @"/DCIM/100APPLE";
NSString * const kPhotoStreamPath = @"/PhotoData";
NSString * const kThumbnailsPath = @"/PhotoData/Thumbnails";

// 支持的照片格式
static NSArray *SupportedPhotoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEIF", @"HEIC", @"JPEG", @"JPG", @"PNG", @"GIF", @"TIFF", @"BMP"];
    });
    return formats;
}

// 支持的视频格式
static NSArray *SupportedVideoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEVC", @"H264", @"MP4", @"MOV", @"M4V", @"3GP"];
    });
    return formats;
}

// 基于实际iOS同步类的数据类型映射 - 完整版本
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            // 原有的同步类
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.Bookmarks",
            @(BackupDataTypeMailAccounts): @"com.apple.MailAccounts",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper",
            
            // 🆕 照片和媒体相关的同步类
            @(BackupDataTypePhotos): @"com.apple.Photos",
            @(BackupDataTypeVideos): @"com.apple.MediaAssets",
            @(BackupDataTypeCameraRoll): @"com.apple.CameraRoll",
            @(BackupDataTypePhotoAlbums): @"com.apple.PhotoAlbums",
            @(BackupDataTypePhotoStream): @"com.apple.PhotoStream",
            @(BackupDataTypeScreenshots): @"com.apple.Screenshots",
            @(BackupDataTypeSlowMotion): @"com.apple.SlowMotion",
            @(BackupDataTypeTimelapses): @"com.apple.Timelapses",
            @(BackupDataTypeBurstPhotos): @"com.apple.BurstPhotos",
            @(BackupDataTypeLivePhotos): @"com.apple.LivePhotos"
        };
    });
    return map;
}

// 🆕 照片路径映射
static NSDictionary *PhotoTypeToPathMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            @(BackupDataTypePhotos): @"/DCIM",
            @(BackupDataTypeVideos): @"/DCIM",
            @(BackupDataTypeCameraRoll): @"/DCIM/100APPLE",
            @(BackupDataTypePhotoAlbums): @"/PhotoData/Albums",
            @(BackupDataTypePhotoStream): @"/PhotoData/PhotoStream",
            @(BackupDataTypeScreenshots): @"/DCIM/Screenshots",
            @(BackupDataTypeSlowMotion): @"/DCIM/SlowMotion",
            @(BackupDataTypeTimelapses): @"/DCIM/Timelapses",
            @(BackupDataTypeBurstPhotos): @"/DCIM/Bursts",
            @(BackupDataTypeLivePhotos): @"/DCIM/LivePhotos"
        };
    });
    return map;
}

// 获取已知的同步类列表 - 用于检测支持的数据类型
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.Bookmarks",
            @"com.apple.MailAccounts",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - PhotoInfo 实现

@implementation PhotoInfo

- (instancetype)init {
    self = [super init];
    if (self) {
        _isVideo = NO;
        _isLivePhoto = NO;
        _isBurst = NO;
        _isScreenshot = NO;
        _isFavorite = NO;
        _videoDuration = 0;
        _width = 0;
        _height = 0;
        _fileSize = 0;
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<PhotoInfo: %@ (%@) - %lux%lu, %@ KB>",
            self.filename, self.format,
            (unsigned long)self.width, (unsigned long)self.height,
            @(self.fileSize / 1024)];
}

@end

#pragma mark - SyncDataItem 完整实现

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
        _isMediaFile = NO;
    }
    return self;
}

- (NSString *)description {
    if (self.isMediaFile && self.photoInfo) {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (Media: %@) - %@ records>",
                self.name, self.photoInfo.filename, @(self.recordCount)];
    } else {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
                self.name, self.identifier, @(self.recordCount)];
    }
}

@end

#pragma mark - BackupOptionTask 内部接口

// 在类的内部接口中添加线程安全队列
@interface BackupOptionTask () {
    // libimobiledevice C API 指针
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // 🆕 AFC 连接 - 用于文件传输
    afc_client_t _afc_photos;  // 专用于照片传输的AFC连接
    
    // 操作状态
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // 同步上下文
    dispatch_queue_t _operationQueue;
    dispatch_queue_t _photoQueue;  // 🆕 专用于照片操作的队列
    dispatch_queue_t _connectionQueue;  // 🆕 专用于连接操作的队列，确保线程安全
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;
    NSMutableDictionary *_photoCache; // 🆕 照片缓存
    
    // 当前操作参数
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // 内部状态
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
    
    // 🆕 照片相关状态
    NSUInteger _totalPhotosToProcess;
    NSUInteger _processedPhotos;
    NSUInteger _photoDownloadedBytes;
    NSUInteger _photoTotalBytes;
    
    // 🆕 线程安全标志
    NSRecursiveLock *_connectionLock;
    
    // ✅ 新增：连接能力状态
    DeviceConnectionCapability _connectionCapability;
}

// 私有方法声明
- (void)cleanupBasicConnection;
- (BOOL)validateServiceDependency:(BackupDataType)dataType error:(NSError **)error;


- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// 🆕 AFC 服务相关方法
- (BOOL)startAFCService:(NSError **)error;
- (BOOL)startPhotoAFCService:(NSError **)error;
- (void)closeAFCServices;

// 🆕 照片扫描和处理方法
- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error;
- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                               afcClient:(afc_client_t)afcClient
                                   error:(NSError **)error;
- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath
                            afcClient:(afc_client_t)afcClient;
- (BOOL)isPhotoFile:(NSString *)filename;
- (BOOL)isVideoFile:(NSString *)filename;
- (NSString *)getFileExtension:(NSString *)filename;

// 真实数据处理方法
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// 🆕 照片数据处理方法
- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error;
- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType;
- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType;

// 数据获取方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// 同步操作方法
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// 🆕 照片特定的备份和恢复方法
- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;

// 验证和错误处理
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;
- (BOOL)ensureStableConnection:(NSError **)error;
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType;

// 🆕 照片相关验证方法
- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error;
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error;

// 工具方法
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;
- (NSString *)stringForPlistType:(plist_type)type;
- (NSString *)formatDuration:(NSTimeInterval)duration;

// 🆕 内部连接方法（不使用锁，避免递归锁）
- (BOOL)isConnectedInternal;
- (void)disconnectDeviceInternal;


- (NSString *)generateThumbnailPath:(NSString *)originalPath;
- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize;
- (void)checkDeviceCompatibilityForSync;
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType;
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType;

@end

#pragma mark - BackupOptionTask 完整实现

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;
@synthesize connectionCapability = _connectionCapability;

#pragma mark - 单例和初始化

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _photoQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.photo", DISPATCH_QUEUE_CONCURRENT);
        _connectionQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.connection", DISPATCH_QUEUE_SERIAL);
        _connectionLock = [[NSRecursiveLock alloc] init];
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        _photoCache = [NSMutableDictionary dictionary];
        
        // 🆕 照片传输设置默认值
        _photoTransferMode = PhotoTransferModeOriginal;
        _enableThumbnailGeneration = YES;
        _maxPhotoResolution = 0; // 无限制
        _preserveOriginalFormat = YES;
        _includeHiddenPhotos = NO;
        _includeLivePhotos = YES;
        _includeVideoFiles = YES;
        
        // 设置默认数据存储路径
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        _totalPhotosToProcess = 0;
        _processedPhotos = 0;
        _photoDownloadedBytes = 0;
        _photoTotalBytes = 0;
        
        [self logMessage:[NSString stringWithFormat:@"Complete Enhanced BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}

//- (void)dealloc {
//    [self disconnectDevice];
//}

#pragma mark - 设备连接和查询

- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [_connectionLock lock];
    @try {
        [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
        
        if (!deviceUDID || deviceUDID.length == 0) {
            [self logMessage:@"[ERR] Device UDID cannot be empty"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                                 description:@"Device UDID cannot be empty"];
            }
            return NO;
        }
        
        // 如果已经连接到同一设备，检查连接状态
        if ([_deviceUDID isEqualToString:deviceUDID] && [self isConnectedInternal]) {
            [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@ (MobileSync: %@, AFC: %@)",
                             deviceUDID,
                             _mobilesync ? @"Yes" : @"No",
                             _afc ? @"Yes" : @"No"]];
            return YES;
        }
        
        // 安全地断开现有连接
        if (_device || _lockdown || _mobilesync || _afc) {
            [self logMessage:@"[WAR] Disconnecting existing connection before reconnecting"];
            [self disconnectDeviceInternal];
            // 短暂等待确保清理完成
            [NSThread sleepForTimeInterval:0.2];
        }
        
        _deviceUDID = [deviceUDID copy];
        return [self connectToDeviceInternal:deviceUDID error:error];
        
    } @finally {
        [_connectionLock unlock];
    }
}

/*
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. 连接设备
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. 创建lockdown客户端
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        // 清理已创建的设备连接
        if (_device) {
            idevice_free(_device);
            _device = NULL;
        }
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // 3. 启动mobilesync服务 - 添加更详细的错误处理
    NSError *syncError = nil;
    if (![self startMobileSyncService:&syncError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] MobileSync service failed to start: %@", syncError.localizedDescription]];
        [self logMessage:@"Continuing without MobileSync - photo features will still work via AFC"];
        // 不要因为MobileSync失败就完全失败，因为AFC还可以工作
        // 清除错误以便继续
        if (error) *error = nil;
    } else {
        [self logMessage:@"MobileSync service started successfully"];
    }
    
    // 🆕 4. 启动AFC服务（用于文件传输）
    NSError *afcError = nil;
    if (![self startAFCService:&afcError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] AFC service failed to start: %@", afcError.localizedDescription]];
        [self logMessage:@"[WAR] Photo features will be limited without AFC"];
        // AFC失败也不完全失败，因为MobileSync还可以工作
    } else {
        [self logMessage:@"AFC service started successfully"];
    }
    
    // 🆕 5. 启动照片专用AFC服务
    NSError *photoAfcError = nil;
    if (![self startPhotoAFCService:&photoAfcError]) {
        [self logMessage:@"Photo AFC service not available, using regular AFC for photos"];
        // 这个失败是正常的，很多设备没有专用的AFC2服务
    } else {
        [self logMessage:@"Photo AFC service started successfully"];
    }
    
    // 只要有AFC或MobileSync其中之一成功，就认为连接成功
    BOOL hasWorkingService = (_mobilesync != NULL) || (_afc != NULL);
    
    if (hasWorkingService) {
        [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@ (MobileSync: %@, AFC: %@)",
                         deviceUDID,
                         _mobilesync ? @"Yes" : @"No",
                         _afc ? @"Yes" : @"No"]];
        [self setInternalStatus:SyncTaskStatusIdle];
        return YES;
    } else {
        [self logMessage:@"[ERR] Neither MobileSync nor AFC services are available"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                             description:@"Neither MobileSync nor AFC services could be started"];
        }
        // 完全清理连接
        [self disconnectDevice];
        return NO;
    }
}*/

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. 基础设备连接
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. 创建lockdown客户端
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        [self cleanupBasicConnection];
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // ✅ 关键修复：重置连接能力，独立验证各个服务
    _connectionCapability = DeviceConnectionCapabilityNone;
    
    // 3. 尝试启动MobileSync服务（传统数据类型必需）
    NSError *mobileSyncError = nil;
    if ([self startMobileSyncService:&mobileSyncError]) {
        _connectionCapability |= DeviceConnectionCapabilityMobileSync;
        [self logMessage:@"✅ MobileSync service available - Traditional data types (Contacts, Calendars, etc.) supported"];
    } else {
        [self logMessage:[NSString stringWithFormat:@"❌ MobileSync service failed: %@ - Traditional data types will NOT be available",
                         mobileSyncError.localizedDescription ?: @"Unknown error"]];
        // ✅ 关键修复：不掩盖MobileSync失败，如实记录
    }
    
    // 4. 尝试启动AFC服务（照片数据类型必需）
    NSError *afcError = nil;
    if ([self startAFCService:&afcError]) {
        _connectionCapability |= DeviceConnectionCapabilityAFC;
        [self logMessage:@"✅ AFC service available - Photo data types supported"];
        
        // 5. 尝试启动照片专用AFC服务（可选）
        NSError *photoAfcError = nil;
        if ([self startPhotoAFCService:&photoAfcError]) {
            [self logMessage:@"✅ Photo AFC service started successfully"];
        } else {
            [self logMessage:@"Photo AFC service not available, using regular AFC for photos"];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"❌ AFC service failed: %@ - Photo data types will NOT be available",
                         afcError.localizedDescription ?: @"Unknown error"]];
    }
    
    // ✅ 关键修复：明确的连接成功标准
    if (_connectionCapability == DeviceConnectionCapabilityNone) {
        NSString *errorDesc = @"No services available - neither MobileSync nor AFC could be started. Device connection failed.";
        [self logMessage:[NSString stringWithFormat:@"❌ %@", errorDesc]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
        }
        [self cleanupBasicConnection];
        return NO;
    }
    
    // ✅ 连接成功，记录详细的能力信息
    [self logMessage:[NSString stringWithFormat:@"✅ Successfully connected to device: %@", deviceUDID]];
    [self logMessage:[NSString stringWithFormat:@"📊 Connection capability: %@", [self getConnectionCapabilityDescription]]];
    
    [self setInternalStatus:SyncTaskStatusIdle];
    return YES;
}

// ✅ 新增：清理基础连接的辅助方法
- (void)cleanupBasicConnection {
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
    }
    
    if (_device) {
        idevice_free(_device);
        _device = NULL;
    }
}

// 🆕 启动AFC服务
- (BOOL)startAFCService:(NSError **)error {
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to start AFC service: %d", ldret]];
        }
        return NO;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to create AFC client: %d", afc_err]];
        }
        return NO;
    }
    
    [self logMessage:@"AFC service started successfully"];
    return YES;
}

// 🆕 启动照片专用AFC服务
- (BOOL)startPhotoAFCService:(NSError **)error {
    // 尝试启动照片专用的AFC服务
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc2", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        // 如果没有afc2，尝试使用普通的afc
        [self logMessage:@"AFC2 service not available, using regular AFC for photos"];
        _afc_photos = _afc; // 使用同一个AFC客户端
        return YES;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc_photos);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:@"Failed to create photo AFC client, using regular AFC"];
        _afc_photos = _afc; // 回退到普通AFC
        return YES;
    }
    
    [self logMessage:@"Photo AFC service started successfully"];
    return YES;
}

- (BOOL)startMobileSyncService:(NSError **)error {
    [self logMessage:@"Starting MobileSync service..."];
    
    int maxRetries = 3;
    int retryDelay = 1; // 减少延迟时间
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        [self logMessage:[NSString stringWithFormat:@"MobileSync service start attempt %d: lockdownd_start_service returned %d",
                         attempt + 1, ldret]];
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            [self logMessage:[NSString stringWithFormat:@"MobileSync service descriptor created successfully (port: %d)", service->port]];
            
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            [self logMessage:[NSString stringWithFormat:@"mobilesync_client_new returned %d", err]];
            
            if (err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:@"MobileSync client created successfully"];
                return YES;  // 成功
            } else {
                [self logMessage:[NSString stringWithFormat:@"[ERR] MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"[ERR] Failed to start MobileSync service (attempt %d): ldret=%d, service=%p, port=%d",
                             attempt + 1, ldret, service, service ? service->port : 0]];
            
            if (service) {
                lockdownd_service_descriptor_free(service);
            }
        }
        
        // 如果不是最后一次尝试，等待后重试
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Retrying MobileSync in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // 所有尝试都失败
    NSString *errorDesc = [NSString stringWithFormat:@"Failed to create MobileSync client after %d attempts", maxRetries];
    [self logMessage:[NSString stringWithFormat:@"[ERR] %@", errorDesc]];
    
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
    }
    return NO;
}

- (void)disconnectDevice {
    [_connectionLock lock];
    @try {
        [self disconnectDeviceInternal];
        [self logMessage:@"Device disconnection completed"];
    } @finally {
        [_connectionLock unlock];
    }
}

// 🆕 关闭AFC服务 - 增强版本，确保安全清理
- (void)closeAFCServices {
    // 清理照片专用AFC服务
    if (_afc_photos && _afc_photos != _afc) {
        @try {
            afc_client_free(_afc_photos);
            [self logMessage:@"Photo AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing photo AFC: %@", exception.reason]];
        }
        _afc_photos = NULL;
    }
    
    // 清理普通AFC服务
    if (_afc) {
        @try {
            afc_client_free(_afc);
            [self logMessage:@"AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing AFC: %@", exception.reason]];
        }
        _afc = NULL;
    }
    
    // 如果照片AFC指向普通AFC，也清空
    if (_afc_photos == _afc) {
        _afc_photos = NULL;
    }
}

/*
- (BOOL)isConnected {
    [_connectionLock lock];
    @try {
        // 只要有设备连接和lockdown，并且至少有一个服务（MobileSync或AFC）可用就认为已连接
        BOOL connected = (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
        return connected;
    } @finally {
        [_connectionLock unlock];
    }
}*/

- (BOOL)isConnected {
    [_connectionLock lock];
    @try {
        // ✅ 修复：基于连接能力判断，而不是简单的服务存在检查
        BOOL basicConnectionExists = (_device != NULL && _lockdown != NULL);
        BOOL hasAnyCapability = (_connectionCapability != DeviceConnectionCapabilityNone);
        
        return basicConnectionExists && hasAnyCapability;
    } @finally {
        [_connectionLock unlock];
    }
}

#pragma mark - 🆕 内部连接管理方法

// 🆕 内部连接检查方法（不使用锁）
- (BOOL)isConnectedInternal {
    return (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
}

// 🆕 内部断开连接方法（不使用锁）
/*
- (void)disconnectDeviceInternal {
    [self logMessage:@"Internal disconnecting device..."];
    
    // 设置状态为空闲
    [self setInternalStatus:SyncTaskStatusIdle];
    
    // 🆕 关闭AFC服务 - 安全地清理
    [self closeAFCServices];
    
    // 清理MobileSync连接
    if (_mobilesync) {
        @try {
            mobilesync_finish(_mobilesync);
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception during mobilesync_finish: %@", exception.reason]];
        }
        
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [self logMessage:@"MobileSync client freed"];
    }
    
    // 清理通知代理
    if (_np) {
        np_client_free(_np);
        _np = NULL;
        [self logMessage:@"Notification proxy freed"];
    }
    
    // 清理lockdown连接
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
        [self logMessage:@"Lockdown client freed"];
    }
    
    // 清理设备连接
    if (_device) {
        idevice_free(_device);
        _device = NULL;
        [self logMessage:@"Device connection freed"];
    }
}
*/

- (void)disconnectDeviceInternal {
    [self logMessage:@"Internal disconnecting device..."];
    
    // ✅ 重置连接能力
    _connectionCapability = DeviceConnectionCapabilityNone;
    
    // 设置状态为空闲
    [self setInternalStatus:SyncTaskStatusIdle];
    
    // 关闭AFC服务 - 安全地清理
    [self closeAFCServices];
    
    // 清理MobileSync连接
    if (_mobilesync) {
        @try {
            mobilesync_finish(_mobilesync);
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception during mobilesync_finish: %@", exception.reason]];
        }
        
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [self logMessage:@"MobileSync client freed"];
    }
    
    // 清理通知代理
    if (_np) {
        np_client_free(_np);
        _np = NULL;
        [self logMessage:@"Notification proxy freed"];
    }
    
    // 清理lockdown连接
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
        [self logMessage:@"Lockdown client freed"];
    }
    
    // 清理设备连接
    if (_device) {
        idevice_free(_device);
        _device = NULL;
        [self logMessage:@"Device connection freed"];
    }
    
    [self logMessage:@"Device disconnection completed, capability reset to None"];
}

#pragma mark - 🆕 照片库访问功能

- (BOOL)checkPhotoLibraryAccess:(NSError **)error {
    [self logMessage:@"Checking photo library access"];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Device not connected"];
        }
        return NO;
    }
    
    if (!_afc && !_afc_photos) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // 测试访问DCIM目录
    afc_client_t afc_client = _afc_photos ?: _afc;
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, "/DCIM", &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        [self logMessage:@"Photo library access confirmed"];
        return YES;
    } else if (afc_err == AFC_E_READ_ERROR) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoLibraryLocked
                             description:@"Photo library is locked or access denied"];
        }
        return NO;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to access photo library: %d", afc_err]];
        }
        return NO;
    }
}

- (NSArray<PhotoInfo *> *)scanPhotoLibrary:(NSArray<NSString *> *)albumNames error:(NSError **)error {
    [self logMessage:@"Starting photo library scan"];
    
    if (![self checkPhotoLibraryAccess:error]) {
        return nil;
    }
    
    NSMutableArray<PhotoInfo *> *allPhotos = [NSMutableArray array];
    
    if (!albumNames || albumNames.count == 0) {
        // 扫描所有默认目录
        NSArray *defaultPaths = @[@"/DCIM/100APPLE", @"/DCIM/101APPLE", @"/DCIM/102APPLE"];
        
        for (NSString *path in defaultPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    } else {
        // 扫描指定相册
        for (NSString *albumName in albumNames) {
            NSString *albumPath = [NSString stringWithFormat:@"/PhotoData/Albums/%@", albumName];
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:albumPath recursive:YES error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo library scan completed: %lu photos found", (unsigned long)allPhotos.count]];
    return [allPhotos copy];
}

- (void)scanPhotoLibraryAsync:(NSArray<NSString *> *)albumNames
                     progress:(PhotoScanProgressCallback)progressCallback
                   completion:(PhotoCompletionCallback)completion {
    
    dispatch_async(_photoQueue, ^{
        NSError *error = nil;
        NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:albumNames error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(photos, error);
            }
        });
    });
}

- (NSDictionary *)getPhotoLibraryStatistics:(NSError **)error {
    [self logMessage:@"Getting photo library statistics"];
    
    NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:nil error:error];
    if (!photos) {
        return nil;
    }
    
    NSUInteger photoCount = 0;
    NSUInteger videoCount = 0;
    NSUInteger livePhotoCount = 0;
    NSUInteger burstCount = 0;
    NSUInteger screenshotCount = 0;
    NSUInteger totalSize = 0;
    
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (PhotoInfo *photo in photos) {
        if (photo.isVideo) {
            videoCount++;
        } else {
            photoCount++;
        }
        
        if (photo.isLivePhoto) livePhotoCount++;
        if (photo.isBurst) burstCount++;
        if (photo.isScreenshot) screenshotCount++;
        
        totalSize += photo.fileSize;
        
        if (!oldestDate || [photo.dateCreated compare:oldestDate] == NSOrderedAscending) {
            oldestDate = photo.dateCreated;
        }
        if (!newestDate || [photo.dateCreated compare:newestDate] == NSOrderedDescending) {
            newestDate = photo.dateCreated;
        }
    }
    
    return @{
        @"totalItems": @(photos.count),
        @"photoCount": @(photoCount),
        @"videoCount": @(videoCount),
        @"livePhotoCount": @(livePhotoCount),
        @"burstCount": @(burstCount),
        @"screenshotCount": @(screenshotCount),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"averageFileSize": @(photos.count > 0 ? totalSize / photos.count : 0)
    };
}

- (BOOL)downloadPhoto:(PhotoInfo *)photoInfo
        toDestination:(NSString *)destinationPath
                error:(NSError **)error {
    
    if (!photoInfo || !destinationPath) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo info or destination path cannot be nil"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Downloading photo: %@", photoInfo.filename]];
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // 构建设备上的完整路径
    NSString *devicePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // 打开设备上的文件
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afc_client, [devicePath UTF8String], AFC_FOPEN_RDONLY, &handle);
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to open photo file: %d", afc_err]];
        }
        return NO;
    }
    
    // 创建本地文件
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *destDir = [destinationPath stringByDeletingLastPathComponent];
    if (![fileManager fileExistsAtPath:destDir]) {
        [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    NSFileHandle *destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    if (!destFile) {
        [fileManager createFileAtPath:destinationPath contents:nil attributes:nil];
        destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    }
    
    if (!destFile) {
        afc_file_close(afc_client, handle);
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to create destination file"];
        }
        return NO;
    }
    
    // 读取并写入文件
    const uint32_t bufferSize = 65536; // 64KB buffer
    uint32_t bytesRead = 0;
    NSUInteger totalBytesRead = 0;
    
    do {
        char buffer[bufferSize];
        afc_err = afc_file_read(afc_client, handle, buffer, bufferSize, &bytesRead);
        
        if (afc_err == AFC_E_SUCCESS && bytesRead > 0) {
            NSData *data = [NSData dataWithBytes:buffer length:bytesRead];
            [destFile writeData:data];
            totalBytesRead += bytesRead;
            
            // 报告进度
            if (self.photoDownloadCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.photoDownloadCallback(photoInfo.filename, totalBytesRead, photoInfo.fileSize);
                });
            }
        }
    } while (afc_err == AFC_E_SUCCESS && bytesRead > 0);
    
    [destFile closeFile];
    afc_file_close(afc_client, handle);
    
    if (afc_err == AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Successfully downloaded photo: %@ (%lu bytes)",
                         photoInfo.filename, (unsigned long)totalBytesRead]];
        return YES;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to read photo data: %d", afc_err]];
        }
        return NO;
    }
}

- (void)downloadPhotos:(NSArray<PhotoInfo *> *)photos
      toDestinationDir:(NSString *)destinationDir
              progress:(PhotoDownloadProgressCallback)progressCallback
            completion:(void (^)(NSUInteger successCount, NSUInteger failedCount, NSError *error))completion {
    
    dispatch_async(_photoQueue, ^{
        NSUInteger successCount = 0;
        NSUInteger failedCount = 0;
        NSError *lastError = nil;
        
        for (NSUInteger i = 0; i < photos.count; i++) {
            if (self->_cancelRequested) {
                break;
            }
            
            PhotoInfo *photo = photos[i];
            NSString *destPath = [destinationDir stringByAppendingPathComponent:photo.filename];
            
            NSError *downloadError = nil;
            BOOL success = [self downloadPhoto:photo toDestination:destPath error:&downloadError];
            
            if (success) {
                successCount++;
            } else {
                failedCount++;
                lastError = downloadError;
            }
            
            // 报告总体进度
            if (progressCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    progressCallback(photo.filename, i + 1, photos.count);
                });
            }
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(successCount, failedCount, lastError);
            }
        });
    });
}

#pragma mark - 🆕 照片扫描和处理实现

- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error {
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return @[];
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Failed to read directory %@: %d", directory, afc_err]];
        return @[];
    }
    
    NSMutableArray<PhotoInfo *> *photos = [NSMutableArray array];
    
    if (dir_list) {
        for (int i = 0; dir_list[i] != NULL; i++) {
            NSString *filename = [NSString stringWithUTF8String:dir_list[i]];
            
            // 跳过隐藏文件和目录
            if ([filename hasPrefix:@"."]) continue;
            
            NSString *fullPath = [directory stringByAppendingPathComponent:filename];
            
            // 检查是否是照片或视频文件
            if ([self isPhotoFile:filename] || [self isVideoFile:filename]) {
                PhotoInfo *photoInfo = [self createPhotoInfoFromPath:fullPath
                                                           afcClient:afc_client
                                                               error:nil];
                if (photoInfo) {
                    [photos addObject:photoInfo];
                }
            } else if (recursive) {
                // 递归扫描子目录
                char **subdir_info = NULL;
                afc_err = afc_get_file_info(afc_client, [fullPath UTF8String], &subdir_info);
                
                if (afc_err == AFC_E_SUCCESS && subdir_info) {
                    // 检查是否是目录
                    for (int j = 0; subdir_info[j] != NULL; j += 2) {
                        if (strcmp(subdir_info[j], "st_ifmt") == 0) {
                            if (strcmp(subdir_info[j + 1], "S_IFDIR") == 0) {
                                NSArray<PhotoInfo *> *subdirPhotos = [self scanPhotosInDirectory:fullPath
                                                                                     recursive:recursive
                                                                                         error:nil];
                                if (subdirPhotos) {
                                    [photos addObjectsFromArray:subdirPhotos];
                                }
                            }
                            break;
                        }
                    }
                    afc_dictionary_free(subdir_info);
                }
            }
        }
        afc_dictionary_free(dir_list);
    }
    
    [self logMessage:[NSString stringWithFormat:@"Found %lu photos in directory: %@",
                     (unsigned long)photos.count, directory]];
    return [photos copy];
}

- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                             afcClient:(afc_client_t)afcClient
                                 error:(NSError **)error {
    
    PhotoInfo *photoInfo = [[PhotoInfo alloc] init];
    photoInfo.filename = [photoPath lastPathComponent];
    photoInfo.format = [[self getFileExtension:photoInfo.filename] uppercaseString];
    photoInfo.isVideo = [self isVideoFile:photoInfo.filename];
    
    // 获取文件信息
    char **file_info = NULL;
    afc_error_t afc_err = afc_get_file_info(afcClient, [photoPath UTF8String], &file_info);
    
    if (afc_err == AFC_E_SUCCESS && file_info) {
        for (int i = 0; file_info[i] != NULL; i += 2) {
            NSString *key = [NSString stringWithUTF8String:file_info[i]];
            NSString *value = [NSString stringWithUTF8String:file_info[i + 1]];
            
            if ([key isEqualToString:@"st_size"]) {
                // 使用安全的转换方法
                photoInfo.fileSize = [self unsignedLongLongValueFromString:value];
            } else if ([key isEqualToString:@"st_mtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateModified = [NSDate dateWithTimeIntervalSince1970:timestamp];
            } else if ([key isEqualToString:@"st_birthtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateCreated = [NSDate dateWithTimeIntervalSince1970:timestamp];
            }
        }
        afc_dictionary_free(file_info);
    } else {
        [self logMessage:[NSString stringWithFormat:@"Failed to get file info for %@: %d", photoPath, afc_err]];
    }
    
    // 设置默认值
    if (!photoInfo.dateCreated) {
        photoInfo.dateCreated = photoInfo.dateModified ?: [NSDate date];
    }
    if (!photoInfo.dateModified) {
        photoInfo.dateModified = photoInfo.dateCreated;
    }
    
    // 生成唯一ID
    photoInfo.photoID = [NSString stringWithFormat:@"%@_%lu",
                        [[photoInfo.filename stringByDeletingPathExtension]
                         stringByReplacingOccurrencesOfString:@" " withString:@"_"],
                        (unsigned long)[photoInfo.dateCreated timeIntervalSince1970]];
    
    // 检测特殊类型
    NSString *lowercaseFilename = [photoInfo.filename lowercaseString];
    photoInfo.isLivePhoto = [lowercaseFilename containsString:@"live"];
    photoInfo.isBurst = [lowercaseFilename containsString:@"burst"];
    photoInfo.isScreenshot = [lowercaseFilename hasPrefix:@"img_"] && [lowercaseFilename containsString:@"screenshot"];
    
    // 尝试提取EXIF数据（简化版本）
    if (!photoInfo.isVideo) {
        photoInfo.exifData = [self extractEXIFFromPath:photoPath afcClient:afcClient];
        
        // 从EXIF提取尺寸信息
        if (photoInfo.exifData) {
            NSNumber *width = photoInfo.exifData[@"PixelXDimension"];
            NSNumber *height = photoInfo.exifData[@"PixelYDimension"];
            if (width && height) {
                photoInfo.width = [width unsignedIntegerValue];
                photoInfo.height = [height unsignedIntegerValue];
            }
        }
    }
    
    return photoInfo;
}

- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath afcClient:(afc_client_t)afcClient {
    // 这是一个简化的EXIF提取实现
    // 在真实实现中，你需要一个完整的EXIF解析库
    
    // 读取文件的前几个字节来检测格式和基本信息
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afcClient, [photoPath UTF8String], AFC_FOPEN_RDONLY, &handle);
    
    if (afc_err != AFC_E_SUCCESS) {
        return nil;
    }
    
    char header[1024];
    uint32_t bytesRead = 0;
    afc_err = afc_file_read(afcClient, handle, header, sizeof(header), &bytesRead);
    afc_file_close(afcClient, handle);
    
    if (afc_err != AFC_E_SUCCESS || bytesRead < 10) {
        return nil;
    }
    
    NSMutableDictionary *exifData = [NSMutableDictionary dictionary];
    
    // 检测JPEG格式
    if (bytesRead >= 2 && header[0] == (char)0xFF && header[1] == (char)0xD8) {
        exifData[@"Format"] = @"JPEG";
        // 这里可以添加更复杂的EXIF解析逻辑
    }
    // 检测HEIF格式
    else if (bytesRead >= 8 && strncmp(&header[4], "ftyp", 4) == 0) {
        exifData[@"Format"] = @"HEIF";
    }
    // 检测PNG格式
    else if (bytesRead >= 8 && strncmp(header, "\x89PNG\r\n\x1a\n", 8) == 0) {
        exifData[@"Format"] = @"PNG";
    }
    
    // 添加基本信息
    exifData[@"FileSize"] = @(photoPath.length);
    exifData[@"ExtractedAt"] = [NSDate date];
    
    return [exifData copy];
}

- (BOOL)isPhotoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedPhotoFormats() containsObject:extension];
}

- (BOOL)isVideoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedVideoFormats() containsObject:extension];
}

- (NSString *)getFileExtension:(NSString *)filename {
    return [[filename pathExtension] uppercaseString];
}

#pragma mark - 数据查询增强
/*
- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // 🆕 检查是否是照片/媒体类型
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self processPhotoDataForType:dataType error:error];
    }
    
    // 检查缓存
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // 使用真实的数据获取方法
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // 缓存结果
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}*/

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // ✅ 关键修复：在数据获取前验证服务依赖
    if (![self validateServiceDependency:dataType error:error]) {
        return nil;
    }
    
    // 🆕 检查是否是照片/媒体类型
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self processPhotoDataForType:dataType error:error];
    }
    
    // 检查缓存
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // 使用真实的数据获取方法
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // 缓存结果
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

// ✅ 新增：验证服务依赖的统一方法
- (BOOL)validateServiceDependency:(BackupDataType)dataType error:(NSError **)error {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        // 照片类型需要AFC服务
        if (!(_connectionCapability & DeviceConnectionCapabilityAFC)) {
            NSString *errorDesc = [NSString stringWithFormat:@"Cannot access %@ data: AFC service is not available. Photo data types require AFC service for file system access.", typeName];
            [self logMessage:[NSString stringWithFormat:@"❌ %@", errorDesc]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed description:errorDesc];
            }
            return NO;
        }
        [self logMessage:[NSString stringWithFormat:@"✅ %@ data access validated: AFC service available", typeName]];
        return YES;
    } else {
        // 传统类型需要MobileSync服务
        if (!(_connectionCapability & DeviceConnectionCapabilityMobileSync)) {
            NSString *errorDesc = [NSString stringWithFormat:@"Cannot access %@ data: MobileSync service is not available. Traditional data types (Contacts, Calendars, etc.) require MobileSync service for data synchronization.", typeName];
            [self logMessage:[NSString stringWithFormat:@"❌ %@", errorDesc]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
            }
            return NO;
        }
        [self logMessage:[NSString stringWithFormat:@"✅ %@ data access validated: MobileSync service available", typeName]];
        return YES;
    }
}

#pragma mark - ✅ 新增：连接能力查询方法

- (BOOL)canSyncTraditionalDataTypes {
    return (_connectionCapability & DeviceConnectionCapabilityMobileSync) != 0;
}

- (BOOL)canSyncPhotoDataTypes {
    return (_connectionCapability & DeviceConnectionCapabilityAFC) != 0;
}

- (NSString *)getConnectionCapabilityDescription {
    switch (_connectionCapability) {
        case DeviceConnectionCapabilityNone:
            return @"No services available";
        case DeviceConnectionCapabilityMobileSync:
            return @"Traditional data only (Contacts, Calendars, etc.) - MobileSync available, AFC unavailable";
        case DeviceConnectionCapabilityAFC:
            return @"Photos only - AFC available, MobileSync unavailable";
        case DeviceConnectionCapabilityFull:
            return @"Full capability (Traditional data + Photos) - Both MobileSync and AFC available";
        default:
            return [NSString stringWithFormat:@"Unknown capability state: %lu", (unsigned long)_connectionCapability];
    }
}

- (void)diagnoseServiceCapabilities {
    [self logMessage:@"=== 📊 Service Capabilities Diagnosis ==="];
    
    // 基础连接状态
    BOOL isConnected = [self isConnected];
    [self logMessage:[NSString stringWithFormat:@"Device connected: %@", isConnected ? @"✅ YES" : @"❌ NO"]];
    
    if (!isConnected) {
        [self logMessage:@"Device is not connected. Cannot diagnose service capabilities."];
        [self logMessage:@"=== Diagnosis Complete ==="];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    // 服务状态详情
    [self logMessage:@"--- Service Status ---"];
    [self logMessage:[NSString stringWithFormat:@"MobileSync service: %@", _mobilesync ? @"✅ Available" : @"❌ Not available"]];
    [self logMessage:[NSString stringWithFormat:@"AFC service: %@", _afc ? @"✅ Available" : @"❌ Not available"]];
    [self logMessage:[NSString stringWithFormat:@"Photo AFC service: %@",
                     (_afc_photos && _afc_photos != _afc) ? @"✅ Available (dedicated)" :
                     (_afc_photos == _afc) ? @"✅ Available (shared with regular AFC)" : @"❌ Not available"]];
    
    // 连接能力总结
    [self logMessage:@"--- Connection Capabilities ---"];
    [self logMessage:[NSString stringWithFormat:@"Overall capability: %@", [self getConnectionCapabilityDescription]]];
    [self logMessage:[NSString stringWithFormat:@"Can sync traditional data: %@", [self canSyncTraditionalDataTypes] ? @"✅ YES" : @"❌ NO"]];
    [self logMessage:[NSString stringWithFormat:@"Can sync photo data: %@", [self canSyncPhotoDataTypes] ? @"✅ YES" : @"❌ NO"]];
    
    // 数据类型支持情况
    [self logMessage:@"--- Data Type Support Summary ---"];
    if ([self canSyncTraditionalDataTypes]) {
        [self logMessage:@"✅ Traditional data types supported: Contacts, Calendars, Bookmarks, MailAccounts, Notes, Reminders, Applications, Configuration, Keychain, VoiceMemos, Wallpaper"];
    } else {
        [self logMessage:@"❌ Traditional data types NOT supported: MobileSync service required but not available"];
        [self logMessage:@"💡 To enable traditional data types, ensure device is unlocked and 'Trust This Computer' is confirmed"];
    }
    
    if ([self canSyncPhotoDataTypes]) {
        [self logMessage:@"✅ Photo data types supported: Photos, Videos, CameraRoll, PhotoAlbums, PhotoStream, Screenshots, SlowMotion, Timelapses, BurstPhotos, LivePhotos"];
    } else {
        [self logMessage:@"❌ Photo data types NOT supported: AFC service required but not available"];
        [self logMessage:@"💡 To enable photo data types, ensure device is unlocked and file system access is available"];
    }
    
    // 建议和下一步操作
    [self logMessage:@"--- Recommendations ---"];
    if (_connectionCapability == DeviceConnectionCapabilityNone) {
        [self logMessage:@"⚠️  No data can be synchronized. Check device connection and trust status."];
    } else if (_connectionCapability == DeviceConnectionCapabilityFull) {
        [self logMessage:@"🎉 All data types are supported. Device is ready for comprehensive backup."];
    } else {
        [self logMessage:@"⚠️  Partial functionality available. Some data types may not be accessible."];
        if (!(_connectionCapability & DeviceConnectionCapabilityMobileSync)) {
            [self logMessage:@"💡 To enable traditional data sync: Ensure device is unlocked, trusted, and iOS sync services are running"];
        }
        if (!(_connectionCapability & DeviceConnectionCapabilityAFC)) {
            [self logMessage:@"💡 To enable photo sync: Ensure device allows file system access and AFC services are available"];
        }
    }
    
    [self logMessage:@"=== Diagnosis Complete ==="];
}


- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - 🆕 照片数据处理方法

- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Processing photo data for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // 检查照片缓存
    NSString *cacheKey = [NSString stringWithFormat:@"photo_datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _photoCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached photo items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    // 根据数据类型确定扫描路径
    NSString *scanPath = PhotoTypeToPathMap()[@(dataType)];
    if (!scanPath) {
        scanPath = @"/DCIM"; // 默认路径
    }
    
    // 扫描照片
    NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:scanPath recursive:YES error:error];
    if (!photos) {
        return @[];
    }
    
    // 根据数据类型过滤照片
    NSPredicate *filter = [self createFilterPredicateForDataType:dataType];
    if (filter) {
        photos = [photos filteredArrayUsingPredicate:filter];
    }
    
    // 转换为SyncDataItem
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    for (PhotoInfo *photo in photos) {
        SyncDataItem *item = [self createSyncItemFromPhotoInfo:photo dataType:dataType];
        if (item) {
            [items addObject:item];
        }
    }
    
    // 缓存结果
    _photoCache[cacheKey] = items;
    
    [self logMessage:[NSString stringWithFormat:@"Processed %lu photo items for type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return [items copy];
}

- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypePhotos:
            return [NSPredicate predicateWithFormat:@"isVideo == NO"];
        case BackupDataTypeVideos:
            return [NSPredicate predicateWithFormat:@"isVideo == YES"];
        case BackupDataTypeScreenshots:
            return [NSPredicate predicateWithFormat:@"isScreenshot == YES"];
        case BackupDataTypeLivePhotos:
            return [NSPredicate predicateWithFormat:@"isLivePhoto == YES"];
        case BackupDataTypeBurstPhotos:
            return [NSPredicate predicateWithFormat:@"isBurst == YES"];
        default:
            return nil; // 无过滤器，返回所有照片
    }
}

- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    
    item.identifier = photoInfo.photoID;
    item.name = photoInfo.filename;
    item.dataType = dataType;
    item.modificationDate = photoInfo.dateModified;
    item.recordCount = 1;
    item.dataSize = photoInfo.fileSize;
    item.isSelected = NO;
    item.isMediaFile = YES;
    item.photoInfo = photoInfo;
    
    // 设置远程路径
    item.remotePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // 创建元数据
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    metadata[@"isPhoto"] = @(!photoInfo.isVideo);
    metadata[@"isVideo"] = @(photoInfo.isVideo);
    metadata[@"format"] = photoInfo.format ?: @"Unknown";
    metadata[@"fileSize"] = @(photoInfo.fileSize);
    metadata[@"formattedSize"] = [self formatFileSize:photoInfo.fileSize];
    
    if (photoInfo.width > 0 && photoInfo.height > 0) {
        metadata[@"dimensions"] = [NSString stringWithFormat:@"%lux%lu",
                                  (unsigned long)photoInfo.width, (unsigned long)photoInfo.height];
        metadata[@"width"] = @(photoInfo.width);
        metadata[@"height"] = @(photoInfo.height);
        metadata[@"megapixels"] = @((photoInfo.width * photoInfo.height) / 1000000.0);
    }
    
    if (photoInfo.isVideo && photoInfo.videoDuration > 0) {
        metadata[@"duration"] = @(photoInfo.videoDuration);
        metadata[@"formattedDuration"] = [self formatDuration:photoInfo.videoDuration];
    }
    
    if (photoInfo.isLivePhoto) metadata[@"isLivePhoto"] = @YES;
    if (photoInfo.isBurst) metadata[@"isBurst"] = @YES;
    if (photoInfo.isScreenshot) metadata[@"isScreenshot"] = @YES;
    if (photoInfo.isFavorite) metadata[@"isFavorite"] = @YES;
    
    item.metadata = [metadata copy];
    
    return item;
}

- (NSString *)formatDuration:(NSTimeInterval)duration {
    NSInteger hours = (NSInteger)duration / 3600;
    NSInteger minutes = ((NSInteger)duration % 3600) / 60;
    NSInteger seconds = (NSInteger)duration % 60;
    
    if (hours > 0) {
        return [NSString stringWithFormat:@"%ld:%02ld:%02ld", (long)hours, (long)minutes, (long)seconds];
    } else {
        return [NSString stringWithFormat:@"%ld:%02ld", (long)minutes, (long)seconds];
    }
}

#pragma mark - 获取支持的数据类型

/*
- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    [self logMessage:@"Getting supported data types with enhanced stability (including photos)"];
    
    if (![self isConnected]) {
        [self logMessage:@"[ERR] Device not connected"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // ✅ 使用缓存机制避免重复检测
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    
    // 检查缓存是否有效（5分钟内且同一设备）
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                         (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // 📊 开始检测支持的数据类型
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    [self logMessage:[NSString stringWithFormat:@"Checking %lu data types for support...", (unsigned long)totalCount]];
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        BOOL isSupported = NO;
        
        // 🆕 照片类型使用AFC检查，其他类型使用MobileSync检查
        if ([BackupOptionTask isPhotoMediaType:dataType]) {
            // 照片类型：检查AFC访问能力
            if (_afc || _afc_photos) {
                NSString *testPath = PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM";
                isSupported = [self canAccessPhotoDirectory:testPath error:nil];
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ test (path: %@): %@",
                                 typeName, testPath, isSupported ? @"✅ Supported" : @"❌ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ skipped: AFC not available", typeName]];
                isSupported = NO;
            }
        } else {
            // 非照片类型：使用MobileSync检查（如果可用）
            if (_mobilesync) {
                isSupported = [self isDataTypeSupportedStable:dataType];
                [self logMessage:[NSString stringWithFormat:@"Data type %@ test: %@",
                                 typeName, isSupported ? @"✅ Supported" : @"❌ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Data type %@ skipped: MobileSync not available", typeName]];
                isSupported = NO;
            }
        }
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
        }
        
        // 添加小延迟避免过度请求
        if (typeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.05];  // 减少延迟时间
        }
    }
    
    // 更新缓存
    if (successCount > 0) {
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cacheTime = [NSDate date];
        
        [self logMessage:[NSString stringWithFormat:@"Detection complete: %lu/%lu data types supported (cached for 5 minutes)",
                         (unsigned long)successCount, (unsigned long)totalCount]];
    } else {
        [self logMessage:@"[WAR] No data types detected as supported"];
    }
    
    return supportedTypes;
}*/

- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    [self logMessage:@"Getting supported data types with capability-based detection"];
    
    if (![self isConnected]) {
        [self logMessage:@"❌ Device not connected"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // ✅ 使用缓存机制避免重复检测
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    static DeviceConnectionCapability cachedCapability = DeviceConnectionCapabilityNone;
    
    // 检查缓存是否有效（5分钟内且同一设备且能力相同）
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cachedCapability == _connectionCapability &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu", (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // 📊 开始检测支持的数据类型
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    [self logMessage:[NSString stringWithFormat:@"Checking %lu data types based on connection capability...", (unsigned long)totalCount]];
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        BOOL isSupported = NO;
        
        if ([BackupOptionTask isPhotoMediaType:dataType]) {
            // ✅ 照片类型：基于AFC能力检测
            if (_connectionCapability & DeviceConnectionCapabilityAFC) {
                NSString *testPath = PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM";
                isSupported = [self canAccessPhotoDirectory:testPath error:nil];
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ (AFC): %@",
                                 typeName, isSupported ? @"✅ Supported" : @"❌ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ (AFC): ❌ Not supported - AFC capability missing", typeName]];
                isSupported = NO;
            }
        } else {
            // ✅ 传统类型：基于MobileSync能力检测
            if (_connectionCapability & DeviceConnectionCapabilityMobileSync) {
                isSupported = [self isDataTypeSupportedStable:dataType];
                [self logMessage:[NSString stringWithFormat:@"Traditional type %@ (MobileSync): %@",
                                 typeName, isSupported ? @"✅ Supported" : @"❌ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Traditional type %@ (MobileSync): ❌ Not supported - MobileSync capability missing", typeName]];
                isSupported = NO;
            }
        }
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
        }
        
        // 添加小延迟避免过度请求
        if (typeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.05];
        }
    }
    
    // ✅ 更新缓存
    if (successCount >= 0) { // 即使是0也缓存，避免重复检测
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cachedCapability = _connectionCapability;
        cacheTime = [NSDate date];
        
        [self logMessage:[NSString stringWithFormat:@"Detection complete: %lu/%lu data types supported (cached for 5 minutes)",
                         (unsigned long)successCount, (unsigned long)totalCount]];
        [self logMessage:[NSString stringWithFormat:@"📊 Capability summary: %@", [self getConnectionCapabilityDescription]]];
    }
    
    return supportedTypes;
}

// 🆕 检查照片目录访问能力
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error {
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        return NO;
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        return YES;
    }
    
    return NO;
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    // 🆕 照片类型使用AFC检查
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self canAccessPhotoDirectory:PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM" error:nil];
    }
    
    @try {
        // 使用正确的API创建anchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // 准备正确的参数
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // 正确调用mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // 如果成功启动，需要结束会话
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

// ✅ 新增：稳定的数据类型检测方法（保持原有逻辑）
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    // ✅ 添加连接检查
    if (!_mobilesync) {
        [self logMessage:@"MobileSync未连接，跳过检测"];
        return NO;
    }
    
    @try {
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // ✅ 重要：立即结束会话，避免状态残留
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // ✅ 每次检测后休息，避免设备过载
        [NSThread sleepForTimeInterval:0.2];
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"检测异常: %@", exception.reason]];
        return NO;
    }
}

// ✅ 新增：确保稳定连接方法（保持原有逻辑但避免过度重连）
- (BOOL)ensureStableConnection:(NSError **)error {
    // 检查连接状态
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            [self logMessage:@"[ERR] No device UDID for reconnection"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // 重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // ✅ 简化连接质量检查，避免不必要的重连
    if (_lockdown) {
        // 只做简单的连接测试，不要过度检查
        [self logMessage:@"Connection appears stable"];
        return YES;
    }
    
    [self logMessage:@"[WAR] Connection quality check failed, but not attempting risky reconnection"];
    return YES; // 返回YES避免触发重连循环
}

#pragma mark - 扫描设备数据增强版

- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== 🔧 开始增强版设备真实数据扫描（包含照片）===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // ✅ 首先获取支持的数据类型
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"[WAR] 获取支持的数据类型失败: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"[WAR] 设备不支持任何数据类型的选择性同步");
        return @{};
    }
    
    NSLog(@"设备支持的数据类型掩码: %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // 逐个处理支持的数据类型
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // 只处理设备支持的数据类型
        if (!(supportedTypes & dataType)) {
            NSLog(@"跳过不支持的数据类型: %@", typeName);
            continue;
        }
        
        NSLog(@"正在获取 %@ 的真实数据...", typeName);
        
        // ✅ 使用改进的数据获取方法
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"%@ 支持但无数据: %@ 项", typeName, itemCount);
            } else {
                NSLog(@"%@ 获取成功: %@ 项", typeName, itemCount);
            }
        } else {
            NSLog(@"[WAR] %@ 获取失败或无响应", typeName);
        }
        
        // 添加延迟避免过度请求
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== 🔧 增强版数据扫描完成，共处理 %lu 种数据类型（包含照片）===",
          (unsigned long)realData.count);
    return [realData copy];
}

// ✅ 增强的数据获取方法
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"增强方法获取 %@ 的真实数据", typeName);
    
    // ✅ 连接状态检查
    if (![self isConnected]) {
        NSLog(@"[WAR] 设备未连接，无法获取 %@ 数据", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // 🆕 根据数据类型选择获取方法
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        // 照片类型：使用AFC方法
        items = [self processPhotoDataForType:dataType error:&error];
    } else {
        // 非照片类型：使用MobileSync方法
        int maxAttempts = 3;
        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            if (attempt > 0) {
                NSLog(@"重试获取 %@ 数据 (第 %d 次尝试)", typeName, attempt + 1);
                [NSThread sleepForTimeInterval:0.5];
            }
            
            items = [self getDataItemsForType:dataType error:&error];
            
            if (items && items.count > 0) {
                NSLog(@"第 %d 次尝试成功获取 %@ 数据: %lu 项",
                      attempt + 1, typeName, (unsigned long)items.count);
                break;
            }
            
            if (error) {
                NSLog(@"[WAR] 第 %d 次尝试获取 %@ 数据失败: %@",
                      attempt + 1, typeName, error.localizedDescription);
                error = nil; // 清除错误以便下次尝试
            }
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"[WAR] %@ 最终无法获取到数据", typeName);
    return nil;
}

// ✅ 新增：改进的数据处理方法，更好地处理空数据情况
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"%@ 数据为空，创建空数据字典", typeName]];
        
        // ✅ 即使没有数据也创建一个有效的字典
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ 支持但当前无数据", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // 计算统计信息
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

#pragma mark - 🆕 数据类型工具方法增强

+ (BOOL)isPhotoMediaType:(BackupDataType)dataType {
    BackupDataType photoTypes = (BackupDataTypePhotos | BackupDataTypeVideos | BackupDataTypeCameraRoll |
                                BackupDataTypePhotoAlbums | BackupDataTypePhotoStream | BackupDataTypeScreenshots |
                                BackupDataTypeSlowMotion | BackupDataTypeTimelapses | BackupDataTypeBurstPhotos |
                                BackupDataTypeLivePhotos);
    return (dataType & photoTypes) != 0;
}

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeMailAccounts:
            return @"MailAccounts";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
            
        // 🆕 照片和媒体类型
        case BackupDataTypePhotos:
            return @"Photos";
        case BackupDataTypeVideos:
            return @"Videos";
        case BackupDataTypeCameraRoll:
            return @"Camera Roll";
        case BackupDataTypePhotoAlbums:
            return @"Photo Albums";
        case BackupDataTypePhotoStream:
            return @"Photo Stream";
        case BackupDataTypeScreenshots:
            return @"Screenshots";
        case BackupDataTypeSlowMotion:
            return @"Slow Motion";
        case BackupDataTypeTimelapses:
            return @"Time-lapses";
        case BackupDataTypeBurstPhotos:
            return @"Burst Photos";
        case BackupDataTypeLivePhotos:
            return @"Live Photos";
            
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // 这里可以根据需要添加本地化支持
    // 目前返回英文版本
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeMailAccounts) [array addObject:@(BackupDataTypeMailAccounts)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    // 🆕 照片和媒体类型
    if (dataTypes & BackupDataTypePhotos) [array addObject:@(BackupDataTypePhotos)];
    if (dataTypes & BackupDataTypeVideos) [array addObject:@(BackupDataTypeVideos)];
    if (dataTypes & BackupDataTypeCameraRoll) [array addObject:@(BackupDataTypeCameraRoll)];
    if (dataTypes & BackupDataTypePhotoAlbums) [array addObject:@(BackupDataTypePhotoAlbums)];
    if (dataTypes & BackupDataTypePhotoStream) [array addObject:@(BackupDataTypePhotoStream)];
    if (dataTypes & BackupDataTypeScreenshots) [array addObject:@(BackupDataTypeScreenshots)];
    if (dataTypes & BackupDataTypeSlowMotion) [array addObject:@(BackupDataTypeSlowMotion)];
    if (dataTypes & BackupDataTypeTimelapses) [array addObject:@(BackupDataTypeTimelapses)];
    if (dataTypes & BackupDataTypeBurstPhotos) [array addObject:@(BackupDataTypeBurstPhotos)];
    if (dataTypes & BackupDataTypeLivePhotos) [array addObject:@(BackupDataTypeLivePhotos)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        // 原有数据类型
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper),
        
        // 🆕 新增照片和媒体类型
        @(BackupDataTypePhotos),
        @(BackupDataTypeVideos),
        @(BackupDataTypeCameraRoll),
        @(BackupDataTypePhotoAlbums),
        @(BackupDataTypePhotoStream),
        @(BackupDataTypeScreenshots),
        @(BackupDataTypeSlowMotion),
        @(BackupDataTypeTimelapses),
        @(BackupDataTypeBurstPhotos),
        @(BackupDataTypeLivePhotos)
    ];
}

#pragma mark - 选择性同步操作

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // 异步执行同步操作
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // 分解数据类型为单独的类型
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // 按数据类型分组
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // 对每种数据类型执行同步
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // 这里可以实现更细粒度的项目同步逻辑
        // 目前先使用数据类型级别的同步
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // 创建备份目录
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - 操作控制

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - 同步操作实现

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // 根据方向执行不同的操作
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // 双向同步暂时不实现
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 🆕 检查是否是照片类型，使用不同的备份方法
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self backupPhotoDataType:dataType toPath:path error:error];
    }
    
    // 获取数据项
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // 创建数据类型目录
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // 保存数据项信息
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // 保存备份元数据
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 🆕 检查是否是照片类型，使用不同的恢复方法
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self restorePhotoDataType:dataType fromPath:path error:error];
    }
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - 🆕 照片特定的备份和恢复方法

- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up photo data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 获取照片数据项
    NSArray<SyncDataItem *> *items = [self processPhotoDataForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // 创建数据类型目录
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // 创建照片子目录
    NSString *photosDir = [dataTypeDir stringByAppendingPathComponent:@"Media"];
    NSString *thumbnailsDir = [dataTypeDir stringByAppendingPathComponent:@"Thumbnails"];
    
    [fileManager createDirectoryAtPath:photosDir withIntermediateDirectories:YES attributes:nil error:nil];
    if (self.enableThumbnailGeneration) {
        [fileManager createDirectoryAtPath:thumbnailsDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    // 下载照片文件
    NSUInteger successCount = 0;
    NSUInteger totalCount = items.count;
    
    for (NSUInteger i = 0; i < items.count; i++) {
        if (_cancelRequested) {
            break;
        }
        
        SyncDataItem *item = items[i];
        if (!item.isMediaFile || !item.photoInfo) {
            continue;
        }
        
        // 更新进度
        [self updateProgress:(i * 100.0 / totalCount)
                   operation:[NSString stringWithFormat:@"Downloading %@", item.photoInfo.filename]
                     current:i
                       total:totalCount];
        
        // 下载原始文件
        NSString *destPath = [photosDir stringByAppendingPathComponent:item.photoInfo.filename];
        NSError *downloadError = nil;
        BOOL success = [self downloadPhoto:item.photoInfo toDestination:destPath error:&downloadError];
        
        if (success) {
            successCount++;
            item.localPath = destPath;
            
            // 生成缩略图
            if (self.enableThumbnailGeneration && !item.photoInfo.isVideo) {
                NSString *thumbnailPath = [self generateThumbnailPath:destPath];
                [self createThumbnail:destPath destinationPath:thumbnailPath maxSize:200];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"Failed to download %@: %@",
                             item.photoInfo.filename, downloadError.localizedDescription]];
        }
    }
    
    // 保存照片项信息
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"isMediaFile": @(item.isMediaFile),
            @"localPath": item.localPath ?: @"",
            @"remotePath": item.remotePath ?: @"",
            @"metadata": item.metadata ?: @{},
            @"photoInfo": item.photoInfo ? @{
                @"filename": item.photoInfo.filename ?: @"",
                @"photoID": item.photoInfo.photoID ?: @"",
                @"format": item.photoInfo.format ?: @"",
                @"fileSize": @(item.photoInfo.fileSize),
                @"width": @(item.photoInfo.width),
                @"height": @(item.photoInfo.height),
                @"isVideo": @(item.photoInfo.isVideo),
                @"isLivePhoto": @(item.photoInfo.isLivePhoto),
                @"isBurst": @(item.photoInfo.isBurst),
                @"isScreenshot": @(item.photoInfo.isScreenshot),
                @"isFavorite": @(item.photoInfo.isFavorite),
                @"dateCreated": item.photoInfo.dateCreated ?: [NSDate date],
                @"dateModified": item.photoInfo.dateModified ?: [NSDate date]
            } : @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save photo items data"];
        }
        return NO;
    }
    
    // 保存备份元数据
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"successCount": @(successCount),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown",
        @"photoTransferMode": @(self.photoTransferMode),
        @"includeThumbnails": @(self.enableThumbnailGeneration),
        @"preserveOriginalFormat": @(self.preserveOriginalFormat)
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu/%lu photos of type: %@",
                     (unsigned long)successCount, (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    
    return successCount > 0;
}

- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring photo data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Photo backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Photo backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo restore not yet implemented for %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // TODO: 实现照片上传到设备的功能
    // 这需要使用AFC写入文件到设备的/DCIM目录
    
    return YES;
}

#pragma mark - 便捷方法

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *mailAccountsPath = [_dataStoragePath stringByAppendingPathComponent:@"MailAccounts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeMailAccounts
                                     toDirectory:mailAccountsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupPhotos:(PhotoTransferMode)transferMode
               completion:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *photosPath = [_dataStoragePath stringByAppendingPathComponent:@"Photos"];
    
    // 设置传输模式
    self.photoTransferMode = transferMode;
    
    // 开始备份
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypePhotos
                                     toDirectory:photosPath
                                           error:&error];
    
    if (completion) {
        // 获取照片数量
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypePhotos error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupCameraRoll:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *cameraRollPath = [_dataStoragePath stringByAppendingPathComponent:@"CameraRoll"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCameraRoll
                                     toDirectory:cameraRollPath
                                           error:&error];
    
    if (completion) {
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypeCameraRoll error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // 设置完成回调来捕获结果
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - 数据验证和恢复

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // 尝试读取文件以验证格式
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // 参数验证
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查路径是否存在
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // 确保是目录而不是文件
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // 获取基本信息 - 添加错误处理
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // 设置默认值
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // 扫描数据类型
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // 自动释放池，避免内存累积
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // 检查items.plist是否存在
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // 尝试读取items数据
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // 计算该数据类型的大小
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // 设置汇总信息
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // 添加备份统计信息
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - 调试和诊断工具

- (void)diagnoseDeviceSyncCapabilities {
    
    if (![self isConnected]) {
        [self logMessage:@"Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"✅" : @"❌";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    info[@"isPhotoMediaType"] = @([BackupOptionTask isPhotoMediaType:dataType]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount),
                @"isMediaFile": @(firstItem.isMediaFile)
            };
        }
    }
    
    return info;
}

- (void)diagnosePhotoLibraryAccess {
    [self logMessage:@"=== Photo Library Access Diagnosis ==="];
    
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Device not connected"];
        return;
    }
    
    // 检查AFC服务
    if (!_afc) {
        [self logMessage:@"[WAR] AFC service not available"];
    } else {
        [self logMessage:@"AFC service available"];
    }
    
    if (!_afc_photos) {
        [self logMessage:@"[WAR] Photo AFC service not available, using regular AFC"];
    } else if (_afc_photos == _afc) {
        [self logMessage:@"Using regular AFC for photo access"];
    } else {
        [self logMessage:@"Dedicated photo AFC service available"];
    }
    
    // 测试DCIM目录访问
    NSError *error = nil;
    BOOL hasAccess = [self checkPhotoLibraryAccess:&error];
    
    if (hasAccess) {
        [self logMessage:@"Photo library access confirmed"];
        
        // 扫描各个照片目录
        NSArray *testPaths = @[@"/DCIM", @"/DCIM/100APPLE", @"/PhotoData"];
        
        for (NSString *path in testPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            [self logMessage:[NSString stringWithFormat:@"%@: %lu items", path, (unsigned long)photos.count]];
        }
        
        // 获取统计信息
        NSDictionary *stats = [self getPhotoLibraryStatistics:nil];
        if (stats) {
            [self logMessage:[NSString stringWithFormat:@"Total photos: %@", stats[@"photoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total videos: %@", stats[@"videoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total size: %@", stats[@"formattedSize"]]];
        }
        
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] Photo library access failed: %@", error.localizedDescription]];
    }
    
    [self logMessage:@"=== Photo Library Diagnosis Complete ==="];
}

#pragma mark - 真实数据处理方法实现

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 处理非数组类型的情况
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 返回非数组数据，可能表示空数据集", syncClass]];
        
        // 如果是布尔类型，可能表示同步状态
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ 同步状态: %s",
                             syncClass, bool_val ? "成功" : "失败"]];
        }
        
        return @[]; // 返回空数组而不是失败
    }
    
    // 继续处理数组数据...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // 提取通用字段
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // 根据数据类型提取特定字段
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeMailAccounts:
            [self extractMailAccountSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // 如果没有标识符，使用索引
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // 如果没有名称，使用默认名称
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // 提取记录ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // 提取修改时间
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // 估算数据大小
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // 默认大小
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 姓名字段
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 电话号码
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // 邮箱地址
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 日历标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 开始时间
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // 结束时间
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 书签标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 账户名称
    plist_t account_name = plist_dict_get_item(item_dict, "AccountName");
    if (!account_name) account_name = plist_dict_get_item(item_dict, "EmailAddress");
    
    if (account_name && plist_get_node_type(account_name) == PLIST_STRING) {
        char *name_str = NULL;
        plist_get_string_val(account_name, &name_str);
        if (name_str) {
            item.name = [NSString stringWithUTF8String:name_str];
            free(name_str);
        }
    }
    
    // 服务器信息
    plist_t hostname = plist_dict_get_item(item_dict, "Hostname");
    if (hostname && plist_get_node_type(hostname) == PLIST_STRING) {
        char *host_str = NULL;
        plist_get_string_val(hostname, &host_str);
        if (host_str) {
            metadata[@"hostname"] = [NSString stringWithUTF8String:host_str];
            free(host_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 备忘录标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 内容
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // 大概估算
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 提醒事项标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 完成状态
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // 优先级
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 尝试各种可能的名称字段
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 添加一些通用元数据
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

// getDataItemsSimplified 方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"获取简化数据项 - 类型: %@, 同步类: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // 验证参数
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"同步类参数不能为空"];
        }
        return @[];
    }
    
    // 确保设备连接
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"设备未连接"];
        }
        return @[];
    }
    
    // ✅ 关键修复：移除重复的支持检查
    // 上层代码已经通过 getSupportedDataTypes 验证过支持性，避免重复检查导致状态冲突
    [self logMessage:[NSString stringWithFormat:@"跳过重复支持检查，直接获取 %@ 数据", syncClass]];
    
    // 直接调用数据获取方法
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"成功获取 %@ 数据: %lu 项",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"%@ 数据为空或获取失败", syncClass]];
    }
    
    return items ?: @[];
}

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"使用修复版获取 %@ 数据", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // 添加设备兼容性检查
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // ✅ 关键修复：每次数据获取前都重新建立 MobileSync 连接
        [self logMessage:@"重新建立 MobileSync 连接以确保数据获取稳定性"];
        
        // 强制断开并重建 MobileSync 连接
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // 短暂等待，让设备重置状态
        [NSThread sleepForTimeInterval:0.5];
        
        // 重新启动 MobileSync 服务
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] 重新启动 MobileSync 服务失败: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"MobileSync 连接已重新建立"];
        
        // ✅ 关键修复2：使用与检测时相同的参数
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"[ERR] 创建anchors失败"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // ✅ 关键修复3：使用检测时完全相同的参数
        uint64_t data_class_version = 106;  // 与检测时保持一致
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"使用干净连接启动同步会话: %@", syncClass]];
        
        // ✅ 关键修复4：启动同步会话
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"%@ 同步会话启动成功（干净连接）", syncClass]];
            
            // ✅ 使用更稳定的数据获取方法
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"成功请求 %@ 的所有记录", syncClass]];
                
                // ✅ 改进的数据接收逻辑 - 处理超时和多批次数据
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // 减少最大批次数量
                int timeoutCount = 0;
                int maxTimeouts = 2; // 允许的最大超时次数
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"mobilesync_receive_changes 返回状态: %d (批次 %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // 重置超时计数器
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"处理 %@ 第 %d 批数据",
                                            syncClass, batchCount]];
                            
                            // 🔍 详细分析接收到的数据类型
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"接收到的数据类型: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // 🔧 改进的数据处理：支持多种数据类型
                            NSArray<SyncDataItem *> *batchItems = [self processRealDataForType:dataType
                                                                                     dataArray:entities
                                                                                     syncClass:syncClass];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"从第 %d 批获取到 %lu 项数据",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"第 %d 批数据为空或处理失败", batchCount]];
                            }
                            
                            // 清理resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"第 %d 批 %@ 返回空数据", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // 🔧 改进的超时处理
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"%@ 接收超时 (第 %d 次，共 %d 次)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 超时次数达到上限，停止接收", syncClass]];
                            break;
                        }
                        
                        // 如果已经获取到数据，超时可能是正常的结束信号
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"%@ 已获取到数据，超时可能是正常结束", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[ERR] 接收 %@ 数据时出错: %d",
                                        syncClass, receive_err]];
                        break;
                    }
                    
                    // 防止无限循环
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 达到最大批次限制(%d)，停止接收",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // 如果标记为最后一条记录，直接退出
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"%@ 接收到最后记录标记，正常结束", syncClass]];
                        break;
                    }
                    
                    // 添加小延迟，避免过度请求
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // 使用内部逻辑控制循环
                
                [self logMessage:[NSString stringWithFormat:@"%@ 数据接收完成: %d 批次, %lu 项",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"[WAR] %@ get_all_records失败: %d",
                                syncClass, get_all_err]];
            }
            
            // ✅ 确保会话正确结束
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"%@ 同步会话已结束", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ mobilesync_start失败（干净连接后）: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"错误详情: %s", error_description]];
            }
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // ✅ 即使没有获取到数据也不算错误
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"%@ 没有可用数据（使用干净连接后确认）", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"%@ 最终获取到 %lu 项真实数据（干净连接）",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ 数据获取异常: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}

#pragma mark - 验证和错误处理

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // 增强的类型检查和日志
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // 如果不是数组，尝试处理其他可能的类型
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // 可能表示没有数据或操作失败
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // 如果是true，可能表示成功但无数据
        }
        
        [self logMessage:[NSString stringWithFormat:@"[WAR] Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // 根据错误类型采取不同的处理策略
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // 尝试重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // 快速检查是否支持此数据类型
    return [self isDataTypeSupported:dataType];
}

- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error {
    if (!photoPath || photoPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo path cannot be empty"];
        }
        return NO;
    }
    
    NSString *filename = [photoPath lastPathComponent];
    if (![self isPhotoFile:filename] && ![self isVideoFile:filename]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoFormatUnsupported
                             description:[NSString stringWithFormat:@"Unsupported file format: %@", filename]];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - 私有方法实现

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
        case SyncTaskStatusScanningPhotos:
            return @"Scanning photos";
        case SyncTaskStatusDownloadingPhotos:
            return @"Downloading photos";
        case SyncTaskStatusProcessingMetadata:
            return @"Processing metadata";
        case SyncTaskStatusGeneratingThumbnails:
            return @"Generating thumbnails";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - 工具方法

- (void)logMessage:(NSString *)message {
    NSString *logMessage = [NSString stringWithFormat:@"%@", message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}

- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}

- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}

- (NSString *)sanitizeFilename:(NSString *)filename {
    NSMutableString *sanitized = [filename mutableCopy];
    NSArray *invalidChars = @[@"/", @"\\", @":", @"*", @"?", @"\"", @"<", @">", @"|"];
    
    for (NSString *invalidChar in invalidChars) {
        [sanitized replaceOccurrencesOfString:invalidChar
                                   withString:@"_"
                                      options:NSLiteralSearch
                                        range:NSMakeRange(0, sanitized.length)];
    }
    
    return [sanitized copy];
}

- (NSString *)generateThumbnailPath:(NSString *)originalPath {
    NSString *directory = [[originalPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"Thumbnails"];
    NSString *filename = [originalPath lastPathComponent];
    NSString *nameWithoutExt = [filename stringByDeletingPathExtension];
    NSString *extension = [filename pathExtension];
    
    NSString *thumbnailFilename = [NSString stringWithFormat:@"%@_thumb.%@", nameWithoutExt, extension];
    return [directory stringByAppendingPathComponent:thumbnailFilename];
}

- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize {
    // 这是一个简化的缩略图生成实现
    // 在真实应用中，你需要使用图像处理库（如CoreGraphics、ImageIO等）
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 创建目录
    NSString *destDir = [destPath stringByDeletingLastPathComponent];
    [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    
    // 简单的文件复制作为占位符
    // 在实际实现中，这里应该进行图像缩放
    NSError *error = nil;
    BOOL success = [fileManager copyItemAtPath:sourcePath toPath:destPath error:&error];
    
    if (!success) {
        [self logMessage:[NSString stringWithFormat:@"Failed to create thumbnail: %@", error.localizedDescription]];
    }
    
    return success;
}

// 🆕 安全的字符串转无符号长长整型方法
- (unsigned long long)unsignedLongLongValueFromString:(NSString *)string {
    if (!string || string.length == 0) {
        return 0;
    }
    
    // 方法1: 使用C函数strtoull（推荐）
    const char *cString = [string UTF8String];
    char *endPtr = NULL;
    unsigned long long result = strtoull(cString, &endPtr, 10);
    
    // 如果转换失败，使用备用方法
    if (endPtr == cString) {
        // 方法2: 使用NSScanner作为备用
        NSScanner *scanner = [NSScanner scannerWithString:string];
        unsigned long long scannerResult = 0;
        if ([scanner scanUnsignedLongLong:&scannerResult]) {
            return scannerResult;
        }
        
        // 方法3: 最后的备用方案，使用longLongValue
        long long signedValue = [string longLongValue];
        return (unsigned long long)MAX(0, signedValue);
    }
    
    return result;
}

- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"设备未连接或lockdown未初始化"];
        return;
    }
    
    // 修复1：正确获取设备名称
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"设备名称: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"获取设备名称失败: %d", ret]];
    }
    
    // 修复2：正确获取iOS版本
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"iOS版本: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"[WAR] iOS版本过低，可能不支持选择性同步"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"[WAR] iOS 15+设备，数据格式可能有变化"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] iOS %ld 设备，兼容性良好", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] 获取iOS版本失败: %d", ret]];
    }
    
    // 修复3：正确获取设备型号
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"设备型号: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"获取设备型号失败: %d", ret]];
    }
}

@end


//
//  BackupOptionTask.h
//  iOSBackupManager
//
//  Complete Enhanced Version with Photos/Camera Support - 2025.01.27
//  Based on libimobiledevice mobilesync and AFC APIs
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// 数据类型枚举 - 完整版本，包含照片和媒体支持
typedef NS_OPTIONS(NSUInteger, BackupDataType) {
    BackupDataTypeNone          = 0,
    BackupDataTypeContacts      = 1 << 0,  // 联系人
    BackupDataTypeCalendars     = 1 << 1,  // 日历
    BackupDataTypeBookmarks     = 1 << 2,  // 书签
    BackupDataTypeNotes         = 1 << 3,  // 备忘录
    BackupDataTypeReminders     = 1 << 4,  // 提醒事项
    BackupDataTypeApplications  = 1 << 5,  // 应用数据
    BackupDataTypeConfiguration = 1 << 6,  // 系统配置
    BackupDataTypeKeychain      = 1 << 7,  // 钥匙串
    BackupDataTypeVoiceMemos    = 1 << 8,  // 语音备忘录
    BackupDataTypeWallpaper     = 1 << 9,  // 壁纸设置
    BackupDataTypeMailAccounts  = 1 << 10, // 邮箱设置
    
    // 🆕 新增照片和媒体相关数据类型
    BackupDataTypePhotos        = 1 << 11, // 照片库
    BackupDataTypeVideos        = 1 << 12, // 视频库
    BackupDataTypeCameraRoll    = 1 << 13, // 相机胶卷
    BackupDataTypePhotoAlbums   = 1 << 14, // 相册
    BackupDataTypePhotoStream   = 1 << 15, // 照片流
    BackupDataTypeScreenshots   = 1 << 16, // 截屏
    BackupDataTypeSlowMotion    = 1 << 17, // 慢动作视频
    BackupDataTypeTimelapses    = 1 << 18, // 延时摄影
    BackupDataTypeBurstPhotos   = 1 << 19, // 连拍照片
    BackupDataTypeLivePhotos    = 1 << 20, // Live Photos
    
    // 便捷组合
    BackupDataTypeAllPhotos     = (BackupDataTypePhotos | BackupDataTypeVideos | BackupDataTypeCameraRoll |
                                  BackupDataTypePhotoAlbums | BackupDataTypePhotoStream | BackupDataTypeScreenshots |
                                  BackupDataTypeSlowMotion | BackupDataTypeTimelapses | BackupDataTypeBurstPhotos |
                                  BackupDataTypeLivePhotos),
    BackupDataTypeAll           = NSUIntegerMax  // 所有支持的数据类型
};

// 同步方向枚举
typedef NS_ENUM(NSUInteger, SyncDirection) {
    SyncDirectionFromDevice,    // 从设备到计算机（备份）
    SyncDirectionToDevice,      // 从计算机到设备（恢复）
    SyncDirectionBidirectional  // 双向同步
};

// 🆕 照片传输模式枚举
typedef NS_ENUM(NSUInteger, PhotoTransferMode) {
    PhotoTransferModeOriginal,      // 原始质量
    PhotoTransferModeOptimized,     // 优化质量（较小文件）
    PhotoTransferModeThumbnail,     // 仅缩略图
    PhotoTransferModeMetadataOnly   // 仅元数据
};

// 错误代码
typedef NS_ENUM(NSInteger, BackupOptionTaskErrorCode) {
    BackupOptionTaskErrorCodeSuccess = 0,
    BackupOptionTaskErrorCodeUnknown = -1,
    BackupOptionTaskErrorCodeInvalidArg = -2,
    BackupOptionTaskErrorCodeConnectionFailed = -3,
    BackupOptionTaskErrorCodeOperationFailed = -4,
    BackupOptionTaskErrorCodeDeviceNotFound = -5,
    BackupOptionTaskErrorCodeServiceStartFailed = -6,
    BackupOptionTaskErrorCodeProtocolError = -7,
    BackupOptionTaskErrorCodeUserCancelled = -8,
    BackupOptionTaskErrorCodeDataCorrupted = -9,
    BackupOptionTaskErrorCodePermissionDenied = -10,
    BackupOptionTaskErrorCodeSyncConflict = -11,
    BackupOptionTaskErrorCodeDeviceLocked = -12,
    BackupOptionTaskErrorCodeTimeoutError = -13,
    
    // 🆕 照片相关错误
    BackupOptionTaskErrorCodePhotoLibraryLocked = -20,
    BackupOptionTaskErrorCodeInsufficientStorage = -21,
    BackupOptionTaskErrorCodePhotoFormatUnsupported = -22,
    BackupOptionTaskErrorCodePhotoCorrupted = -23,
    BackupOptionTaskErrorCodeAFCServiceFailed = -24
};

// 同步状态枚举
typedef NS_ENUM(NSUInteger, SyncTaskStatus) {
    SyncTaskStatusIdle,
    SyncTaskStatusConnecting,
    SyncTaskStatusPreparing,
    SyncTaskStatusSyncing,
    SyncTaskStatusCompleted,
    SyncTaskStatusFailed,
    SyncTaskStatusCancelled,
    SyncTaskStatusPaused,
    
    // 🆕 照片相关状态
    SyncTaskStatusScanningPhotos,
    SyncTaskStatusDownloadingPhotos,
    SyncTaskStatusProcessingMetadata,
    SyncTaskStatusGeneratingThumbnails
};



// 枚举后添加新的连接能力枚举
typedef NS_ENUM(NSUInteger, DeviceConnectionCapability) {
    DeviceConnectionCapabilityNone = 0,
    DeviceConnectionCapabilityMobileSync = 1 << 0,  // 支持传统数据(Contacts, Calendars, etc.)
    DeviceConnectionCapabilityAFC = 1 << 1,         // 支持照片数据
    DeviceConnectionCapabilityFull = DeviceConnectionCapabilityMobileSync | DeviceConnectionCapabilityAFC
};

// 🆕 照片信息结构
@interface PhotoInfo : NSObject
@property (nonatomic, strong) NSString *filename;
@property (nonatomic, strong) NSString *photoID;
@property (nonatomic, strong) NSString *albumName;
@property (nonatomic, strong) NSDate *dateCreated;
@property (nonatomic, strong) NSDate *dateModified;
@property (nonatomic, assign) NSUInteger fileSize;
@property (nonatomic, assign) NSUInteger width;
@property (nonatomic, assign) NSUInteger height;
@property (nonatomic, strong) NSString *format; // HEIF, JPEG, PNG, etc.
@property (nonatomic, assign) BOOL isVideo;
@property (nonatomic, assign) BOOL isLivePhoto;
@property (nonatomic, assign) BOOL isBurst;
@property (nonatomic, assign) BOOL isScreenshot;
@property (nonatomic, assign) BOOL isFavorite;
@property (nonatomic, assign) NSTimeInterval videoDuration; // 仅视频
@property (nonatomic, strong, nullable) NSDictionary *exifData; // EXIF数据
@property (nonatomic, strong, nullable) NSDictionary *locationData; // GPS位置信息
@end

// 数据项信息结构 - 增强版本
@interface SyncDataItem : NSObject
@property (nonatomic, strong) NSString *identifier;
@property (nonatomic, strong) NSString *name;
@property (nonatomic, assign) BackupDataType dataType;
@property (nonatomic, strong) NSDate *modificationDate;
@property (nonatomic, assign) NSUInteger recordCount;
@property (nonatomic, assign) NSUInteger dataSize;
@property (nonatomic, assign) BOOL isSelected;
@property (nonatomic, strong, nullable) NSDictionary *metadata; // 额外的元数据

// 🆕 照片相关属性
@property (nonatomic, strong, nullable) PhotoInfo *photoInfo;
@property (nonatomic, strong, nullable) NSString *localPath;  // 本地存储路径
@property (nonatomic, strong, nullable) NSString *remotePath; // 设备上的路径
@property (nonatomic, assign) BOOL isMediaFile; // 是否为媒体文件
@end

// 前向声明
@class BackupOptionTask;

// 进度回调块定义
typedef void (^SyncProgressCallback)(float progress, NSString *operation, NSUInteger current, NSUInteger total);
typedef void (^SyncStatusCallback)(SyncTaskStatus status, NSString *description);
typedef void (^SyncCompletionCallback)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error);
typedef void (^SyncLogCallback)(NSString *logMessage);
typedef void (^DataItemsCallback)(NSArray<SyncDataItem *> *items, BackupDataType dataType);

// 🆕 照片相关回调
typedef void (^PhotoScanProgressCallback)(NSUInteger scannedCount, NSUInteger totalCount);
typedef void (^PhotoDownloadProgressCallback)(NSString *filename, NSUInteger downloadedBytes, NSUInteger totalBytes);
typedef void (^PhotoCompletionCallback)(NSArray<PhotoInfo *> *photos, NSError * _Nullable error);

// 选择性备份任务主类 - 完整增强版本
@interface BackupOptionTask : NSObject

#pragma mark - 单例和初始化
+ (instancetype)sharedInstance;
- (instancetype)initWithDeviceUDID:(NSString * _Nullable)deviceUDID;

#pragma mark - 属性
@property (nonatomic, readonly, strong, nullable) NSString *deviceUDID;
@property (nonatomic, readonly, assign) SyncTaskStatus status;
@property (nonatomic, readonly, assign) float progress;
@property (nonatomic, readonly, strong, nullable) NSError *lastError;
@property (nonatomic, readonly, assign) BOOL isOperating;
@property (nonatomic, readonly, assign) BOOL isPaused;

// 数据存储路径
@property (nonatomic, strong) NSString *dataStoragePath;

// 🆕 照片相关设置
@property (nonatomic, assign) PhotoTransferMode photoTransferMode;
@property (nonatomic, assign) BOOL enableThumbnailGeneration;
@property (nonatomic, assign) NSUInteger maxPhotoResolution; // 最大分辨率，0表示无限制
@property (nonatomic, assign) BOOL preserveOriginalFormat;   // 保留原始格式
@property (nonatomic, assign) BOOL includeHiddenPhotos;      // 包含隐藏照片
@property (nonatomic, assign) BOOL includeLivePhotos;        // 包含Live Photos
@property (nonatomic, assign) BOOL includeVideoFiles;        // 包含视频文件

// 回调设置
@property (nonatomic, copy, nullable) SyncProgressCallback progressCallback;
@property (nonatomic, copy, nullable) SyncStatusCallback statusCallback;
@property (nonatomic, copy, nullable) SyncCompletionCallback completionCallback;
@property (nonatomic, copy, nullable) SyncLogCallback logCallback;
@property (nonatomic, copy, nullable) DataItemsCallback dataItemsCallback;

// 🆕 照片相关回调
@property (nonatomic, copy, nullable) PhotoScanProgressCallback photoScanCallback;
@property (nonatomic, copy, nullable) PhotoDownloadProgressCallback photoDownloadCallback;
@property (nonatomic, copy, nullable) PhotoCompletionCallback photoCompletionCallback;

@property (nonatomic, assign, readonly) DeviceConnectionCapability connectionCapability;


#pragma mark - 设备连接和查询
/**
 * 连接到指定设备
 * @param deviceUDID 设备UDID
 * @param error 错误信息
 * @return 是否连接成功
 */
- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error;

/**
 * 🆕 扫描设备真实数据（包含照片）
 */
- (NSDictionary *)scanRealDeviceDataEnhanced;

/**
 * 断开设备连接
 */
- (void)disconnectDevice;

/**
 * 检查设备连接状态
 * @return 是否已连接
 */
- (BOOL)isConnected;

/**
 * 获取设备支持的数据类型
 * @param error 错误信息
 * @return 支持的数据类型掩码
 */
- (BackupDataType)getSupportedDataTypes:(NSError **)error;

/**
 * 检查特定数据类型是否支持
 * @param dataType 数据类型
 * @return 是否支持
 */
- (BOOL)isDataTypeSupported:(BackupDataType)dataType;

#pragma mark - 🆕 照片库访问功能
/**
 * 检查设备照片库访问权限
 * @param error 错误信息
 * @return 是否有访问权限
 */
- (BOOL)checkPhotoLibraryAccess:(NSError **)error;

/**
 * 扫描设备照片库
 * @param albumNames 指定相册名称，nil表示扫描所有
 * @param error 错误信息
 * @return 照片信息数组
 */
- (NSArray<PhotoInfo *> * _Nullable)scanPhotoLibrary:(NSArray<NSString *> * _Nullable)albumNames error:(NSError **)error;

/**
 * 异步扫描照片库
 * @param albumNames 指定相册名称
 * @param progressCallback 进度回调
 * @param completion 完成回调
 */
- (void)scanPhotoLibraryAsync:(NSArray<NSString *> * _Nullable)albumNames
                     progress:(PhotoScanProgressCallback _Nullable)progressCallback
                   completion:(PhotoCompletionCallback)completion;

/**
 * 获取照片库统计信息
 * @param error 错误信息
 * @return 统计信息字典
 */
- (NSDictionary * _Nullable)getPhotoLibraryStatistics:(NSError **)error;

/**
 * 下载指定照片到本地
 * @param photoInfo 照片信息
 * @param destinationPath 目标路径
 * @param error 错误信息
 * @return 是否下载成功
 */
- (BOOL)downloadPhoto:(PhotoInfo *)photoInfo
        toDestination:(NSString *)destinationPath
                error:(NSError **)error;

/**
 * 批量下载照片
 * @param photos 照片数组
 * @param destinationDir 目标目录
 * @param progressCallback 进度回调
 * @param completion 完成回调
 */
- (void)downloadPhotos:(NSArray<PhotoInfo *> *)photos
      toDestinationDir:(NSString *)destinationDir
              progress:(PhotoDownloadProgressCallback _Nullable)progressCallback
            completion:(void (^)(NSUInteger successCount, NSUInteger failedCount, NSError * _Nullable error))completion;

#pragma mark - 数据查询
/**
 * 获取指定数据类型的所有数据项
 * @param dataType 数据类型
 * @param error 错误信息
 * @return 数据项数组
 */
- (NSArray<SyncDataItem *> * _Nullable)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error;

/**
 * 异步获取数据项（推荐用于大量数据）
 * @param dataType 数据类型
 * @param completion 完成回调
 */
- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion;

/**
 * 获取数据类型的统计信息
 * @param dataType 数据类型
 * @param error 错误信息
 * @return 统计信息字典
 */
- (NSDictionary * _Nullable)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error;

#pragma mark - 选择性同步操作
/**
 * 开始选择性同步
 * @param dataTypes 要同步的数据类型掩码
 * @param direction 同步方向
 * @param error 错误信息
 * @return 是否成功开始
 */
- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error;

/**
 * 同步特定数据项
 * @param items 要同步的数据项数组
 * @param direction 同步方向
 * @param error 错误信息
 * @return 是否成功开始同步
 */
- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error;

/**
 * 备份选定的数据类型到指定路径
 * @param dataTypes 数据类型掩码
 * @param backupPath 备份存储路径
 * @param error 错误信息
 * @return 是否成功开始备份
 */
- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error;

/**
 * 从指定路径恢复数据到设备
 * @param dataTypes 数据类型掩码
 * @param backupPath 备份路径
 * @param error 错误信息
 * @return 是否成功开始恢复
 */
- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error;


- (BOOL)canSyncTraditionalDataTypes;
- (BOOL)canSyncPhotoDataTypes;
- (NSString *)getConnectionCapabilityDescription;
- (void)diagnoseServiceCapabilities;

#pragma mark - 操作控制
/**
 * 取消当前同步操作
 */
- (void)cancelCurrentOperation;

/**
 * 暂停当前操作
 */
- (void)pauseCurrentOperation;

/**
 * 恢复暂停的操作
 */
- (void)resumeCurrentOperation;

/**
 * 获取当前操作进度
 * @return 进度百分比 (0.0-100.0)
 */
- (float)getCurrentProgress;

#pragma mark - 数据类型工具方法
/**
 * 将数据类型转换为字符串描述
 * @param dataType 数据类型
 * @return 描述字符串
 */
+ (NSString *)stringForDataType:(BackupDataType)dataType;

/**
 * 将数据类型转换为本地化字符串
 * @param dataType 数据类型
 * @return 本地化描述字符串
 */
+ (NSString *)localizedStringForDataType:(BackupDataType)dataType;

/**
 * 将数据类型掩码转换为数组
 * @param dataTypes 数据类型掩码
 * @return 数据类型数组
 */
+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes;

/**
 * 将数据类型数组转换为掩码
 * @param dataTypeArray 数据类型数组
 * @return 数据类型掩码
 */
+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray;

/**
 * 获取所有可用的数据类型
 * @return 所有数据类型的数组
 */
+ (NSArray<NSNumber *> *)getAllAvailableDataTypes;

/**
 * 🆕 检查数据类型是否为照片/媒体类型
 * @param dataType 数据类型
 * @return 是否为照片/媒体类型
 */
+ (BOOL)isPhotoMediaType:(BackupDataType)dataType;

#pragma mark - 便捷方法
/**
 * 快速备份联系人
 * @param completion 完成回调
 */
- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份日历
 * @param completion 完成回调
 */
- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份书签
 * @param completion 完成回调
 */
- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份邮箱账户
 * @param completion 完成回调
 */
- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份备忘录
 * @param completion 完成回调
 */
- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份提醒事项
 * @param completion 完成回调
 */
- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 🆕 快速备份照片库
 * @param transferMode 传输模式
 * @param completion 完成回调
 */
- (void)quickBackupPhotos:(PhotoTransferMode)transferMode
               completion:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion;

/**
 * 🆕 快速备份相机胶卷
 * @param completion 完成回调
 */
- (void)quickBackupCameraRoll:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion;

/**
 * 快速备份所有支持的数据类型
 * @param completion 完成回调
 */
- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion;

#pragma mark - 数据验证和恢复
/**
 * 验证备份数据的完整性
 * @param backupPath 备份路径
 * @param dataTypes 要验证的数据类型
 * @param error 错误信息
 * @return 验证结果
 */
- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error;

/**
 * 获取备份数据的详细信息
 * @param backupPath 备份路径
 * @param error 错误信息
 * @return 备份信息字典
 */
- (NSDictionary * _Nullable)getBackupInfo:(NSString *)backupPath error:(NSError **)error;

#pragma mark - 调试和诊断工具
/**
 * 诊断设备同步能力
 */
- (void)diagnoseDeviceSyncCapabilities;

/**
 * 获取详细的数据类型信息（用于调试）
 * @param dataType 数据类型
 * @return 数据类型详细信息
 */
- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType;

/**
 * 🆕 诊断设备照片库访问能力
 */
- (void)diagnosePhotoLibraryAccess;

@end

NS_ASSUME_NONNULL_END


-----------------------------

V2的日志：

2025-05-29 13:28:36.208865+0800 MFCTOOL.bin[73786:14262979] DeviceBackupRestore: 🔧 启动修复版选择性备份
2025-05-29 13:28:36.209168+0800 MFCTOOL.bin[73786:14262979] Internal disconnecting device...
2025-05-29 13:28:36.209336+0800 MFCTOOL.bin[73786:14262979] Device disconnection completed, capability reset to None
2025-05-29 13:28:36.209440+0800 MFCTOOL.bin[73786:14262979] Device disconnection completed
2025-05-29 13:28:37.210627+0800 MFCTOOL.bin[73786:14262979] Connecting to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.210933+0800 MFCTOOL.bin[73786:14262979] Status changed: 0 -> 1
2025-05-29 13:28:37.212404+0800 MFCTOOL.bin[73786:14262979] Device connection established
2025-05-29 13:28:37.267719+0800 MFCTOOL.bin[73786:14262979] Lockdown connection established
2025-05-29 13:28:37.267965+0800 MFCTOOL.bin[73786:14262979] Starting MobileSync service...
2025-05-29 13:28:37.274956+0800 MFCTOOL.bin[73786:14262979] MobileSync service start attempt 1: lockdownd_start_service returned 0
2025-05-29 13:28:37.275056+0800 MFCTOOL.bin[73786:14262979] MobileSync service descriptor created successfully (port: 50543)
2025-05-29 13:28:37.367266+0800 MFCTOOL.bin[73786:14262979] mobilesync_client_new returned 0
2025-05-29 13:28:37.367496+0800 MFCTOOL.bin[73786:14262979] MobileSync client created successfully
2025-05-29 13:28:37.367573+0800 MFCTOOL.bin[73786:14262979] ✅ MobileSync service available - Traditional data types (Contacts, Calendars, etc.) supported
2025-05-29 13:28:37.371461+0800 MFCTOOL.bin[73786:14262979] AFC service started successfully
2025-05-29 13:28:37.371550+0800 MFCTOOL.bin[73786:14262979] ✅ AFC service available - Photo data types supported
2025-05-29 13:28:37.383061+0800 MFCTOOL.bin[73786:14262979] AFC2 service not available, using regular AFC for photos
2025-05-29 13:28:37.383152+0800 MFCTOOL.bin[73786:14262979] ✅ Photo AFC service started successfully
2025-05-29 13:28:37.383201+0800 MFCTOOL.bin[73786:14262979] ✅ Successfully connected to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.383290+0800 MFCTOOL.bin[73786:14262979] 📊 Connection capability: Full capability (Traditional data + Photos) - Both MobileSync and AFC available
2025-05-29 13:28:37.383342+0800 MFCTOOL.bin[73786:14262979] Status changed: 1 -> 0
2025-05-29 13:28:37.383449+0800 MFCTOOL.bin[73786:14263179] Connecting to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.383530+0800 MFCTOOL.bin[73786:14263179] Already connected to device: 00008030-0008352034B9802E (MobileSync: Yes, AFC: Yes)
2025-05-29 13:28:37.392975+0800 MFCTOOL.bin[73786:14263179] === 确保设备连接和初始化 ===
2025-05-29 13:28:37.393018+0800 MFCTOOL.bin[73786:14262979] 选择性备份状态更新: Connecting to device
2025-05-29 13:28:37.393095+0800 MFCTOOL.bin[73786:14263179] Internal disconnecting device...
2025-05-29 13:28:37.393123+0800 MFCTOOL.bin[73786:14262979] 选择性备份状态更新: Idle
2025-05-29 13:28:37.393179+0800 MFCTOOL.bin[73786:14263179] AFC client freed
2025-05-29 13:28:37.393457+0800 MFCTOOL.bin[73786:14263179] MobileSync client freed
2025-05-29 13:28:37.394628+0800 MFCTOOL.bin[73786:14263179] Lockdown client freed
2025-05-29 13:28:37.394685+0800 MFCTOOL.bin[73786:14263179] Device connection freed
2025-05-29 13:28:37.394719+0800 MFCTOOL.bin[73786:14263179] Device disconnection completed, capability reset to None
2025-05-29 13:28:37.394751+0800 MFCTOOL.bin[73786:14263179] Device disconnection completed
2025-05-29 13:28:37.899877+0800 MFCTOOL.bin[73786:14263179] Connecting to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.900136+0800 MFCTOOL.bin[73786:14263179] Status changed: 0 -> 1
2025-05-29 13:28:37.901844+0800 MFCTOOL.bin[73786:14263179] Device connection established
2025-05-29 13:28:37.907407+0800 MFCTOOL.bin[73786:14262979] 选择性备份状态更新: Connecting to device
2025-05-29 13:28:37.953409+0800 MFCTOOL.bin[73786:14263179] Lockdown connection established
2025-05-29 13:28:37.953627+0800 MFCTOOL.bin[73786:14263179] Starting MobileSync service...
2025-05-29 13:28:37.960253+0800 MFCTOOL.bin[73786:14263179] MobileSync service start attempt 1: lockdownd_start_service returned 0
2025-05-29 13:28:37.960382+0800 MFCTOOL.bin[73786:14263179] MobileSync service descriptor created successfully (port: 50548)
2025-05-29 13:29:18.037318+0800 MFCTOOL.bin[73786:14263179] mobilesync_client_new returned -5
2025-05-29 13:29:18.037682+0800 MFCTOOL.bin[73786:14263179] [ERR] MobileSync client creation failed (attempt 1): -5
2025-05-29 13:29:18.037795+0800 MFCTOOL.bin[73786:14263179] [WAR] Retrying MobileSync in 1 seconds...
2025-05-29 13:29:19.061107+0800 MFCTOOL.bin[73786:14263179] MobileSync service start attempt 2: lockdownd_start_service returned 0
2025-05-29 13:29:19.061318+0800 MFCTOOL.bin[73786:14263179] MobileSync service descriptor created successfully (port: 50580)
2025-05-29 13:29:19.097476+0800 MFCTOOL.bin[73786:14263179] mobilesync_client_new returned 0
2025-05-29 13:29:19.097627+0800 MFCTOOL.bin[73786:14263179] MobileSync client created successfully
2025-05-29 13:29:19.097691+0800 MFCTOOL.bin[73786:14263179] ✅ MobileSync service available - Traditional data types (Contacts, Calendars, etc.) supported
2025-05-29 13:29:19.101355+0800 MFCTOOL.bin[73786:14263179] AFC service started successfully
2025-05-29 13:29:19.101466+0800 MFCTOOL.bin[73786:14263179] ✅ AFC service available - Photo data types supported
2025-05-29 13:29:19.105710+0800 MFCTOOL.bin[73786:14263179] AFC2 service not available, using regular AFC for photos
2025-05-29 13:29:19.105783+0800 MFCTOOL.bin[73786:14263179] ✅ Photo AFC service started successfully
2025-05-29 13:29:19.105826+0800 MFCTOOL.bin[73786:14263179] ✅ Successfully connected to device: 00008030-0008352034B9802E
2025-05-29 13:29:19.105867+0800 MFCTOOL.bin[73786:14263179] 📊 Connection capability: Full capability (Traditional data + Photos) - Both MobileSync and AFC available
2025-05-29 13:29:19.105907+0800 MFCTOOL.bin[73786:14263179] Status changed: 1 -> 0
2025-05-29 13:29:19.105949+0800 MFCTOOL.bin[73786:14263179] ✅ 设备连接成功
2025-05-29 13:29:19.106029+0800 MFCTOOL.bin[73786:14263179] Device UDID: 00008030-0008352034B9802E
2025-05-29 13:29:19.106202+0800 MFCTOOL.bin[73786:14262979] 选择性备份状态更新: Idle
2025-05-29 13:29:19.146898+0800 MFCTOOL.bin[73786:14263179] ✅ Contacts (com.apple.Contacts)
2025-05-29 13:29:19.205766+0800 MFCTOOL.bin[73786:14263179] ✅ Calendars (com.apple.Calendars)
2025-05-29 13:29:19.232658+0800 MFCTOOL.bin[73786:14263179] ✅ Bookmarks (com.apple.Bookmarks)
2025-05-29 13:29:19.244533+0800 MFCTOOL.bin[73786:14263179] ✅ MailAccounts (com.apple.MailAccounts)
2025-05-29 13:29:19.247338+0800 MFCTOOL.bin[73786:14263179] ❌ Notes (com.apple.Notes)
2025-05-29 13:29:19.247410+0800 MFCTOOL.bin[73786:14263179] ❌ Reminders (com.apple.Reminders)
2025-05-29 13:29:19.247457+0800 MFCTOOL.bin[73786:14263179] ❌ Applications (com.apple.MobileApplication)
2025-05-29 13:29:19.247496+0800 MFCTOOL.bin[73786:14263179] ❌ Configuration (com.apple.SystemConfiguration)
2025-05-29 13:29:19.247547+0800 MFCTOOL.bin[73786:14263179] ❌ Keychain (com.apple.Keychain)
2025-05-29 13:29:19.247582+0800 MFCTOOL.bin[73786:14263179] ❌ Voice Memos (com.apple.VoiceMemos)
2025-05-29 13:29:19.247616+0800 MFCTOOL.bin[73786:14263179] ❌ Wallpaper (com.apple.Wallpaper)
2025-05-29 13:29:19.249034+0800 MFCTOOL.bin[73786:14263179] ✅ Photos (com.apple.Photos)
2025-05-29 13:29:19.249860+0800 MFCTOOL.bin[73786:14263179] ✅ Videos (com.apple.MediaAssets)
2025-05-29 13:29:19.250704+0800 MFCTOOL.bin[73786:14263179] ✅ Camera Roll (com.apple.CameraRoll)
2025-05-29 13:29:19.251506+0800 MFCTOOL.bin[73786:14263179] ❌ Photo Albums (com.apple.PhotoAlbums)
2025-05-29 13:29:19.252128+0800 MFCTOOL.bin[73786:14263179] ❌ Photo Stream (com.apple.PhotoStream)
2025-05-29 13:29:19.252584+0800 MFCTOOL.bin[73786:14263179] ❌ Screenshots (com.apple.Screenshots)
2025-05-29 13:29:19.253196+0800 MFCTOOL.bin[73786:14263179] ❌ Slow Motion (com.apple.SlowMotion)
2025-05-29 13:29:19.254098+0800 MFCTOOL.bin[73786:14263179] ❌ Time-lapses (com.apple.Timelapses)
2025-05-29 13:29:19.254965+0800 MFCTOOL.bin[73786:14263179] ❌ Burst Photos (com.apple.BurstPhotos)
2025-05-29 13:29:19.256148+0800 MFCTOOL.bin[73786:14263179] ❌ Live Photos (com.apple.LivePhotos)
2025-05-29 13:29:19.256200+0800 MFCTOOL.bin[73786:14263179] Total: 7/21 data types supported
2025-05-29 13:29:19.256240+0800 MFCTOOL.bin[73786:14263179] ✅ 设备连接和初始化完成
2025-05-29 13:29:19.256278+0800 MFCTOOL.bin[73786:14263179] === 🔧 开始增强版设备真实数据扫描（包含照片）===
2025-05-29 13:29:19.256322+0800 MFCTOOL.bin[73786:14263179] Getting supported data types with capability-based detection
2025-05-29 13:29:19.256365+0800 MFCTOOL.bin[73786:14263179] Checking 21 data types based on connection capability...
2025-05-29 13:29:19.461503+0800 MFCTOOL.bin[73786:14263179] Traditional type Contacts (MobileSync): ❌ Not supported
2025-05-29 13:29:19.718282+0800 MFCTOOL.bin[73786:14263179] Traditional type Calendars (MobileSync): ❌ Not supported
2025-05-29 13:29:19.975068+0800 MFCTOOL.bin[73786:14263179] Traditional type Bookmarks (MobileSync): ❌ Not supported
2025-05-29 13:29:20.234082+0800 MFCTOOL.bin[73786:14263179] Traditional type MailAccounts (MobileSync): ❌ Not supported
2025-05-29 13:29:20.494481+0800 MFCTOOL.bin[73786:14263179] Traditional type Notes (MobileSync): ❌ Not supported
2025-05-29 13:29:20.754897+0800 MFCTOOL.bin[73786:14263179] Traditional type Reminders (MobileSync): ❌ Not supported
2025-05-29 13:29:21.015058+0800 MFCTOOL.bin[73786:14263179] Traditional type Applications (MobileSync): ❌ Not supported
2025-05-29 13:29:21.272970+0800 MFCTOOL.bin[73786:14263179] Traditional type Configuration (MobileSync): ❌ Not supported
2025-05-29 13:29:21.533149+0800 MFCTOOL.bin[73786:14263179] Traditional type Keychain (MobileSync): ❌ Not supported
2025-05-29 13:29:21.791707+0800 MFCTOOL.bin[73786:14263179] Traditional type Voice Memos (MobileSync): ❌ Not supported
2025-05-29 13:29:22.047414+0800 MFCTOOL.bin[73786:14263179] Traditional type Wallpaper (MobileSync): ❌ Not supported
2025-05-29 13:29:22.101301+0800 MFCTOOL.bin[73786:14263179] Photo type Photos (AFC): ✅ Supported
2025-05-29 13:29:22.155478+0800 MFCTOOL.bin[73786:14263179] Photo type Videos (AFC): ✅ Supported
2025-05-29 13:29:22.209910+0800 MFCTOOL.bin[73786:14263179] Photo type Camera Roll (AFC): ✅ Supported
2025-05-29 13:29:22.266844+0800 MFCTOOL.bin[73786:14263179] Photo type Photo Albums (AFC): ❌ Not supported
2025-05-29 13:29:22.323087+0800 MFCTOOL.bin[73786:14263179] Photo type Photo Stream (AFC): ❌ Not supported
2025-05-29 13:29:22.376133+0800 MFCTOOL.bin[73786:14263179] Photo type Screenshots (AFC): ❌ Not supported
2025-05-29 13:29:22.432756+0800 MFCTOOL.bin[73786:14263179] Photo type Slow Motion (AFC): ❌ Not supported
2025-05-29 13:29:22.490063+0800 MFCTOOL.bin[73786:14263179] Photo type Time-lapses (AFC): ❌ Not supported
2025-05-29 13:29:22.544290+0800 MFCTOOL.bin[73786:14263179] Photo type Burst Photos (AFC): ❌ Not supported
2025-05-29 13:29:22.601710+0800 MFCTOOL.bin[73786:14263179] Photo type Live Photos (AFC): ❌ Not supported
2025-05-29 13:29:22.602005+0800 MFCTOOL.bin[73786:14263179] Detection complete: 3/21 data types supported (cached for 5 minutes)
2025-05-29 13:29:22.602110+0800 MFCTOOL.bin[73786:14263179] 📊 Capability summary: Full capability (Traditional data + Photos) - Both MobileSync and AFC available
2025-05-29 13:29:22.602199+0800 MFCTOOL.bin[73786:14263179] 设备支持的数据类型掩码: 14336
2025-05-29 13:29:22.602284+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Contacts
2025-05-29 13:29:22.602355+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Calendars
2025-05-29 13:29:22.602423+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Bookmarks
2025-05-29 13:29:22.602490+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: MailAccounts
2025-05-29 13:29:22.602586+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Notes
2025-05-29 13:29:22.602758+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Reminders
2025-05-29 13:29:22.602996+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Applications
2025-05-29 13:29:22.603195+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Configuration
2025-05-29 13:29:22.603409+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Keychain
2025-05-29 13:29:22.603533+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Voice Memos
2025-05-29 13:29:22.603656+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Wallpaper
2025-05-29 13:29:22.603827+0800 MFCTOOL.bin[73786:14263179] 正在获取 Photos 的真实数据...
2025-05-29 13:29:22.603990+0800 MFCTOOL.bin[73786:14263179] 增强方法获取 Photos 的真实数据
2025-05-29 13:29:22.604074+0800 MFCTOOL.bin[73786:14263179] Processing photo data for type: Photos
2025-05-29 13:29:22.618887+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM/100APPLE
2025-05-29 13:29:22.619005+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM
2025-05-29 13:29:22.619290+0800 MFCTOOL.bin[73786:14263179] Processed 1 photo items for type: Photos
2025-05-29 13:29:22.619393+0800 MFCTOOL.bin[73786:14263179] Photos 获取成功: 1 项
2025-05-29 13:29:22.924510+0800 MFCTOOL.bin[73786:14263179] 正在获取 Videos 的真实数据...
2025-05-29 13:29:22.924754+0800 MFCTOOL.bin[73786:14263179] 增强方法获取 Videos 的真实数据
2025-05-29 13:29:22.924857+0800 MFCTOOL.bin[73786:14263179] Processing photo data for type: Videos
2025-05-29 13:29:22.938520+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM/100APPLE
2025-05-29 13:29:22.938636+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM
2025-05-29 13:29:22.938824+0800 MFCTOOL.bin[73786:14263179] Processed 1 photo items for type: Videos
2025-05-29 13:29:22.938935+0800 MFCTOOL.bin[73786:14263179] Videos 获取成功: 1 项
2025-05-29 13:29:23.244067+0800 MFCTOOL.bin[73786:14263179] 正在获取 Camera Roll 的真实数据...
2025-05-29 13:29:23.244331+0800 MFCTOOL.bin[73786:14263179] 增强方法获取 Camera Roll 的真实数据
2025-05-29 13:29:23.244441+0800 MFCTOOL.bin[73786:14263179] Processing photo data for type: Camera Roll
2025-05-29 13:29:23.253467+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM/100APPLE
2025-05-29 13:29:23.253660+0800 MFCTOOL.bin[73786:14263179] Processed 2 photo items for type: Camera Roll
2025-05-29 13:29:23.253778+0800 MFCTOOL.bin[73786:14263179] Camera Roll 获取成功: 2 项
2025-05-29 13:29:23.558902+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Photo Albums
2025-05-29 13:29:23.559145+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Photo Stream
2025-05-29 13:29:23.559227+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Screenshots
2025-05-29 13:29:23.559302+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Slow Motion
2025-05-29 13:29:23.559372+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Time-lapses
2025-05-29 13:29:23.559442+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Burst Photos
2025-05-29 13:29:23.559509+0800 MFCTOOL.bin[73786:14263179] 跳过不支持的数据类型: Live Photos
2025-05-29 13:29:23.559581+0800 MFCTOOL.bin[73786:14263179] === 🔧 增强版数据扫描完成，共处理 3 种数据类型（包含照片）===
2025-05-29 13:29:23.559717+0800 MFCTOOL.bin[73786:14262979] === 真实设备数据获取结果 ===
2025-05-29 13:29:23.559945+0800 MFCTOOL.bin[73786:14262979] === 结果记录完成 ===
2025-05-29 13:29:23.560030+0800 MFCTOOL.bin[73786:14262979] DeviceBackupRestore: 创建增强的选择性备份窗口
2025-05-29 13:29:23.586689+0800 MFCTOOL.bin[73786:14262979] DeviceBackupRestore: 增强的选择性备份窗口已显示
