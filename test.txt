//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Created based on libimobiledevice mobilesync API
//  Provides selective backup functionality using mobilesync protocol
//
//  Final Version - 2025.01.27
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// 引入 libimobiledevice 相关头文件
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// 常量定义
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// 基于实际iOS同步类的数据类型映射
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        // 基于实际的iOS同步服务类标识符
        map = @{
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.WebBookmarks",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper"
        };
    });
    return map;
}

// 获取已知的同步类列表 - 用于检测支持的数据类型
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.WebBookmarks",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - SyncDataItem 实现

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
            self.name, self.identifier, @(self.recordCount)];
}

@end

#pragma mark - BackupOptionTask 内部接口

@interface BackupOptionTask () {
    // libimobiledevice C API 指针
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // 操作状态
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // 同步上下文
    dispatch_queue_t _operationQueue;
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;
    
    // 当前操作参数
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // 内部状态
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
}

// 私有方法声明
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// 真实数据处理方法
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// 数据获取方法
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// 同步操作方法
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// 验证和错误处理
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;

// 工具方法
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;

@end

#pragma mark - BackupOptionTask 实现

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;

#pragma mark - 单例和初始化

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        
        // 设置默认数据存储路径
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        
        [self logMessage:[NSString stringWithFormat:@"BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}

- (void)dealloc {
    [self logMessage:@"BackupOptionTask deallocating and cleaning up resources"];
    [self disconnectDevice];
}

#pragma mark - 设备连接和查询

- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
    
    if (!deviceUDID || deviceUDID.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Device UDID cannot be empty"];
        }
        return NO;
    }
    
    // 如果已经连接到同一设备，直接返回成功
    if ([_deviceUDID isEqualToString:deviceUDID] && _device && _lockdown && _mobilesync) {
        [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@", deviceUDID]];
        return YES;
    }
    
    // 先断开现有连接
    [self disconnectDevice];
    
    _deviceUDID = [deviceUDID copy];
    return [self connectToDeviceInternal:deviceUDID error:error];
}

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. 连接设备
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. 创建lockdown客户端
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // 3. 启动mobilesync服务
    if (![self startMobileSyncService:error]) {
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@", deviceUDID]];
    [self setInternalStatus:SyncTaskStatusIdle];
    return YES;
}

- (BOOL)startMobileSyncService:(NSError **)error {
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS || !service || service->port == 0) {
        NSString *desc = [NSString stringWithFormat:@"Failed to start mobilesync service: %d", ldret];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:desc];
        }
        return NO;
    }
    
    mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
    lockdownd_service_descriptor_free(service);
    
    if (err != MOBILESYNC_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to create mobilesync client: %d", err];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"MobileSync service started successfully"];
    return YES;
}

- (void)disconnectDevice {
    [self logMessage:@"Disconnecting device"];
    
    if (_mobilesync) {
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
    }
    
    if (_afc) {
        afc_client_free(_afc);
        _afc = NULL;
    }
    
    if (_np) {
        np_client_free(_np);
        _np = NULL;
    }
    
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
    }
    
    if (_device) {
        idevice_free(_device);
        _device = NULL;
    }
    
    [self setInternalStatus:SyncTaskStatusIdle];
}

- (BOOL)isConnected {
    return (_device != NULL && _lockdown != NULL && _mobilesync != NULL);
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    @try {
        // 使用正确的API创建anchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // 准备正确的参数
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // 正确调用mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // 如果成功启动，需要结束会话
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    [self logMessage:@"Getting supported data types"];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // 逐个检查每种数据类型的支持性
    NSArray *allDataTypes = @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
    
    for (NSNumber *dataTypeNum in allDataTypes) {
        BackupDataType dataType = [dataTypeNum unsignedIntegerValue];
        
        if ([self isDataTypeSupported:dataType]) {
            supportedTypes |= dataType;
            [self logMessage:[NSString stringWithFormat:@"Supported data type: %@", [BackupOptionTask stringForDataType:dataType]]];
        } else {
            [self logMessage:[NSString stringWithFormat:@"Unsupported data type: %@", [BackupOptionTask stringForDataType:dataType]]];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Total supported data types: %lu", (unsigned long)supportedTypes]];
    return supportedTypes;
}

#pragma mark - 数据查询

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // 检查缓存
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // 使用真实的数据获取方法
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // 缓存结果
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - 真实数据获取实现

- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"Getting real device data for type: %@ (class: %@)",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // 统一使用真实的mobilesync数据获取
    return [self getGenericDataViaMobileSync:dataType syncClass:syncClass error:error];
}

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"Getting real data from device for: %@", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    @try {
        // Step 1: 创建mobilesync anchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // Step 2: 准备mobilesync_start的参数
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // Step 3: 启动同步会话
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"MobileSync session started for %@", syncClass]];
            
            // Step 4: 请求所有记录
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:@"Successfully requested all records from device"];
                
                // Step 5: 接收变更数据
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS && entities) {
                        batchCount++;
                        [self logMessage:[NSString stringWithFormat:@"Processing batch %d for %@",
                                        batchCount, syncClass]];
                        
                        // 处理这批数据
                        NSArray<SyncDataItem *> *batchItems = [self processRealDataForType:dataType
                                                                                 dataArray:entities
                                                                                 syncClass:syncClass];
                        if (batchItems && batchItems.count > 0) {
                            [allItems addObjectsFromArray:batchItems];
                            [self logMessage:[NSString stringWithFormat:@"Added %lu items from batch %d",
                                           (unsigned long)batchItems.count, batchCount]];
                        }
                        
                        // 清理entities
                        plist_free(entities);
                        entities = NULL;
                        
                        // 清理actions
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err != MOBILESYNC_E_SUCCESS) {
                        [self logMessage:[NSString stringWithFormat:@"Error receiving changes: %d", receive_err]];
                        [self handleSyncError:receive_err forDataType:dataType operation:@"receive_changes"];
                        break;
                    }
                    
                } while (!is_last_record);
                
                [self logMessage:[NSString stringWithFormat:@"Completed receiving data, processed %d batches", batchCount]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"mobilesync_get_all_records_from_device failed: %d", get_all_err]];
                [self handleSyncError:get_all_err forDataType:dataType operation:@"get_all_records"];
            }
            
            // Step 6: 结束同步会话
            mobilesync_finish(_mobilesync);
            [self logMessage:@"MobileSync session finished"];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"mobilesync_start failed: %d", start_err]];
            [self handleSyncError:start_err forDataType:dataType operation:@"start_sync"];
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"Error description: %s", error_description]];
            }
        }
        
        // 清理资源
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        if (allItems.count == 0 && error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"No data retrieved for %@", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"Retrieved %lu real items for %@",
                         (unsigned long)allItems.count, syncClass]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception in real data sync: %@", exception]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during sync: %@", exception.reason]];
        }
        return @[];
    }
}

#pragma mark - 真实数据处理方法

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (![self validateReceivedData:data_array forDataType:dataType]) {
        return @[];
    }
    
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // 提取通用字段
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // 根据数据类型提取特定字段
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // 如果没有标识符，使用索引
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // 如果没有名称，使用默认名称
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // 提取记录ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // 提取修改时间
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // 估算数据大小
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // 默认大小
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 姓名字段
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 电话号码
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // 邮箱地址
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 日历标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 开始时间
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // 结束时间
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 书签标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 备忘录标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 内容
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // 大概估算
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 提醒事项标题
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // 完成状态
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // 优先级
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // 尝试各种可能的名称字段
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // 添加一些通用元数据
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

#pragma mark - 选择性同步操作

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // 异步执行同步操作
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // 分解数据类型为单独的类型
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // 按数据类型分组
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // 对每种数据类型执行同步
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // 这里可以实现更细粒度的项目同步逻辑
        // 目前先使用数据类型级别的同步
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // 创建备份目录
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - 操作控制

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - 同步操作实现

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // 根据方向执行不同的操作
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // 双向同步暂时不实现
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // 获取数据项
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // 创建数据类型目录
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // 保存数据项信息
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // 保存备份元数据
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - 数据类型工具方法

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // 这里可以根据需要添加本地化支持
    // 目前返回英文版本
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
}

#pragma mark - 便捷方法

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // 设置完成回调来捕获结果
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - 数据验证和恢复

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // 尝试读取文件以验证格式
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // 参数验证
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查路径是否存在
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // 确保是目录而不是文件
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // 获取基本信息 - 添加错误处理
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // 设置默认值
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // 扫描数据类型
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // 自动释放池，避免内存累积
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // 检查items.plist是否存在
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // 尝试读取items数据
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // 计算该数据类型的大小
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // 设置汇总信息
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // 添加备份统计信息
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - 验证和错误处理

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"Invalid data type received (expected array, got %d) for: %@",
                         type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // 根据错误类型采取不同的处理策略
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // 尝试重新连接
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // 快速检查是否支持此数据类型
    return [self isDataTypeSupported:dataType];
}

#pragma mark - 调试和诊断工具

- (void)diagnoseDeviceSyncCapabilities {
    [self logMessage:@"=== Device Sync Capabilities Diagnosis ==="];
    
    if (![self isConnected]) {
        [self logMessage:@"❌ Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"📱 Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"✅" : @"❌";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"📊 Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
    [self logMessage:@"=== End Diagnosis ==="];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount)
            };
        }
    }
    
    return info;
}

#pragma mark - 私有方法实现

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - 工具方法

- (void)logMessage:(NSString *)message {
    NSString *timestamp = [self getCurrentTimestamp];
    NSString *logMessage = [NSString stringWithFormat:@"[%@] [BackupOptionTask] %@", timestamp, message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}

- (NSString *)formatFileSize:(NSUInteger)bytes {
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}

@end



//
//  BackupOptionTask.h
//  iOSBackupManager
//
//  Created based on libimobiledevice mobilesync API
//  Provides selective backup functionality using mobilesync protocol
//
//  Final Version - 2025.01.27
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// 数据类型枚举 - 对应mobilesync支持的数据类型
typedef NS_OPTIONS(NSUInteger, BackupDataType) {
    BackupDataTypeNone          = 0,
    BackupDataTypeContacts      = 1 << 0,  // 联系人
    BackupDataTypeCalendars     = 1 << 1,  // 日历
    BackupDataTypeBookmarks     = 1 << 2,  // 书签
    BackupDataTypeNotes         = 1 << 3,  // 备忘录
    BackupDataTypeReminders     = 1 << 4,  // 提醒事项
    BackupDataTypeApplications  = 1 << 5,  // 应用数据
    BackupDataTypeConfiguration = 1 << 6,  // 系统配置
    BackupDataTypeKeychain      = 1 << 7,  // 钥匙串
    BackupDataTypeVoiceMemos    = 1 << 8,  // 语音备忘录
    BackupDataTypeWallpaper     = 1 << 9,  // 壁纸设置
    BackupDataTypeAll           = NSUIntegerMax  // 所有支持的数据类型
};

// 同步方向枚举
typedef NS_ENUM(NSUInteger, SyncDirection) {
    SyncDirectionFromDevice,    // 从设备到计算机（备份）
    SyncDirectionToDevice,      // 从计算机到设备（恢复）
    SyncDirectionBidirectional  // 双向同步
};

// 错误代码
typedef NS_ENUM(NSInteger, BackupOptionTaskErrorCode) {
    BackupOptionTaskErrorCodeSuccess = 0,
    BackupOptionTaskErrorCodeUnknown = -1,
    BackupOptionTaskErrorCodeInvalidArg = -2,
    BackupOptionTaskErrorCodeConnectionFailed = -3,
    BackupOptionTaskErrorCodeOperationFailed = -4,
    BackupOptionTaskErrorCodeDeviceNotFound = -5,
    BackupOptionTaskErrorCodeServiceStartFailed = -6,
    BackupOptionTaskErrorCodeProtocolError = -7,
    BackupOptionTaskErrorCodeUserCancelled = -8,
    BackupOptionTaskErrorCodeDataCorrupted = -9,
    BackupOptionTaskErrorCodePermissionDenied = -10,
    BackupOptionTaskErrorCodeSyncConflict = -11,
    BackupOptionTaskErrorCodeDeviceLocked = -12,
    BackupOptionTaskErrorCodeTimeoutError = -13
};

// 同步状态枚举
typedef NS_ENUM(NSUInteger, SyncTaskStatus) {
    SyncTaskStatusIdle,
    SyncTaskStatusConnecting,
    SyncTaskStatusPreparing,
    SyncTaskStatusSyncing,
    SyncTaskStatusCompleted,
    SyncTaskStatusFailed,
    SyncTaskStatusCancelled,
    SyncTaskStatusPaused
};

// 数据项信息结构
@interface SyncDataItem : NSObject
@property (nonatomic, strong) NSString *identifier;
@property (nonatomic, strong) NSString *name;
@property (nonatomic, assign) BackupDataType dataType;
@property (nonatomic, strong) NSDate *modificationDate;
@property (nonatomic, assign) NSUInteger recordCount;
@property (nonatomic, assign) NSUInteger dataSize;
@property (nonatomic, assign) BOOL isSelected;
@property (nonatomic, strong, nullable) NSDictionary *metadata; // 额外的元数据
@end

// 前向声明
@class BackupOptionTask;

// 进度回调块定义
typedef void (^SyncProgressCallback)(float progress, NSString *operation, NSUInteger current, NSUInteger total);
typedef void (^SyncStatusCallback)(SyncTaskStatus status, NSString *description);
typedef void (^SyncCompletionCallback)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error);
typedef void (^SyncLogCallback)(NSString *logMessage);
typedef void (^DataItemsCallback)(NSArray<SyncDataItem *> *items, BackupDataType dataType);

// 选择性备份任务主类
@interface BackupOptionTask : NSObject

#pragma mark - 单例和初始化
+ (instancetype)sharedInstance;
- (instancetype)initWithDeviceUDID:(NSString * _Nullable)deviceUDID;

#pragma mark - 属性
@property (nonatomic, readonly, strong, nullable) NSString *deviceUDID;
@property (nonatomic, readonly, assign) SyncTaskStatus status;
@property (nonatomic, readonly, assign) float progress;
@property (nonatomic, readonly, strong, nullable) NSError *lastError;
@property (nonatomic, readonly, assign) BOOL isOperating;
@property (nonatomic, readonly, assign) BOOL isPaused;

// 数据存储路径
@property (nonatomic, strong) NSString *dataStoragePath;

// 回调设置
@property (nonatomic, copy, nullable) SyncProgressCallback progressCallback;
@property (nonatomic, copy, nullable) SyncStatusCallback statusCallback;
@property (nonatomic, copy, nullable) SyncCompletionCallback completionCallback;
@property (nonatomic, copy, nullable) SyncLogCallback logCallback;
@property (nonatomic, copy, nullable) DataItemsCallback dataItemsCallback;

#pragma mark - 设备连接和查询
/**
 * 连接到指定设备
 * @param deviceUDID 设备UDID
 * @param error 错误信息
 * @return 是否连接成功
 */
- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error;

/**
 * 断开设备连接
 */
- (void)disconnectDevice;

/**
 * 检查设备连接状态
 * @return 是否已连接
 */
- (BOOL)isConnected;

/**
 * 获取设备支持的数据类型
 * @param error 错误信息
 * @return 支持的数据类型掩码
 */
- (BackupDataType)getSupportedDataTypes:(NSError **)error;

/**
 * 检查特定数据类型是否支持
 * @param dataType 数据类型
 * @return 是否支持
 */
- (BOOL)isDataTypeSupported:(BackupDataType)dataType;

#pragma mark - 数据查询
/**
 * 获取指定数据类型的所有数据项
 * @param dataType 数据类型
 * @param error 错误信息
 * @return 数据项数组
 */
- (NSArray<SyncDataItem *> * _Nullable)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error;

/**
 * 异步获取数据项（推荐用于大量数据）
 * @param dataType 数据类型
 * @param completion 完成回调
 */
- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion;

/**
 * 获取数据类型的统计信息
 * @param dataType 数据类型
 * @param error 错误信息
 * @return 统计信息字典
 */
- (NSDictionary * _Nullable)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error;

#pragma mark - 选择性同步操作
/**
 * 开始选择性同步
 * @param dataTypes 要同步的数据类型掩码
 * @param direction 同步方向
 * @param error 错误信息
 * @return 是否成功开始
 */
- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error;

/**
 * 同步特定数据项
 * @param items 要同步的数据项数组
 * @param direction 同步方向
 * @param error 错误信息
 * @return 是否成功开始同步
 */
- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error;

/**
 * 备份选定的数据类型到指定路径
 * @param dataTypes 数据类型掩码
 * @param backupPath 备份存储路径
 * @param error 错误信息
 * @return 是否成功开始备份
 */
- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error;

/**
 * 从指定路径恢复数据到设备
 * @param dataTypes 数据类型掩码
 * @param backupPath 备份路径
 * @param error 错误信息
 * @return 是否成功开始恢复
 */
- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error;

#pragma mark - 操作控制
/**
 * 取消当前同步操作
 */
- (void)cancelCurrentOperation;

/**
 * 暂停当前操作
 */
- (void)pauseCurrentOperation;

/**
 * 恢复暂停的操作
 */
- (void)resumeCurrentOperation;

/**
 * 获取当前操作进度
 * @return 进度百分比 (0.0-100.0)
 */
- (float)getCurrentProgress;

#pragma mark - 数据类型工具方法
/**
 * 将数据类型转换为字符串描述
 * @param dataType 数据类型
 * @return 描述字符串
 */
+ (NSString *)stringForDataType:(BackupDataType)dataType;

/**
 * 将数据类型转换为本地化字符串
 * @param dataType 数据类型
 * @return 本地化描述字符串
 */
+ (NSString *)localizedStringForDataType:(BackupDataType)dataType;

/**
 * 将数据类型掩码转换为数组
 * @param dataTypes 数据类型掩码
 * @return 数据类型数组
 */
+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes;

/**
 * 将数据类型数组转换为掩码
 * @param dataTypeArray 数据类型数组
 * @return 数据类型掩码
 */
+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray;

/**
 * 获取所有可用的数据类型
 * @return 所有数据类型的数组
 */
+ (NSArray<NSNumber *> *)getAllAvailableDataTypes;

#pragma mark - 便捷方法
/**
 * 快速备份联系人
 * @param completion 完成回调
 */
- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份日历
 * @param completion 完成回调
 */
- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份书签
 * @param completion 完成回调
 */
- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份备忘录
 * @param completion 完成回调
 */
- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份提醒事项
 * @param completion 完成回调
 */
- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * 快速备份所有支持的数据类型
 * @param completion 完成回调
 */
- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion;

#pragma mark - 数据验证和恢复
/**
 * 验证备份数据的完整性
 * @param backupPath 备份路径
 * @param dataTypes 要验证的数据类型
 * @param error 错误信息
 * @return 验证结果
 */
- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error;

/**
 * 获取备份数据的详细信息
 * @param backupPath 备份路径
 * @param error 错误信息
 * @return 备份信息字典
 */
- (NSDictionary * _Nullable)getBackupInfo:(NSString *)backupPath error:(NSError **)error;

#pragma mark - 调试和诊断工具
/**
 * 诊断设备同步能力
 */
- (void)diagnoseDeviceSyncCapabilities;

/**
 * 获取详细的数据类型信息（用于调试）
 * @param dataType 数据类型
 * @return 数据类型详细信息
 */
- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType;

@end

NS_ASSUME_NONNULL_END



//
//  DeviceBackupRestore.m
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import "DeviceBackupRestore.h"
#import "DefaultBackupViewController.h"
#import "BackupProgressViewController.h"
#import "EncryptedSettingsViewController.h"
#import "RestoreProgressViewController.h"
#import "DeviceManager.h" // 引入设备管理模块
#import "DatalogsSettings.h"//日志保存路径全局
#import "LanguageManager.h" //语言
#import "CurrentHistoryController.h" //历史操作记录
#import "SidebarViewController.h"
#import "LogUtility.h" // 自定义日志函数LogWithTimestamp，自动添加时间戳
#import "LogManager.h" //全局日志区域
#import "UserManager.h" //登录
#import "DataBaseManager.h" //数据储存管理
#import "BackupTask.h"
#import "BackupOptionTask.h"

@interface DeviceBackupRestore () <NSTableViewDataSource, NSTableViewDelegate>

// 子视图控制器
@property (strong) DefaultBackupViewController *defaultBackupViewController;
@property (strong) BackupProgressViewController *backupProgressViewController;
@property (strong) EncryptedSettingsViewController *encryptedSettingsViewController;
@property (strong) RestoreProgressViewController *restoreProgressViewController;
@property (strong) NSViewController *currentViewController;

// 进度属性的私有设置器
@property (nonatomic, readwrite) double backupProgress;
@property (nonatomic, readwrite) double restoreProgress;
@property (nonatomic, readwrite, getter=isBackupInProgress) BOOL backupInProgress;
@property (nonatomic, readwrite, getter=isRestoreInProgress) BOOL restoreInProgress;

// 备份相关配置
@property (nonatomic, strong) NSString *backupLocationPath;
@property (nonatomic, assign) BOOL backupIsEncrypted;

// 备份数据
@property (nonatomic, strong) NSMutableArray *backupItems;

@end

@implementation DeviceBackupRestore


#pragma mark - 单例实现

+ (instancetype)sharedInstance {
    static DeviceBackupRestore *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}


#pragma mark - 初始化方法

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"DeviceBackupRestore: viewDidLoad");
    
    // 初始化当前备份文件列表
    self.currentBackupFiles = [NSMutableArray array];
        
    // 初始化 NSPopUpButton
    [self populateDevicePopUpButton];

    //当前设备列表信息
    [self getCurrentConnectedDevicesFromHistorylist];
    
    // 初始化数据
    self.backupItems = [NSMutableArray array];

    NSLog(@"DeviceBackupRestore: 已加载样本备份项目: %lu个", (unsigned long)self.backupItems.count);
    
    // 初始化属性
    self.backupProgress = 0.0;
    self.restoreProgress = 0.0;
    self.backupInProgress = NO;
    self.restoreInProgress = NO;
    
    // 初始化备份设置
    self.backupLocationPath = NSHomeDirectory();
    self.backupIsEncrypted = NO;
    NSLog(@"DeviceBackupRestore: 默认备份位置: %@", self.backupLocationPath);
    
    // 初始化视图控制器
    [self initializeViewControllers];
    
    // 显示默认视图
    [self displayContentController:self.defaultBackupViewController];
    
    self.collectedLogs = [[NSMutableString alloc] init]; // 初始化日志缓存
    
    NSLog(@"DeviceBackupRestore: 已显示默认备份视图");
}

- (void)viewDidAppear {
    [super viewDidAppear];
    NSLog(@"DeviceBackupRestore: viewDidAppear");
}


#pragma mark - 填充 NSPopUpButton 表头当前连接的设备列表
- (void)populateDevicePopUpButton {
    NSLog(@"[DEBUG] 开始执行 populateDevicePopUpButton 方法");
    
    NSLog(@"[DEBUG] FlasherTabsController 的 deviceUDID: %@, deviceECID: %@", self.deviceUDID, self.deviceECID);
    
    NSDictionary *allDevicesData = [self getCurrentConnectedDevicesFromHistorylist];
    if (!allDevicesData) {
        NSLog(@"[ERROR] 无法提取设备信息，因为 Plist 文件读取失败。");
        return;
    }
    
    // 清空当前的菜单项
    [self.devicePopUpButton removeAllItems];
    
    // 添加一个默认的选项
    NSString *pleaseSelectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseSelectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Select Device"];
    [self.devicePopUpButton addItemWithTitle:pleaseSelectDeviceTitle];
    
    BOOL hasAvailableDevices = NO;
    
    // 确保 NSPopUpButton 已布局完成，以获取正确的宽度
    [self.devicePopUpButton layoutSubtreeIfNeeded];
    
    // 获取 NSPopUpButton 的宽度
    CGFloat popupWidth = self.devicePopUpButton.bounds.size.width;
    
    // 设定制表符在宽度的85%，留出15%的边距
    CGFloat tabLocation = popupWidth * 0.90;
    
    // 创建段落样式并设置制表符位置
    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    NSTextTab *rightTab = [[NSTextTab alloc] initWithType:NSRightTabStopType location:tabLocation];
    [paragraphStyle setTabStops:@[rightTab]];
    [paragraphStyle setDefaultTabInterval:tabLocation];
    
    // 设置字体大小
    CGFloat fontSize = 12.0;
    
    // 遍历所有设备数据
    for (NSString *key in allDevicesData) {
        NSDictionary *device = allDevicesData[key];
        
        // 获取设备连接状态和模式
        BOOL isConnected = [device[@"IsConnected"] boolValue];
        NSString *deviceMode = device[@"Mode"];
        
        // 排除未连接的设备或模式为 "-" 的设备
        if (!isConnected || [deviceMode isEqualToString:@"-"]) {
            NSLog(@"[INFO] 排除设备 - OfficialName: %@, IsConnected: %@, Mode: %@",
                  device[@"OfficialName"] ?: @"Unknown Name",
                  isConnected ? @"YES" : @"NO",
                  deviceMode ?: @"Unknown Mode");
            continue; // 跳过当前循环，处理下一个设备
        }
        
        NSString *officialName = device[@"OfficialName"] ?: @"Unknown Name";
        NSString *udid = device[@"UDID"];
        NSString *ecid = device[@"ECID"] ?: @"Unknown ECID";
        NSString *type = device[@"TYPE"];
        
        NSString *idString;
        NSString *uniqueKey;
        
        if (udid && udid.length > 0) {
            idString = [NSString stringWithFormat:@"UDID: %@", [udid stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
            uniqueKey = udid;
        } else if (ecid && ecid.length > 0) {
            idString = [NSString stringWithFormat:@"ECID: %@", [ecid stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
            uniqueKey = ecid;
        } else {
            idString = @"Unknown ID";
            uniqueKey = key; // 使用 plist 中的 key 作为备用
        }
        
        // 获取本地化后的 mode
        NSString *localizedMode = [self getLocalizedDeviceModeForDevice:device];
        
        // 使用制表符分隔左侧和右侧内容，使用本地化后的 mode
        // 结构: 左侧信息 \t 右侧信息
        NSString *rawString = [NSString stringWithFormat:@"  %@  -  %@ \t  %@", localizedMode, officialName, type];
        
        // 创建属性字符串
        NSDictionary *attributes = @{
            NSParagraphStyleAttributeName: paragraphStyle,
            NSFontAttributeName: [NSFont systemFontOfSize:fontSize]
        };
        NSAttributedString *attrTitle = [[NSAttributedString alloc] initWithString:rawString attributes:attributes];
        
        // 创建 NSMenuItem 并设置 attributedTitle
        NSMenuItem *item = [[NSMenuItem alloc] initWithTitle:rawString action:nil keyEquivalent:@""];
        item.attributedTitle = attrTitle;
        item.representedObject = uniqueKey;
               
        // 检查当前设备是否为选中设备
        BOOL isSelected = ([uniqueKey isEqualToString:self.deviceUDID] || [uniqueKey isEqualToString:self.deviceECID]);
        if (isSelected) {
            [self.devicePopUpButton selectItem:item];
            self.currentDeviceType = type; // 设置当前 deviceType
            self.currentDeviceMode = deviceMode;
            NSLog(@"[DEBUG] 已选中设备信息: %@  Type: %@  Mode: %@",self.deviceOfficialName, self.currentDeviceType, self.currentDeviceMode);
            
            [self lockDeviceWithInfo:uniqueKey officialName:self.deviceOfficialName type:self.currentDeviceType mode:self.currentDeviceMode];
            NSLog(@"[DEBUG] 已选中设备并锁定: %@  Type: %@  Mode: %@",self.deviceOfficialName, self.currentDeviceType, self.currentDeviceMode);
        }
               
        // 添加到 NSPopUpButton
        [self.devicePopUpButton.menu addItem:item];
        
        hasAvailableDevices = YES;
    }
    
    // 如果没有可用设备，显示提示信息
    if (!hasAvailableDevices) {
        NSString *pleaseConnectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseConnectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Connect Device"];
        [self.devicePopUpButton addItemWithTitle:pleaseConnectDeviceTitle];
    }
    

    // 自动选中对应的设备项（根据 deviceUDID 或 deviceECID）
    [self AutoSelectDeviceInPopUpButton];
    
    NSLog(@"[DEBUG] populateDevicePopUpButton 方法执行完成");
}

#pragma mark - 手动选择后获取当前选择的设备信息
- (IBAction)devicePopUpButtonChanged:(id)sender {
    // 获取当前选中的 NSMenuItem
    NSMenuItem *selectedItem = [self.devicePopUpButton selectedItem];
    
    // 从 selectedItem 中获取对应的设备唯一标识符
    NSString *selectedDeviceID = selectedItem.representedObject;
    
    // 通过唯一标识符找到设备的详细信息（比如从缓存的数据中查找）
    NSDictionary *selectedDeviceInfo = [self getDeviceInfoByID:selectedDeviceID];
    
    // 打印设备信息或执行相关操作
    NSLog(@"[INFO] 手动选中设备的详细信息：%@ 选中的ID %@ ", selectedDeviceInfo, selectedDeviceID);

    NSString *deviceOfficialName = selectedDeviceInfo[@"OfficialName"] ?: @"Unknown Name";
    NSString *deviceUDID = selectedDeviceInfo[@"UDID"];
    NSString *deviceECID = selectedDeviceInfo[@"ECID"] ?: @"Unknown ECID";
    NSString *deviceTYPE = selectedDeviceInfo[@"TYPE"];
    NSString *devicePairStatus = selectedDeviceInfo[@"IsPair"];
    //NSString *deviceModel = selectedDeviceInfo[@"MODEL"];
    NSString *deviceMode = selectedDeviceInfo[@"Mode"];
    
    
    NSLog(@"[INFO] 手动选中设备的名称：%@ 模式：%@ 类型：%@ 匹配：%@", deviceOfficialName, deviceMode, deviceTYPE, devicePairStatus);
    
    NSString *idString;
    NSString *uniqueKey;
    
    if (deviceUDID && deviceUDID.length > 0) {
        idString = [NSString stringWithFormat:@"UDID: %@", [deviceUDID stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
        uniqueKey = deviceUDID;
    } else if (deviceECID && deviceECID.length > 0) {
        idString = [NSString stringWithFormat:@"ECID: %@", [deviceECID stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]];
        uniqueKey = deviceECID;
    } else {
        idString = @"Unknown ID";
        uniqueKey = selectedDeviceID; // 使用 plist 中的 key 作为备用
    }
    
    
    if (deviceTYPE) {
        // 更新当前设备的 deviceType
        self.currentDeviceType = deviceTYPE;
        NSLog(@"当前设备的 deviceType: %@", self.currentDeviceType);

        // 在选择新设备之前取消所有下载任务
      //  [self cancelAllDownloadTasks];

        
        // 锁定并持久化设备信息
        [self lockDeviceWithInfo:uniqueKey officialName:deviceOfficialName type:deviceTYPE mode:deviceMode];
        
        
        // ✅ 修改：直接传递设备信息给备份视图控制器
        if (self.backupProgressViewController) {
            NSLog(@"DeviceBackupRestore: 直接传递设备信息给备份视图控制器");
            
            // 创建设备信息字典
            NSDictionary *deviceInfoToPass = @{
                @"uniqueKey": uniqueKey,
                @"officialName": deviceOfficialName,
                @"type": deviceTYPE,
                @"mode": deviceMode,
                @"udid": deviceUDID ?: @"",
                @"ecid": deviceECID ?: @""
            };
            
            // 直接调用加载方法
            [self.backupProgressViewController loadBackupDataForDevice:uniqueKey deviceInfo:deviceInfoToPass];
        } else {
            NSLog(@"DeviceBackupRestore: 备份视图控制器为空");
        }
        
        // 示例操作：显示设备信息
        NSString *logdeviceOfficialName = [[LanguageManager sharedManager] localizedStringForKeys:@"CurrentDeviceSwitchedto" inModule:@"Flasher" defaultValue:@"The device has been switched to: %@, %@\n"];
        
        // 在 logdeviceOfficialName 前面追加 [warning]
        logdeviceOfficialName = [NSString stringWithFormat:@"[WAR] %@", logdeviceOfficialName];
       
        NSString *choosedDeviceMessage = [NSString stringWithFormat:logdeviceOfficialName, deviceOfficialName, deviceTYPE];
        
        [self showLogsWithMessage:choosedDeviceMessage];//设备切换日志

    } else {
        NSLog(@"[ERROR] 无法根据 uniqueKey 获取设备信息: %@", uniqueKey);
    }
    
    //判断按钮显示状态
    NSLog(@"手动选择后当前设备模式: %@", deviceMode);

    if ([deviceMode isEqualToString:@"Normal"]) {
        [self.backupProgressViewController checkAndLoadExistingBackupData];
    }
    
    // 根据设备类型判断 如果是Watch / Mac 类型 则作相关判断
    if ([deviceTYPE.lowercaseString containsString:@"watch"]) {
        
        /*
        // 如果设备类型为 "watch"，禁用 autoOfficialFirmwareCheckbox
        if (self.autoOfficialFirmwareCheckbox.state == NSControlStateValueOn) {
            // 如果复选框已经选中，取消选择
            self.autoOfficialFirmwareCheckbox.state = NSControlStateValueOff;
        }
        self.autoOfficialFirmwareCheckbox.enabled = NO;
        [self.autoOfficialFirmwareCheckbox setNeedsDisplay:YES]; // 强制刷新*/
    } else {
        /*
        // 如果设备类型不是 "watch"，启用 autoOfficialFirmwareCheckbox
        self.autoOfficialFirmwareCheckbox.enabled = YES;
        [self.autoOfficialFirmwareCheckbox setNeedsDisplay:YES]; // 强制刷新*/
    }
}

- (NSDictionary *)getDeviceInfoByID:(NSString *)deviceID {
    // 示例：从当前已加载的设备列表中找到设备详情
    NSDictionary *allDevicesData = [self getCurrentConnectedDevicesFromHistorylist];
    return allDevicesData[deviceID];
}

#pragma mark - 获取/ 读取当前设备的文件
- (NSDictionary *)getCurrentConnectedDevicesFromHistorylist {
    NSLog(@"[DEBUG] 加载 CurrentDevices.plist");
    NSString *mfcDataPath = [DatalogsSettings mfcDataDirectory];
    NSString *cachesDirectory = [mfcDataPath stringByAppendingPathComponent:@"Caches"];
    NSString *plistPath = [cachesDirectory stringByAppendingPathComponent:@"CurrentDevices.plist"];
   
    // 检查 Plist 文件是否存在
    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) {
        NSLog(@"[ERROR] Plist 文件不存在: %@", plistPath);
        return nil;
    }
    
    // 读取 Plist 文件内容
    NSDictionary *allDevicesData = [NSDictionary dictionaryWithContentsOfFile:plistPath];
    if (!allDevicesData) {
        NSLog(@"[ERROR] 无法读取 Plist 文件内容: %@", plistPath);
        return nil;
    }
    
    return allDevicesData;
}

#pragma mark -  获取当前设备的模式，并返回本地化后的字符串
- (NSString *)getLocalizedDeviceModeForDevice:(NSDictionary *)device {
    LanguageManager *languageManager = [LanguageManager sharedManager];
    
    // 定义设备模式到本地化键的映射
    NSDictionary<NSString *, NSString *> *modeLocalizationKeys = @{
        @"Normal" : @"isNormalModeTitle",
        @"Recovery" : @"isRecoveryModeTitle",
        @"DFU" : @"isDFUModeTitle",
        @"WiFi" : @"isWiFiModeTitle",
        @"WTF" : @"isWTFModeTitle"
    };
    
    // 获取设备的原始模式
    NSString *originalMode = device[@"Mode"];
    
    // 获取对应的本地化键
    NSString *localizationKey = modeLocalizationKeys[originalMode];
    
    // 如果找到对应的本地化键，则进行本地化
    if (localizationKey) {
        NSString *localizedMode = [languageManager localizedStringForKeys:localizationKey inModule:@"DeviceModes" defaultValue:originalMode];
        
        // 检查本地化是否成功（即 localizedMode 不等于 defaultValue）
        if ([localizedMode isEqualToString:originalMode]) {
            NSLog(@"[DEBUG] 模式相同，无须进行本地化. 本地化模式: %@，使用设备原始模式: %@", localizedMode, originalMode);
        }
        
        return localizedMode;
    } else {
        // 如果没有找到对应的本地化键，返回原始模式并记录日志
        NSLog(@"[DEBUG] 未知模式，本地化失败，使用设备原始模式: %@", originalMode);
        return originalMode;
    }
}


#pragma mark -锁定设备并持久化设备信息 同步更新
- (void)lockDeviceWithInfo:(NSString *)uniqueKey officialName:(NSString *)officialName type:(NSString *)type mode:(NSString *)mode {
    // 更新锁定的设备信息
    self.lockedDeviceID = uniqueKey;
    self.deviceType = type;
    self.deviceMode = mode;

    // 创建设备信息字典
    NSDictionary *lockedDeviceInfo = @{
        @"uniqueKey": uniqueKey,
        @"officialName": officialName ?: @"",
        @"type": type ?: @"",
        @"mode": mode ?: @""
    };

    // 持久化锁定的设备信息
    [self setLockedDeviceInfo:lockedDeviceInfo];
    
    // 记录锁定设备的其他信息，如 officialName 和 type 等
    NSLog(@"[INFO] 设备已锁定 - uniqueKey: %@, officialName: %@, type: %@, 模式: %@", uniqueKey, officialName, type, mode);

    // 验证设备信息同步
    NSDictionary *syncedDeviceInfo = [self getLockedDeviceInfo];
    NSLog(@"[INFO] 锁定设备同步信息 - %@", syncedDeviceInfo);
}


#pragma mark - 从内存获取锁定的设备ID
- (NSString *)getLockedDeviceID {
    return self.lockedDeviceID;
}

#pragma mark - 设备锁定信息存入内存
- (void)setLockedDeviceID:(NSString *)lockedDeviceID {
    _lockedDeviceID = lockedDeviceID;
}

#pragma mark - 从内存获取已锁定的设备信息
- (NSDictionary *)getLockedDeviceInfo {
    return self.LockedDeviceInfo;
}

#pragma mark - 设备锁定信息存入内存（字典）
- (void)setLockedDeviceInfo:(NSDictionary *)LockedDeviceInfo {
    _LockedDeviceInfo = LockedDeviceInfo;
}


#pragma mark -  辅助方法：根据 deviceUDID 或 deviceECID 自动选中对应的设备项
- (void)AutoSelectDeviceInPopUpButton {
    BOOL found = NO;
    NSString *selectedDeviceID = nil;
    
    // 在执行固件操作之前移除 deviceListDidChange 监听
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"DeviceListChangedNotification" object:nil];
    
    // 优先根据 deviceUDID 进行匹配
    if (self.deviceUDID && self.deviceUDID.length > 0) {
        for (NSMenuItem *item in self.devicePopUpButton.menu.itemArray) {
            if ([item.representedObject isEqualToString:self.deviceUDID]) {
                [self.devicePopUpButton selectItem:item];
                selectedDeviceID = self.deviceUDID; //自动选中的
                found = YES;
                break;
            }
        }
    }

    // 如果未找到匹配的 deviceUDID，尝试根据 deviceECID 进行匹配
    if (!found && self.deviceECID && self.deviceECID.length > 0) {
        for (NSMenuItem *item in self.devicePopUpButton.menu.itemArray) {
            if ([item.representedObject isEqualToString:self.deviceECID]) {
                [self.devicePopUpButton selectItem:item];
                selectedDeviceID = self.deviceECID; //自动选中的
                found = YES;
                break;
            }
        }
    }
    

    if (found) {
        self.lockedDeviceID = selectedDeviceID;  // 锁定设备
        //[self setLockedDeviceID];
        
        [self setLockedDeviceID:selectedDeviceID]; // 持久化设备信息
        
        //判断按钮显示状态
        NSLog(@"自动选中后判断按钮显示状态: %@" , self.currentDeviceMode);
        BOOL isLoggedIn = [UserManager sharedManager].isUserLoggedIn;
        if ([self.currentDeviceMode isEqualToString:@"Normal"] && isLoggedIn) {
          //  self.eraseDevice.enabled = YES; //擦除内容
         //   self.triggerPairButton.enabled = YES;
           // self.triggerUnPairButton.enabled = YES;
        }else{
          //  self.eraseDevice.enabled = NO; //擦除内容
          //  self.triggerPairButton.enabled = NO;
          //  self.triggerUnPairButton.enabled = NO;
        }
        
        // 固件操作完成后开始定时每 3 秒监听一次
       // [self startDeviceListMonitoring];
        
    } else {
        // 未找到匹配设备，解除锁定
        self.lockedDeviceID = nil;
        [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"LockedDeviceID"];
    }
}

#pragma mark - 刷新日志显示

- (void)showLogsWithMessage:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        // 生成时间戳
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
        NSString *timestamp = [dateFormatter stringFromDate:[NSDate date]];

        // 手动生成带时间戳的日志
        NSString *formattedLog = [NSString stringWithFormat:@"[%@] %@", timestamp, message];

        // 获取日志显示的 NSTextView
        NSTextView *textView = (NSTextView *)[LogManager sharedManager].logScrollView.documentView;
        if (textView) {
            // ✅ 直接调用 AppendLogToTextView 追加日志（仍然是原始 message）
            AppendLogToTextView(textView, message);

            // 自动滚动到底部
            NSRange endRange = NSMakeRange(textView.string.length, 0);
            [textView scrollRangeToVisible:endRange];

            // ✅ 存入 collectedLogs，但加上时间戳，确保最终日志文件有完整格式
            [self.collectedLogs appendFormat:@"%@\n", formattedLog];
        } else {
            NSLog(@"[ERROR] Failed to access NSTextView.");
        }
    });
}

#pragma mark - 初始化视图控制器

- (void)initializeViewControllers {
    NSLog(@"DeviceBackupRestore: 初始化视图控制器");
    
    // 从Storyboard实例化子视图控制器
    self.defaultBackupViewController = [self.storyboard instantiateControllerWithIdentifier:@"DefaultBackupViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化DefaultBackupViewController");
    
    self.backupProgressViewController = [self.storyboard instantiateControllerWithIdentifier:@"BackupProgressViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化BackupProgressViewController");
    
    self.encryptedSettingsViewController = [self.storyboard instantiateControllerWithIdentifier:@"EncryptedSettingsViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化EncryptedSettingsViewController");
    
    self.restoreProgressViewController = [self.storyboard instantiateControllerWithIdentifier:@"RestoreProgressViewController"];
    NSLog(@"DeviceBackupRestore: 已实例化RestoreProgressViewController");
    
    // 设置默认备份视图的数据源
    self.defaultBackupViewController.backupItems = self.backupItems;
    
    // 将自己设置为各个子视图控制器的代理
    self.backupProgressViewController.delegate = (id<BackupProgressDelegate>)self;
    self.encryptedSettingsViewController.delegate = (id<EncryptedSettingsDelegate>)self;
    self.restoreProgressViewController.delegate = (id<RestoreProgressDelegate>)self;
}

#pragma mark - 视图切换管理

- (void)displayContentController:(NSViewController *)content {
    NSLog(@"DeviceBackupRestore: 切换到视图控制器: %@", NSStringFromClass([content class]));
    
    // 检查新内容是否为空
    if (!content) {
        NSLog(@"DeviceBackupRestore: 错误 - 尝试显示空的视图控制器");
        return;
    }
    
    // 检查 contentView 是否存在
    if (!self.contentView) {
        NSLog(@"DeviceBackupRestore: 错误 - contentView 为空，无法添加子视图");
        return;
    }
    
    // 移除当前视图控制器
    if (self.currentViewController) {
        // 先从视图层级中移除视图
        [self.currentViewController.view removeFromSuperview];
        
        // 直接从父视图控制器中移除
        [self.currentViewController removeFromParentViewController];
        
        NSLog(@"DeviceBackupRestore: 已移除当前视图控制器: %@", NSStringFromClass([self.currentViewController class]));
    }
    
    // 添加新的视图控制器
    [self addChildViewController:content];
    
    // 添加视图
    NSView *contentView = content.view;
    [self.contentView addSubview:contentView];
    contentView.frame = self.contentView.bounds;
    contentView.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable;
    
    // 更新当前视图控制器引用
    self.currentViewController = content;
    NSLog(@"DeviceBackupRestore: 已添加新视图控制器: %@", NSStringFromClass([content class]));
}



#pragma mark - 按钮动作方法
- (IBAction)showBackupManageView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了备份管理按钮");
    [self displayContentController:self.defaultBackupViewController];
    [self updateButtonStates:self.backupManageButton];
}


- (IBAction)showBackupView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了立即备份按钮");
    [self displayContentController:self.backupProgressViewController];
    [self updateButtonStates:self.startBackupButton];
    
    // ✅ 在切换到备份视图时也传递当前设备信息
    if (self.lockedDeviceID && self.lockedDeviceID.length > 0) {
        NSLog(@"DeviceBackupRestore: 传递当前设备信息到备份视图");
        [self.backupProgressViewController loadBackupDataForDevice:self.lockedDeviceID deviceInfo:self.LockedDeviceInfo];
    }
    
    // 获取当前锁定的设备ID（UDID 或 ECID）
    NSString *lockedDeviceID = self.lockedDeviceID;
    if (!lockedDeviceID) {
        lockedDeviceID = [self getLockedDeviceID];
        NSLog(@"尝试从UserDefaults获取锁定的设备ID: %@", lockedDeviceID);
    }
    NSLog(@"当前获取到锁定的设备ID: %@", lockedDeviceID);
    
    // 自动开始备份
    [self triggerStartBackup:nil];
}

- (IBAction)showEncryptedSettingsView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了备份加密按钮");
    [self displayContentController:self.encryptedSettingsViewController];
    [self updateButtonStates:self.encryptedBackupButton];
    
    // 更新加密设置视图中的状态
    [self.encryptedSettingsViewController updateEncryptionStatus:self.backupIsEncrypted];
}

- (IBAction)showRestoreView:(id)sender {
    NSLog(@"DeviceBackupRestore: 点击了恢复备份按钮");
    [self displayContentController:self.restoreProgressViewController];
    [self updateButtonStates:self.restoreButton];
    
    // 更新恢复视图的备份列表
    [self.restoreProgressViewController setBackupItems:self.backupItems];
}

- (void)updateButtonStates:(NSButton *)activeButton {
    if (!activeButton) {
        NSLog(@"DeviceBackupRestore: 警告 - 尝试更新按钮状态，但活动按钮为空");
        return;
    }
    
    NSLog(@"DeviceBackupRestore: 更新按钮状态，当前活动按钮: %@", activeButton.title);
    
    // 全面进行空指针检查
    if ([self.backupManageButton isKindOfClass:[NSButton class]]) {
        [self.backupManageButton setState:(activeButton == self.backupManageButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - backupManageButton 类型错误或为空");
    }
    
    if ([self.startBackupButton isKindOfClass:[NSButton class]]) {
        [self.startBackupButton setState:(activeButton == self.startBackupButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - startBackupButton 类型错误或为空");
    }
    
    if ([self.encryptedBackupButton isKindOfClass:[NSButton class]]) {
        [self.encryptedBackupButton setState:(activeButton == self.encryptedBackupButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - encryptedBackupButton 类型错误或为空");
    }
    
    if ([self.restoreButton isKindOfClass:[NSButton class]]) {
        [self.restoreButton setState:(activeButton == self.restoreButton) ? NSControlStateValueOn : NSControlStateValueOff];
    } else {
        NSLog(@"DeviceBackupRestore: 警告 - restoreButton 类型错误或为空");
    }
}

#pragma mark - 公开方法

// 备份调用方法
- (IBAction)triggerStartBackup:(NSButton *)sender {
    sender.enabled = NO; // 禁用按钮，防止重复点击
    
    NSString *deviceUDID = self.lockedDeviceID;
    
    if (!deviceUDID || deviceUDID.length == 0) {
        NSString *pleaseSelectDeviceTitle = [[LanguageManager sharedManager] localizedStringForKeys:@"PleaseSelectDeviceTitle" inModule:@"Flasher" defaultValue:@"Please Select Device"];
        pleaseSelectDeviceTitle = [NSString stringWithFormat:@"[WAR] %@", pleaseSelectDeviceTitle];
        [self showLogsWithMessage:pleaseSelectDeviceTitle];
        sender.enabled = YES;
        return;
    }

    [self showLogsWithMessage:[NSString stringWithFormat:@"将要备份的设备: %@ 模式: %@", self.lockedDeviceID, self.deviceMode]];
    
    // 清空当前备份文件列表
    [self.currentBackupFiles removeAllObjects];
    
    // 重置备份进度视图控制器的状态
    if (self.backupProgressViewController) {
        [self.backupProgressViewController startBackupWithInitialLog:@"准备开始备份...\n"];
        [self.backupProgressViewController updateProgress:0.0];
    }
    
    // 记录操作日志
    NSString *logRecord = [[LanguageManager sharedManager] localizedStringForKeys:@"HandleBackupDevice"
                                                                       inModule:@"OperationRecods"
                                                                  defaultValue:@"Handle Backup Device"];
    [[DataBaseManager sharedInstance] addOperationRecord:logRecord forDeviceECID:deviceUDID UDID:deviceUDID];
    
    if (![self.deviceMode isEqualToString:@"Normal"]) {
        NSString *logMessage = @"[WAR] 设备模式非正常，无法执行备份";
        [self showLogsWithMessage:logMessage];
        sender.enabled = YES;
        self.isWorking = NO;
        return;
    }
    
    // ✅ 创建带时间戳的备份目录
    NSString *timestampedBackupPath = [self createTimestampedBackupDirectoryForDevice:deviceUDID];
    if (!timestampedBackupPath) {
        NSString *errorMessage = @"[ERR] 无法创建备份目录";
        [self showLogsWithMessage:errorMessage];
        sender.enabled = YES;
        self.isWorking = NO;
        return;
    }
    
    [self showLogsWithMessage:[NSString stringWithFormat:@"备份目录已创建: %@", [timestampedBackupPath lastPathComponent]]];
    
    // 强引用保留自己，防止被释放
    __strong typeof(self) strongSelf = self;
    
    // 获取BackupTask实例并设置日志回调
    BackupTask *backupTask = [BackupTask sharedInstance];
    
    // 设置日志回调 - 关键修改
    backupTask.logCallback = ^(NSString *logMessage) {
        dispatch_async(dispatch_get_main_queue(), ^{
            // 格式化日志消息并显示
            NSString *formattedMessage = [NSString stringWithFormat:@"%@", logMessage];
            [strongSelf showLogsWithMessage:formattedMessage];
            
            // 解析文件信息并添加到列表
            [strongSelf parseAndAddBackupFileInfo:logMessage];
        });
    };
    
    // 预先检查设备连接性
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 初步测试设备连接性
        idevice_t testDevice = NULL;
        idevice_error_t ierr = idevice_new(&testDevice, [deviceUDID UTF8String]);
        
        if (ierr != IDEVICE_E_SUCCESS) {
            NSString *errorMsg = [NSString stringWithFormat:@"设备连接测试失败，错误码: %d", ierr];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@", errorMsg]];
                sender.enabled = YES;
                strongSelf.isWorking = NO;
            });
            
            if (testDevice) {
                idevice_free(testDevice);
            }
            return;
        }
        
        if (testDevice) {
            idevice_free(testDevice);
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            [strongSelf showLogsWithMessage:@"设备连接测试成功，开始执行备份任务"];
        });
        
        // 使用新的方法：传递自定义备份路径
        [backupTask startBackupForDevice:deviceUDID
                       customBackupPath:timestampedBackupPath  // 传递时间戳备份路径
                               progress:^(double progress, NSString *message) {
            // 进度更新逻辑保持不变
            dispatch_async(dispatch_get_main_queue(), ^{
                // 更新备份进度视图控制器的进度
                if (strongSelf.backupProgressViewController) {
                    [strongSelf.backupProgressViewController updateProgress:progress * 100];
                }
                
                // 定期显示进度信息到日志
                static double lastLoggedProgress = -1;
                if (progress - lastLoggedProgress >= 0.10 || progress >= 1.0) { // 每10%显示一次
                    NSString *progressMessage = [NSString stringWithFormat:@"%@", message];
                    [strongSelf showLogsWithMessage:progressMessage];
                    lastLoggedProgress = progress;
                }
            });
        }
        completion:^(BOOL success, NSError *error) {
            dispatch_async(dispatch_get_main_queue(), ^{
                sender.enabled = YES;
                strongSelf.isWorking = NO;
                
                if (success) {
                    
                    // ✅ 计算当前备份的实际大小
                    uint64_t currentBackupSize = [strongSelf calculateDirectorySize:timestampedBackupPath];
                    NSString *currentBackupSizeFormatted = [strongSelf formatSize:currentBackupSize];
                    
                    
                    // 更新进度为完成状态
                    if (strongSelf.backupProgressViewController) {
                        [strongSelf.backupProgressViewController updateProgress:100.0];
                        // ✅ 备份完成后刷新当前设备的备份列表
                        [strongSelf.backupProgressViewController checkAndLoadExistingBackupData];
                    }
                    
                    NSString *logDeviceBackupCompletedMessage = [[LanguageManager sharedManager] localizedStringForKeys:@"DeviceBackupCompleted"
                                                                                   inModule:@"Backup"
                                                                              defaultValue:@"Device Backup completed successfully"];
                    
                    // ✅ 显示当前备份的大小而不是总大小
                    [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[SUC] %@ - 备份路径: %@, 备份大小: %@",
                                                   logDeviceBackupCompletedMessage,
                                                   [timestampedBackupPath lastPathComponent],
                                                   currentBackupSizeFormatted]];
                    
                    
                    // ✅ 延迟刷新备份列表，确保文件系统操作完成
                    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                        [strongSelf refreshBackupListAfterCompletion:timestampedBackupPath];
                    });
                    
                } else {
                    // 更新进度为失败状态
                    if (strongSelf.backupProgressViewController) {
                        [strongSelf.backupProgressViewController updateProgress:50.0];
                    }
                    
                    NSString *errorMessage = error ? error.localizedDescription : @"未知错误";
                    NSString *logDeviceBackupFailedMessage = [NSString stringWithFormat:@"设备备份失败: %@", errorMessage];
                    [strongSelf showLogsWithMessage:[NSString stringWithFormat:@"[ERR] %@", logDeviceBackupFailedMessage]];
                }
                
                // 清除日志回调，避免内存泄漏
                backupTask.logCallback = nil;
            });
        }];
    });
}

#pragma mark - 备份完成后刷新
// 计算目录大小的辅助方法
- (unsigned long long)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    unsigned long long totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedLongLongValue];
        }
    }
    
    return totalSize;
}

// 格式化文件大小的辅助方法
- (NSString *)formatSize:(uint64_t)size {
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)size];
}

- (void)refreshBackupListAfterCompletion:(NSString *)newBackupPath {
    NSLog(@"DeviceBackupRestore: 备份完成，刷新表格数据");
    
    if (self.backupProgressViewController) {
        // 获取当前设备信息
        NSString *currentDeviceID = self.lockedDeviceID;
        NSDictionary *deviceInfo = self.LockedDeviceInfo;
        
        if (currentDeviceID && currentDeviceID.length > 0) {
            NSLog(@"DeviceBackupRestore: 为设备 %@ 刷新备份列表", currentDeviceID);
            
            // 重新加载当前设备的备份数据
            [self.backupProgressViewController loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
            
            // 显示刷新成功消息
            NSString *refreshMessage = [NSString stringWithFormat:@"备份列表已刷新，新备份: %@", [newBackupPath lastPathComponent]];
            [self showLogsWithMessage:refreshMessage];
            
            // ✅ 可选：滚动到最新的备份项（如果需要的话）
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                [self.backupProgressViewController scrollToNewestBackup];
            });
        } else {
            NSLog(@"DeviceBackupRestore: 无法刷新 - 当前设备ID为空");
            [self showLogsWithMessage:@"[WAR] 无法刷新备份列表 - 设备信息缺失"];
        }
    }
}



#pragma mark - 时间戳备份目录创建

// 为设备创建带时间戳的备份目录
- (NSString *)createTimestampedBackupDirectoryForDevice:(NSString *)deviceUDID {
    NSLog(@"DeviceBackupRestore: 为设备 %@ 创建时间戳备份目录", deviceUDID);
    
    // 获取基础备份路径
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    
    // 创建设备专用目录路径
    NSString *deviceBackupPath = [defaultBackupPath stringByAppendingPathComponent:deviceUDID];
    
    // 生成时间戳字符串
    NSString *timestampString = [self generateBackupTimestamp];
    
    // 创建完整的备份目录路径：/BackupPath/[DeviceUDID]/[TimeStamp]/
    NSString *timestampedBackupPath = [deviceBackupPath stringByAppendingPathComponent:timestampString];
    
    NSLog(@"DeviceBackupRestore: 时间戳备份路径: %@", timestampedBackupPath);
    
    // 创建目录
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    
    BOOL success = [fileManager createDirectoryAtPath:timestampedBackupPath
                           withIntermediateDirectories:YES
                                            attributes:nil
                                                 error:&error];
    
    if (!success) {
        NSLog(@"DeviceBackupRestore: 创建备份目录失败: %@", error.localizedDescription);
        [self showLogsWithMessage:[NSString stringWithFormat:@"[ERR] 创建备份目录失败: %@", error.localizedDescription]];
        return nil;
    }
    
    NSLog(@"DeviceBackupRestore: 成功创建备份目录: %@", timestampedBackupPath);
    return timestampedBackupPath;
}

// 生成备份时间戳字符串
- (NSString *)generateBackupTimestamp {
    NSDate *now = [NSDate date];
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    
    // 设置时区为本地时区
    [formatter setTimeZone:[NSTimeZone localTimeZone]];
    
    // 创建年月日部分 (YYYYMMDD)
    [formatter setDateFormat:@"yyyyMMdd"];
    NSString *datePart = [formatter stringFromDate:now];
    
    // 创建时分部分 (HHMM)
    [formatter setDateFormat:@"HHmm"];
    NSString *timePart = [formatter stringFromDate:now];
    
    // 确定AM/PM
    [formatter setDateFormat:@"a"];
    NSString *ampmPart = [formatter stringFromDate:now];
    
    // 转换AM/PM为英文（防止本地化问题）
    if ([ampmPart containsString:@"上午"] || [ampmPart containsString:@"AM"]) {
        ampmPart = @"AM";
    } else {
        ampmPart = @"PM";
    }
    
    // 组合成最终的时间戳字符串
    NSString *timestamp = [NSString stringWithFormat:@"%@%@%@", datePart, timePart, ampmPart];
    
    NSLog(@"DeviceBackupRestore: 生成备份时间戳: %@", timestamp);
    return timestamp;
}

// 修改解析备份文件信息的方法，使用新的时间戳目录
- (void)parseAndAddBackupFileInfo:(NSString *)logMessage {
    // 解析不同类型的文件信息
    if ([logMessage containsString:@"Receiving file"] || [logMessage containsString:@"Sending file"]) {
        NSString *fileName = [self extractFileNameFromMessage:logMessage];
        NSString *fileSize = [self extractFileSizeFromMessage:logMessage];
                
        // ✅ 使用当前备份会话的路径而不是默认路径
        NSString *currentBackupPath = [self getCurrentBackupSessionPath];
        NSString *isEncrypted = [logMessage containsString:@"Encrypted"] ? @"Yes" : @"No";
        NSString *isImported = [logMessage containsString:@"Backuptype"] ? @"Import" : @"-";
        
        if (fileName && fileName.length > 0) {
            NSDictionary *fileInfo = @{
                @"fileName": fileName,
                @"backuplocation": currentBackupPath ?: [DatalogsSettings defaultBackupPath],
                @"backupfilesize": fileSize ?: @"-",
                @"backupencryptionstatus": isEncrypted ?: @"-",
                @"backuptype": isImported ?: @"-",
                @"backupdate": [NSDate date]
            };
            
            [self.currentBackupFiles addObject:fileInfo];
            
            // 限制列表长度，避免过多条目影响性能
            if (self.currentBackupFiles.count > 1000) {
                [self.currentBackupFiles removeObjectsInRange:NSMakeRange(0, 100)];
            }
            
            // 通知备份进度视图控制器更新文件列表
            if (self.backupProgressViewController) {
                [self.backupProgressViewController updateBackupFilesList:self.currentBackupFiles];
            }
        }
    }
}

// 获取当前备份会话的路径（如果需要跟踪当前备份路径）
- (NSString *)getCurrentBackupSessionPath {
    // 这里可以保存当前备份会话的路径，如果需要的话
    // 目前返回默认路径，可以根据需要进行扩展
    return nil; // 返回nil使用默认路径
}



- (NSString *)extractFileNameFromMessage:(NSString *)message {
    // 提取文件名的正则表达式
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"(?:Receiving|Sending) file (.+?)(?:\\s|$)"
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    
    if (error) {
        return nil;
    }
    
    NSTextCheckingResult *match = [regex firstMatchInString:message
                                                    options:0
                                                      range:NSMakeRange(0, message.length)];
    
    if (match && match.numberOfRanges > 1) {
        NSString *fullPath = [message substringWithRange:[match rangeAtIndex:1]];
        // 只返回文件名，不包含路径
        return [fullPath lastPathComponent];
    }
    
    return nil;
}

- (NSString *)extractFileSizeFromMessage:(NSString *)message {
    // 提取文件大小信息
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"(\\d+(?:\\.\\d+)?\\s*(?:KB|MB|GB|B))"
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    
    if (error) {
        return nil;
    }
    
    NSTextCheckingResult *match = [regex firstMatchInString:message
                                                    options:0
                                                      range:NSMakeRange(0, message.length)];
    
    if (match) {
        return [message substringWithRange:match.range];
    }
    
    return nil;
}

- (void)clearBackupFilesList {
    [self.currentBackupFiles removeAllObjects];
    if (self.backupProgressViewController) {
        [self.backupProgressViewController updateBackupFilesList:self.currentBackupFiles];
    }
}


- (void)startBackup {
    NSLog(@"DeviceBackupRestore: 开始备份");
    if (self.isBackupInProgress) {
        NSLog(@"DeviceBackupRestore: 备份已在进行中，忽略请求");
        return;
    }
    
    self.backupInProgress = YES;
    self.backupProgress = 0.0;
    
    // 通知备份进度视图控制器开始备份
    [self.backupProgressViewController startBackupWithInitialLog:@"开始备份...\n"];
}

#pragma mark - BackupProgressDelegate
- (void)cancelBackup {
    NSLog(@"DeviceBackupRestore: 取消备份");
    if (!self.isBackupInProgress) {
        NSLog(@"DeviceBackupRestore: 当前没有正在进行的备份，忽略请求");
        return;
    }
    
    self.backupInProgress = NO;
    [self.backupProgressViewController appendLog:@"备份已取消\n"];
    NSLog(@"DeviceBackupRestore: 备份已取消");
}

- (void)startRestore {
    NSLog(@"DeviceBackupRestore: 开始恢复");
    if (self.isRestoreInProgress) {
        NSLog(@"DeviceBackupRestore: 恢复已在进行中，忽略请求");
        return;
    }
    
    self.restoreInProgress = YES;
    self.restoreProgress = 0.0;
    
    // 通知恢复进度视图控制器开始恢复
    [self.restoreProgressViewController startRestoreWithInitialLog:@"开始恢复...\n"];
    
    // 模拟恢复进度
    [self simulateRestoreProcess];
}

- (void)cancelRestore {
    NSLog(@"DeviceBackupRestore: 取消恢复");
    if (!self.isRestoreInProgress) {
        NSLog(@"DeviceBackupRestore: 当前没有正在进行的恢复，忽略请求");
        return;
    }
    
    self.restoreInProgress = NO;
    [self.restoreProgressViewController appendLog:@"恢复已取消\n"];
    NSLog(@"DeviceBackupRestore: 恢复已取消");
}

- (void)setBackupLocation:(NSString *)location {
    NSLog(@"DeviceBackupRestore: 设置备份位置: %@", location);
    self.backupLocationPath = location;
}

- (NSString *)currentBackupLocation {
    NSLog(@"DeviceBackupRestore: 获取当前备份位置: %@", self.backupLocationPath);
    return self.backupLocationPath;
}

- (void)setBackupEncryption:(BOOL)encrypted {
    NSLog(@"DeviceBackupRestore: 设置备份加密状态: %@", encrypted ? @"已加密" : @"未加密");
    self.backupIsEncrypted = encrypted;
}

- (BOOL)isBackupEncrypted {
    NSLog(@"DeviceBackupRestore: 获取备份加密状态: %@", self.backupIsEncrypted ? @"已加密" : @"未加密");
    return self.backupIsEncrypted;
}

#pragma mark - 加密设置

- (void)changePassword:(NSString *)currentPassword newPassword:(NSString *)newPassword {
    NSLog(@"DeviceBackupRestore: 修改密码");
    
    // 在实际应用中，应该执行实际的密码验证和修改
    self.backupIsEncrypted = YES;
    NSLog(@"DeviceBackupRestore: 密码已更新");
    
    // 显示成功提示
    [self showAlert:@"密码已更新" informativeText:@"设备备份密码已成功更新"];
}

- (void)deletePassword:(NSString *)currentPassword {
    NSLog(@"DeviceBackupRestore: 删除密码");
    
    // 在实际应用中，应该执行实际的密码验证和删除
    self.backupIsEncrypted = NO;
    NSLog(@"DeviceBackupRestore: 密码已删除");
    
    // 显示成功提示
    [self showAlert:@"密码已删除" informativeText:@"设备备份密码已成功删除"];
}

#pragma mark - 帮助方法

- (void)showAlert:(NSString *)title informativeText:(NSString *)text {
    NSLog(@"DeviceBackupRestore: 显示警告: %@ - %@", title, text);
    NSAlert *alert = [[NSAlert alloc] init];
    [alert setMessageText:title];
    [alert setInformativeText:text];
    [alert addButtonWithTitle:@"确定"];
    [alert beginSheetModalForWindow:self.view.window completionHandler:nil];
}


// 模拟恢复过程
- (void)simulateRestoreProcess {
    NSLog(@"DeviceBackupRestore: 开始模拟恢复过程");
    __block double progress = 0.0;
    __block NSInteger step = 0;
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 0.2 * NSEC_PER_SEC, 0.05 * NSEC_PER_SEC);
    
    dispatch_source_set_event_handler(timer, ^{
        if (!self.isRestoreInProgress || progress >= 100.0) {
            NSLog(@"DeviceBackupRestore: 恢复进程将终止，状态: isRestoreInProgress=%d, progress=%.1f",
                  self.isRestoreInProgress, progress);
            dispatch_source_cancel(timer);
            
            if (progress >= 100.0) {
                NSLog(@"DeviceBackupRestore: 恢复完成");
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self.restoreProgressViewController appendLog:@"恢复完成!\n"];
                    self.restoreInProgress = NO;
                });
            }
            return;
        }
        
        progress += 2.0;
        step++;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self.restoreProgress = progress;
            [self.restoreProgressViewController updateProgress:progress];
            
            // 每5步添加一条日志
            if (step % 5 == 0) {
                NSString *logMessage = [NSString stringWithFormat:@"恢复进度: %.1f%%...\n", progress];
                NSLog(@"DeviceBackupRestore: %@", logMessage);
                [self.restoreProgressViewController appendLog:logMessage];
            }
        });
    });
    
    dispatch_resume(timer);
    NSLog(@"DeviceBackupRestore: 恢复进程计时器已启动");
}



#pragma mark - 统一权限管理
- (BOOL)validateForAction {
    if (!self.deviceUDID) {
        //NSLog(@"设备 UDID 无效或为空");
        // 可以在这里显示一个提示框给用户
        return NO;
    }
    
    UserManager *userManager = [UserManager sharedManager];
    if (!userManager.isUserLoggedIn) {
       // NSLog(@"没有登录");
        // 发送通知以触发登录流程
        [[NSNotificationCenter defaultCenter] postNotificationName:@"ShowLoginNotification" object:nil];
        return NO;
    }
    
    return YES;
}

@end



//
//  DeviceBackupRestore.h
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import <Cocoa/Cocoa.h>
#import "BackupProgressViewController.h"
#import "EncryptedSettingsViewController.h"
#import "RestoreProgressViewController.h"
#import "BackupOptionTask.h" 

NS_ASSUME_NONNULL_BEGIN

@interface DeviceBackupRestore : NSViewController <BackupProgressDelegate,EncryptedSettingsDelegate,RestoreProgressDelegate>

// 单例访问方法
+ (instancetype)sharedInstance;

@property (weak) IBOutlet NSPopUpButton *devicePopUpButton;

@property (nonatomic, strong) NSMutableString *collectedLogs; //所有日志

@property (nonatomic, strong) NSString *deviceOfficialName;
@property (nonatomic, strong) NSString *deviceUDID; //接受传递viewcontroller点flash按钮传递的参数
@property (nonatomic, strong) NSString *deviceECID;
@property (nonatomic, strong) NSString *deviceMode;
@property (nonatomic, strong) NSString *deviceType;
@property (nonatomic, strong) NSString *deviceSerialNumber;
@property (nonatomic, strong) NSString *isPair;

//API
@property (nonatomic, strong) NSString *currentDeviceMode; // 当前选中的设备模式
@property (nonatomic, strong) NSString *currentDeviceType; // 当前选中的设备属性

// 变量用于保存选中锁定的设备ID（UDID 或 ECID）用于UI锁定的设备ID
@property (nonatomic, strong, nullable) NSString *lockedDeviceID;
@property (nonatomic, strong, nullable) NSDictionary *LockedDeviceInfo;

- (void)setLockedDeviceID:(nullable NSString *)lockedDeviceID;
- (void)setLockedDeviceInfo:(nullable NSDictionary *)LockedDeviceInfo;


@property (nonatomic, assign) BOOL isWorking; //是否在执行一个进程

// 新增：备份文件列表数据源
@property (nonatomic, strong) NSMutableArray *currentBackupFiles;

// UI元素的IBOutlet连接 - 确保这些属性存在且拼写正确
@property (weak) IBOutlet NSButton *backupManageButton;  // 备份管理按钮
@property (weak) IBOutlet NSButton *startBackupButton;        // 立即备份按钮
@property (weak) IBOutlet NSButton *encryptedBackupButton;  // 备份加密按钮
@property (weak) IBOutlet NSButton *restoreButton;          // 恢复备份按钮
@property (weak) IBOutlet NSView *contentView;              // 内容视图区域

//选择性备份
@property (nonatomic, strong) NSWindow *dataTypeSelectionWindow;
@property (nonatomic, strong) NSArray<NSButton *> *dataTypeCheckboxes;
@property (nonatomic, assign) BackupDataType supportedDataTypes;


// 按钮动作方法
- (IBAction)showBackupManageView:(id)sender;
- (IBAction)showBackupView:(id)sender;
- (IBAction)showEncryptedSettingsView:(id)sender;
- (IBAction)showRestoreView:(id)sender;

// 公开方法 (其余方法保持不变)
- (void)startBackup;
- (void)cancelBackup;
- (void)startRestore;
- (void)cancelRestore;
- (void)setBackupLocation:(NSString *)location;
- (NSString *)currentBackupLocation;
- (void)setBackupEncryption:(BOOL)encrypted;
- (BOOL)isBackupEncrypted;

// 进度属性
@property (nonatomic, readonly) double backupProgress;
@property (nonatomic, readonly) double restoreProgress;
@property (nonatomic, readonly, getter=isBackupInProgress) BOOL backupInProgress;
@property (nonatomic, readonly, getter=isRestoreInProgress) BOOL restoreInProgress;

@end
NS_ASSUME_NONNULL_END



//
//  BackupProgressViewController.m
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import "BackupProgressViewController.h"
#import "DeviceManager.h" // 引入设备管理模块
#import "DatalogsSettings.h"//日志保存路径全局
#import "LanguageManager.h" //语言
#import "CurrentHistoryController.h" //历史操作记录
#import "SidebarViewController.h"
#import "LogUtility.h" // 自定义日志函数LogWithTimestamp，自动添加时间戳
#import "LogManager.h" //全局日志区域
#import "BackupTask.h"
#import "DeviceBackupRestore.h"
#import <sqlite3.h>


@interface BackupProgressViewController ()
@property (nonatomic, strong) NSArray *backupDirectories; // 改为备份目录列表
@end

@implementation BackupProgressViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"BackupProgressViewController: viewDidLoad");
    
    // 初始化备份目录列表
    self.backupDirectories = @[];
    
    // 设置表格视图
    [self.tableView setDataSource:self];
    [self.tableView setDelegate:self];
    
    // 设置进度条
    [self.progressBar setMinValue:0.0];
    [self.progressBar setMaxValue:100.0];
    [self.progressBar setDoubleValue:0.0];
    
    // 设置文本视图
    [self.logTextView setEditable:NO];
    [self.logTextView setFont:[NSFont fontWithName:@"Menlo" size:12.0]];
    self.collectedLogs = [[NSMutableString alloc] init]; // 初始化日志缓存
    
    NSLog(@"BackupProgressViewController: 控件已初始化");
    
    //------添加全局日志start-----------
    [[LogManager sharedManager] attachLogToViewController:self];

    NSScrollView *logScrollView = [LogManager sharedManager].logScrollView;

    // 设置布局
    logScrollView.frame = NSMakeRect(0, 3, 852, 360);

    // 确保先从之前的父视图移除（避免重复添加到多个父视图）
    [logScrollView removeFromSuperview];

    // 将 logScrollView 添加到当前视图并控制其层级
    [self.view addSubview:logScrollView positioned:NSWindowBelow relativeTo:nil]; // 添加到较低层级

    //------添加全局日志end-----------
}

- (void)viewWillAppear {
    [super viewWillAppear];
    NSLog(@"BackupProgressViewController: viewWillAppear");
    
    // 确保日志区域在正确位置（如果需要的话）
    NSScrollView *logScrollView = [LogManager sharedManager].logScrollView;
    if (logScrollView.superview != self.view) {
        // 如果日志区域不在当前视图中，重新添加
        [logScrollView removeFromSuperview];
        logScrollView.frame = NSMakeRect(0, -4, 1007, 293);
        [self.view addSubview:logScrollView positioned:NSWindowBelow relativeTo:nil];
        NSLog(@"BackupProgressViewController: 重新添加日志区域");
    }
    
    // 只在表格为空时才尝试加载数据
    if (self.backupDirectories.count == 0) {
        NSLog(@"BackupProgressViewController: 表格为空，尝试加载现有备份目录");
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self checkAndLoadExistingBackupData];
        });
    }
}

- (void)viewWillDisappear {
    [super viewWillDisappear];
    NSLog(@"BackupProgressViewController: viewWillDisappear");
    // 可以选择性地在这里做一些清理，但通常不需要
}

// 便捷的日志方法
- (void)addLogMessage:(NSString *)message {
    [[LogManager sharedManager] addLogMessage:message forViewController:self];
}

- (void)clearLogs {
    [[LogManager sharedManager] clearLogForViewController:self];
}

#pragma mark - 公共方法

// 直接接收设备信息并加载备份目录
- (void)loadBackupDataForDevice:(NSString *)deviceID deviceInfo:(NSDictionary *)deviceInfo {
    NSLog(@"BackupProgressViewController: 接收到设备信息 - ID: %@, Info: %@", deviceID, deviceInfo);
    
    if (!deviceID || deviceID.length == 0) {
        NSLog(@"BackupProgressViewController: 设备ID为空，无法加载备份数据");
        dispatch_async(dispatch_get_main_queue(), ^{
          //  [self appendLog:@"设备ID为空，无法加载备份数据\n"];
        });
        return;
    }
    
    NSString *deviceName = deviceInfo[@"officialName"] ?: @"Unknown Device";
    NSString *deviceType = deviceInfo[@"type"] ?: @"Unknown Type";
    
    // 获取当前设备的备份基础目录路径
    NSString *defaultBackupPath = [DatalogsSettings defaultBackupPath];
    NSString *deviceBackupBasePath = [defaultBackupPath stringByAppendingPathComponent:deviceID];
    
    NSLog(@"BackupProgressViewController: 当前设备备份基础路径: %@", deviceBackupBasePath);
    
    // 显示设备信息
    dispatch_async(dispatch_get_main_queue(), ^{
        NSString *deviceMessage = [NSString stringWithFormat:@"当前设备: %@ (%@)\n", deviceName, deviceType];
        [self appendLog:deviceMessage];
    });
    
    // 只加载当前设备的备份目录
    NSMutableArray *currentDeviceBackups = [NSMutableArray array];
    [self loadCurrentDeviceBackupDirectories:deviceBackupBasePath
                                    deviceID:deviceID
                                  deviceName:deviceName
                                     toArray:currentDeviceBackups];
    
    NSLog(@"BackupProgressViewController: 当前设备备份目录数量: %lu", (unsigned long)currentDeviceBackups.count);
    
    if (currentDeviceBackups.count > 0) {
        NSLog(@"BackupProgressViewController: 找到 %lu 个当前设备的备份目录", (unsigned long)currentDeviceBackups.count);
        
        // 更新表格数据
        dispatch_async(dispatch_get_main_queue(), ^{
            self.backupDirectories = [currentDeviceBackups copy];
            [self.tableView reloadData];
            
            // ✅ 刷新完成后的附加操作
            [self onBackupListRefreshed:currentDeviceBackups.count];
            
            NSLog(@"BackupProgressViewController: 表格已重新加载，当前行数: %ld", [self.tableView numberOfRows]);
        });
    } else {
        NSLog(@"BackupProgressViewController: 当前设备没有找到备份目录");
        dispatch_async(dispatch_get_main_queue(), ^{
            self.backupDirectories = @[]; // 清空列表
            [self.tableView reloadData];
            [self appendLog:@"当前设备暂无备份数据\n"];
        });
    }
}

// 备份列表刷新完成后的回调
- (void)onBackupListRefreshed:(NSUInteger)backupCount {
    NSLog(@"BackupProgressViewController: 备份列表刷新完成，共 %lu 项", (unsigned long)backupCount);
    
    // 显示加载信息
    NSString *loadMessage = [NSString stringWithFormat:@"已刷新当前设备的 %lu 个备份目录\n", (unsigned long)backupCount];
    [self appendLog:loadMessage];
    
    // 如果有备份项，自动选中最新的
    if (backupCount > 0 && self.tableView.numberOfRows > 0) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self.tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:0] byExtendingSelection:NO];
            [self.tableView scrollRowToVisible:0];
        });
    }
}


- (IBAction)refreshBackupList:(id)sender {
    NSLog(@"BackupProgressViewController: 手动刷新备份列表");
    [self forceRefreshBackupList];
}

// 新方法：只加载当前设备的备份目录（支持时间戳子目录）
- (void)loadCurrentDeviceBackupDirectories:(NSString *)deviceBackupBasePath
                                  deviceID:(NSString *)deviceID
                                deviceName:(NSString *)deviceName
                                   toArray:(NSMutableArray *)backupDirs {
    NSLog(@"BackupProgressViewController: 开始加载当前设备备份目录: %@", deviceBackupBasePath);
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // 检查设备基础目录是否存在
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:deviceBackupBasePath isDirectory:&isDirectory] || !isDirectory) {
        NSLog(@"BackupProgressViewController: 设备备份基础目录不存在: %@", deviceBackupBasePath);
        return;
    }
    
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:deviceBackupBasePath error:&error];
    
    if (error || !contents) {
        NSLog(@"BackupProgressViewController: 无法读取设备备份目录: %@", error.localizedDescription);
        return;
    }
    
    NSLog(@"BackupProgressViewController: 在设备目录中找到 %lu 个项目", (unsigned long)contents.count);
    
    // 遍历设备目录下的所有时间戳目录
    for (NSString *item in contents) {
        NSString *itemPath = [deviceBackupBasePath stringByAppendingPathComponent:item];
        BOOL itemIsDirectory = NO;
        
        if ([fileManager fileExistsAtPath:itemPath isDirectory:&itemIsDirectory] && itemIsDirectory) {
            NSLog(@"BackupProgressViewController: 检查时间戳目录: %@", item);
            
            // 检查是否是时间戳格式的目录名（如202505271018AM）
            if ([self isTimestampDirectoryName:item]) {
                // 检查是否是有效的备份目录
                if ([self isValidBackupDirectory:itemPath]) {
                    // 获取目录信息
                    NSDictionary *dirInfo = [self getCurrentDeviceBackupDirectoryInfo:itemPath
                                                                             deviceID:deviceID
                                                                           deviceName:deviceName
                                                                        timestampDir:item];
                    if (dirInfo) {
                        [backupDirs addObject:dirInfo];
                        NSLog(@"BackupProgressViewController: 添加当前设备备份目录: %@", item);
                    }
                } else {
                    NSLog(@"BackupProgressViewController: 跳过无效的时间戳目录: %@", item);
                }
            } else {
                NSLog(@"BackupProgressViewController: 跳过非时间戳格式目录: %@", item);
            }
        }
    }
    
    // 按时间戳排序，最新的在前（根据目录名称的时间戳）
    [backupDirs sortUsingComparator:^NSComparisonResult(NSDictionary *obj1, NSDictionary *obj2) {
        NSString *timestamp1 = obj1[@"timestamp"];
        NSString *timestamp2 = obj2[@"timestamp"];
        return [timestamp2 compare:timestamp1]; // 倒序，最新的在前
    }];
    
    NSLog(@"BackupProgressViewController: 最终加载当前设备备份目录数量: %lu", (unsigned long)backupDirs.count);
}

// 检查目录名是否为时间戳格式
- (BOOL)isTimestampDirectoryName:(NSString *)dirName {
    // 检查格式：202505271018AM 或 202505271318PM
    if (dirName.length < 12) return NO;
    
    // 检查前12个字符是否都是数字
    NSString *numericPart = [dirName substringToIndex:12];
    NSCharacterSet *nonNumericSet = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
    if ([numericPart rangeOfCharacterFromSet:nonNumericSet].location != NSNotFound) {
        return NO;
    }
    
    // 检查是否以AM或PM结尾
    if (dirName.length >= 14) {
        NSString *ampmPart = [dirName substringFromIndex:12];
        if ([ampmPart isEqualToString:@"AM"] || [ampmPart isEqualToString:@"PM"]) {
            return YES;
        }
    }
    
    return NO;
}

// 获取当前设备备份目录信息
- (NSDictionary *)getCurrentDeviceBackupDirectoryInfo:(NSString *)dirPath
                                             deviceID:(NSString *)deviceID
                                           deviceName:(NSString *)deviceName
                                        timestampDir:(NSString *)timestampDir {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // 获取目录属性
    NSDictionary *dirAttributes = [fileManager attributesOfItemAtPath:dirPath error:nil];
    if (!dirAttributes) {
        return nil;
    }
    
    NSDate *modificationDate = dirAttributes[NSFileModificationDate];
    NSString *dateString = [dateFormatter stringFromDate:modificationDate];
    
    // 解析时间戳目录名获取备份时间
    NSString *backupTimeString = [self parseTimestampFromDirectoryName:timestampDir];
    if (backupTimeString) {
        dateString = [NSString stringWithFormat:@"%@", backupTimeString];
    }
    
    // 读取备份信息
    NSString *infoPath = [dirPath stringByAppendingPathComponent:@"Info.plist"];
    NSDictionary *backupInfo = [NSDictionary dictionaryWithContentsOfFile:infoPath];
    
    // 获取加密状态
    BOOL isEncrypted = NO;
    if (backupInfo) {
        isEncrypted = [backupInfo[@"IsEncrypted"] boolValue];
    }
    
    // 计算目录总大小
    unsigned long long totalSize = [self calculateDirectorySize:dirPath];
    NSString *sizeString = [self formatFileSize:totalSize];
    
    return @{
        @"backupitem": [NSString stringWithFormat:@"%@", timestampDir],
        @"backuplocation": dirPath,
        @"backupfilesize": sizeString,
        @"backupdate": dateString,
        @"backupdate_raw": modificationDate, // 用于排序
        @"backupencryptionstatus": isEncrypted ? @"Yes" : @"No",
        @"backuptype": @"Current Device",
        @"deviceid": deviceID,
        @"timestamp": timestampDir // 用于排序
    };
}

// 解析时间戳目录名获取可读的时间字符串
- (NSString *)parseTimestampFromDirectoryName:(NSString *)dirName {
    // 解析格式如 202505271018AM 或 202505271318PM
    if (dirName.length < 12) return nil;
    
    NSString *yearStr = [dirName substringWithRange:NSMakeRange(0, 4)];
    NSString *monthStr = [dirName substringWithRange:NSMakeRange(4, 2)];
    NSString *dayStr = [dirName substringWithRange:NSMakeRange(6, 2)];
    NSString *hourStr = [dirName substringWithRange:NSMakeRange(8, 2)];
    NSString *minuteStr = [dirName substringWithRange:NSMakeRange(10, 2)];
    
    NSString *ampmStr = @"";
    if (dirName.length >= 14) {
        ampmStr = [dirName substringFromIndex:12];
    }
    
    return [NSString stringWithFormat:@"%@-%@-%@ %@:%@ %@",
            yearStr, monthStr, dayStr, hourStr, minuteStr, ampmStr];
}

// ✅ 简化原有的方法，主要用于初始化时调用
- (void)checkAndLoadExistingBackupData {
    NSLog(@"BackupProgressViewController: 检查现有备份数据（通过获取主控制器信息）");
    
    // 获取当前选中的设备ID
    DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
    NSString *currentDeviceID = mainController.lockedDeviceID;
    NSDictionary *deviceInfo = mainController.LockedDeviceInfo;
    
    if (currentDeviceID && currentDeviceID.length > 0) {
        [self loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            // 即使没有选中设备，也显示所有备份目录
            [self loadBackupDataForDevice:@"" deviceInfo:@{}];
        });
    }
}

// 新方法：加载备份目录（而不是文件）
- (void)loadBackupDirectoriesFromPath:(NSString *)backupBasePath toArray:(NSMutableArray *)backupDirs currentDeviceID:(NSString *)currentDeviceID {
    NSLog(@"BackupProgressViewController: 开始从路径加载备份目录: %@", backupBasePath);
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    NSError *error = nil;
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:backupBasePath error:&error];
    
    if (error || !contents) {
        NSLog(@"BackupProgressViewController: 无法读取备份基础目录: %@", error.localizedDescription);
        return;
    }
    
    NSLog(@"BackupProgressViewController: 找到 %lu 个项目在备份目录中", (unsigned long)contents.count);
    
    // 遍历所有项目，查找备份目录
    for (NSString *item in contents) {
        NSString *itemPath = [backupBasePath stringByAppendingPathComponent:item];
        BOOL isDirectory = NO;
        
        if ([fileManager fileExistsAtPath:itemPath isDirectory:&isDirectory] && isDirectory) {
            NSLog(@"BackupProgressViewController: 检查目录: %@", item);
            
            // 检查是否是有效的备份目录
            if ([self isValidBackupDirectory:itemPath]) {
                // 获取目录信息
                NSDictionary *dirInfo = [self getBackupDirectoryInfo:itemPath deviceID:item currentDeviceID:currentDeviceID];
                if (dirInfo) {
                    [backupDirs addObject:dirInfo];
                    NSLog(@"BackupProgressViewController: 添加备份目录: %@", item);
                }
            } else {
                NSLog(@"BackupProgressViewController: 跳过无效目录: %@", item);
            }
        }
    }
    
    // 按修改时间排序，最新的在前
    [backupDirs sortUsingComparator:^NSComparisonResult(NSDictionary *obj1, NSDictionary *obj2) {
        NSDate *date1 = obj1[@"backupdate_raw"];
        NSDate *date2 = obj2[@"backupdate_raw"];
        return [date2 compare:date1];
    }];
    
    NSLog(@"BackupProgressViewController: 最终加载的备份目录数量: %lu", (unsigned long)backupDirs.count);
}

// 检查是否是有效的备份目录
- (BOOL)isValidBackupDirectory:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 检查必要的备份文件是否存在
    NSArray *requiredFiles = @[@"Info.plist"];
    NSArray *optionalFiles = @[@"Status.plist", @"Manifest.plist", @"Manifest.db"];
    
    // 必须文件检查
    BOOL hasRequiredFiles = YES;
    for (NSString *file in requiredFiles) {
        NSString *filePath = [dirPath stringByAppendingPathComponent:file];
        if (![fileManager fileExistsAtPath:filePath]) {
            hasRequiredFiles = NO;
            break;
        }
    }
    
    // 检查是否有至少一个可选文件
    BOOL hasOptionalFile = NO;
    for (NSString *file in optionalFiles) {
        NSString *filePath = [dirPath stringByAppendingPathComponent:file];
        if ([fileManager fileExistsAtPath:filePath]) {
            hasOptionalFile = YES;
            break;
        }
    }
    
    // 检查是否有哈希目录
    BOOL hasHashDirs = NO;
    for (int i = 0; i < 16; i++) { // 只检查前16个哈希目录
        NSString *hashDir = [NSString stringWithFormat:@"%02x", i];
        NSString *hashDirPath = [dirPath stringByAppendingPathComponent:hashDir];
        if ([fileManager fileExistsAtPath:hashDirPath]) {
            hasHashDirs = YES;
            break;
        }
    }
    
    return hasRequiredFiles && (hasOptionalFile || hasHashDirs);
}

// 获取备份目录信息
- (NSDictionary *)getBackupDirectoryInfo:(NSString *)dirPath deviceID:(NSString *)deviceID currentDeviceID:(NSString *)currentDeviceID {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterMediumStyle];
    [dateFormatter setTimeStyle:NSDateFormatterShortStyle];
    
    // 获取目录属性
    NSDictionary *dirAttributes = [fileManager attributesOfItemAtPath:dirPath error:nil];
    if (!dirAttributes) {
        return nil;
    }
    
    NSDate *modificationDate = dirAttributes[NSFileModificationDate];
    NSString *dateString = [dateFormatter stringFromDate:modificationDate];
    
    // 读取备份信息
    NSString *infoPath = [dirPath stringByAppendingPathComponent:@"Info.plist"];
    NSDictionary *backupInfo = [NSDictionary dictionaryWithContentsOfFile:infoPath];
    
    // 获取设备名称
    NSString *deviceName = @"Unknown Device";
    NSString *deviceModel = @"Unknown Model";
    BOOL isEncrypted = NO;
    
    if (backupInfo) {
        deviceName = backupInfo[@"Device Name"] ?: backupInfo[@"Display Name"] ?: @"Unknown Device";
        deviceModel = backupInfo[@"Product Type"] ?: @"Unknown Model";
        isEncrypted = [backupInfo[@"IsEncrypted"] boolValue];
    }
    
    // 计算目录总大小
    unsigned long long totalSize = [self calculateDirectorySize:dirPath];
    NSString *sizeString = [self formatFileSize:totalSize];
    
    // 判断是否是当前设备
    BOOL isCurrentDevice = [deviceID isEqualToString:currentDeviceID];
    NSString *statusString = isCurrentDevice ? @"Current" : @"Other";
    
    return @{
        @"backupitem": [NSString stringWithFormat:@"%@ (%@)", deviceName, deviceModel],
        @"backuplocation": dirPath,
        @"backupfilesize": sizeString,
        @"backupdate": dateString,
        @"backupdate_raw": modificationDate, // 用于排序
        @"backupencryptionstatus": isEncrypted ? @"Yes" : @"No",
        @"backuptype": statusString,
        @"deviceid": deviceID
    };
}

// 计算目录总大小
- (unsigned long long)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    unsigned long long totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedLongLongValue];
        }
    }
    
    return totalSize;
}

// 格式化文件大小
- (NSString *)formatFileSize:(unsigned long long)bytes {
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    return [formatter stringFromByteCount:(long long)bytes];
}

// 修改：更新当前备份过程中的文件信息显示（如果需要的话）
- (void)updateBackupFilesList:(NSArray *)filesList {
    // 对于目录显示模式，我们可能不需要实时更新文件列表
    // 或者可以在这里更新当前正在备份的设备目录信息
    dispatch_async(dispatch_get_main_queue(), ^{
        // 可以在这里添加实时更新逻辑，比如更新当前设备的备份状态
        NSLog(@"BackupProgressViewController: 备份过程中，文件数量: %lu", (unsigned long)filesList.count);
        
        // 重新加载当前数据以反映备份进度
        [self checkAndLoadExistingBackupData];
    });
}

- (void)startBackupWithInitialLog:(NSString *)initialLog {
    NSLog(@"BackupProgressViewController: 开始备份，初始日志: %@", initialLog);
    
    // 重置进度条
    [self.progressBar setDoubleValue:0.0];
    
    // 设置初始日志
    [self.logTextView.textStorage setAttributedString:[[NSAttributedString alloc] initWithString:initialLog]];
}

- (void)updateProgress:(double)progress {
    NSLog(@"BackupProgressViewController: 更新进度: %.1f%%", progress);
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.progressBar setDoubleValue:progress];
    });
}

#pragma mark - 更新日志区域
- (void)appendLog:(NSString *)message {
    dispatch_async(dispatch_get_main_queue(), ^{
        // 生成时间戳
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
        NSString *timestamp = [dateFormatter stringFromDate:[NSDate date]];

        // 手动生成带时间戳的日志
        NSString *formattedLog = [NSString stringWithFormat:@"[%@] %@", timestamp, message];

        // 获取日志显示的 NSTextView
        NSTextView *textView = (NSTextView *)[LogManager sharedManager].logScrollView.documentView;
        if (textView) {
            // ✅ 直接调用 AppendLogToTextView 追加日志（仍然是原始 message）
            AppendLogToTextView(textView, message);

            // 自动滚动到底部
            NSRange endRange = NSMakeRange(textView.string.length, 0);
            [textView scrollRangeToVisible:endRange];

            // ✅ 存入 collectedLogs，但加上时间戳，确保最终日志文件有完整格式
            [self.collectedLogs appendFormat:@"%@\n", formattedLog];
        } else {
            NSLog(@"[ERROR] Failed to access NSTextView.");
        }
    });
}

#pragma mark - 按钮动作

- (IBAction)cancelBackup:(id)sender {
    NSLog(@"BackupProgressViewController: 取消备份按钮被点击");
    if ([self.delegate respondsToSelector:@selector(cancelBackup)]) {
        [self.delegate cancelBackup];
    }
}

#pragma mark - NSTableViewDataSource

- (NSInteger)numberOfRowsInTableView:(NSTableView *)tableView {
    // 返回备份目录列表的行数
    return self.backupDirectories.count;
}

// 修改 viewForTableColumn 方法以显示目录信息
- (NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row {
    if (row < self.backupDirectories.count) {
        NSDictionary *dirInfo = self.backupDirectories[row];
        
        NSTableCellView *cellView = [tableView makeViewWithIdentifier:tableColumn.identifier owner:self];
        if (!cellView) {
            cellView = [[NSTableCellView alloc] init];
            cellView.identifier = tableColumn.identifier;
            
            NSTextField *textField = [[NSTextField alloc] init];
            textField.bordered = NO;
            textField.backgroundColor = [NSColor clearColor];
            textField.editable = NO;
            textField.font = [NSFont systemFontOfSize:11.0];
            [cellView addSubview:textField];
            cellView.textField = textField;
            
            // 设置约束
            textField.translatesAutoresizingMaskIntoConstraints = NO;
            [NSLayoutConstraint activateConstraints:@[
                [textField.leadingAnchor constraintEqualToAnchor:cellView.leadingAnchor constant:6],
                [textField.trailingAnchor constraintEqualToAnchor:cellView.trailingAnchor constant:-6],
                [textField.centerYAnchor constraintEqualToAnchor:cellView.centerYAnchor]
            ]];
        }
        
        // 根据列标识符设置内容
        if ([tableColumn.identifier isEqualToString:@"backupitem"]) {
            NSString *displayName = dirInfo[@"backupitem"] ?: @"";
            // 所有显示的都是当前设备的备份，用蓝色显示
           // cellView.textField.textColor = [NSColor systemBlueColor];
            cellView.textField.stringValue = displayName;
        } else if ([tableColumn.identifier isEqualToString:@"backuplocation"]) {
            cellView.textField.stringValue = dirInfo[@"backuplocation"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupfilesize"]) {
            cellView.textField.stringValue = dirInfo[@"backupfilesize"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupdate"]) {
            cellView.textField.stringValue = dirInfo[@"backupdate"] ?: @"";
        } else if ([tableColumn.identifier isEqualToString:@"backupencryptionstatus"]) {
            cellView.textField.stringValue = dirInfo[@"backupencryptionstatus"] ?: @"";
        }
        
        return cellView;
    }
    
    return nil;
}

- (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row {
    return 30.0; // 设置行高
}

#pragma mark - 表格操作辅助方法

- (void)scrollToNewestBackup {
    NSLog(@"BackupProgressViewController: 滚动到最新备份项");
    
    if (self.backupDirectories.count > 0) {
        // 滚动到第一行（最新的备份）
        [self.tableView scrollRowToVisible:0];
        
        // 可选：选中第一行
        [self.tableView selectRowIndexes:[NSIndexSet indexSetWithIndex:0] byExtendingSelection:NO];
        
        NSLog(@"BackupProgressViewController: 已滚动并选中最新备份项");
    } else {
        NSLog(@"BackupProgressViewController: 没有备份项可滚动");
    }
}
// 添加一个强制刷新方法
- (void)forceRefreshBackupList {
    NSLog(@"BackupProgressViewController: 强制刷新备份列表");
    
    // 获取主控制器信息
    DeviceBackupRestore *mainController = [DeviceBackupRestore sharedInstance];
    NSString *currentDeviceID = mainController.lockedDeviceID;
    NSDictionary *deviceInfo = mainController.LockedDeviceInfo;
    
    if (currentDeviceID && currentDeviceID.length > 0) {
        [self loadBackupDataForDevice:currentDeviceID deviceInfo:deviceInfo];
        
        // 添加刷新日志
        dispatch_async(dispatch_get_main_queue(), ^{
            [self appendLog:@"备份列表已刷新\n"];
        });
    }
}

// 保持原有的方法用于兼容性
- (id)tableView:(NSTableView *)tableView objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row {
    if (row >= self.backupDirectories.count) {
        NSLog(@"BackupProgressViewController: 请求的行 %ld 超出范围", row);
        return nil;
    }
    
    NSDictionary *item = self.backupDirectories[row];
    NSString *identifier = tableColumn.identifier;
    id value = item[identifier];
    NSLog(@"BackupProgressViewController: 表格行 %ld, 列 %@, 值: %@", row, identifier, value);
    return value;
}

@end



//
//  BackupProgressViewController.h
//  MFCTOOL
//
//  Created by Monterey on 19/1/2025.
//

#import <Cocoa/Cocoa.h>

NS_ASSUME_NONNULL_BEGIN

@protocol BackupProgressDelegate;

@interface BackupProgressViewController : NSViewController <NSTableViewDataSource, NSTableViewDelegate>

// UI控件
@property (weak) IBOutlet NSTableView *tableView;
@property (weak) IBOutlet NSProgressIndicator *progressBar;
@property (weak) IBOutlet NSTextView *logTextView;

@property (nonatomic, strong) NSMutableString *collectedLogs; //所有日志

// 新增：备份文件列表
@property (nonatomic, strong) NSArray *backupFiles;



// 委托
@property (weak) id<BackupProgressDelegate> delegate;

// 方法
- (void)startBackupWithInitialLog:(NSString *)initialLog;
- (void)updateProgress:(double)progress;
- (void)appendLog:(NSString *)logMessage;
- (void)checkAndLoadExistingBackupData;
- (void)scrollToNewestBackup;

// 直接传递设备信息的方法
- (void)loadBackupDataForDevice:(NSString *)deviceID deviceInfo:(NSDictionary *)deviceInfo;


// 新增：更新文件列表方法
- (void)updateBackupFilesList:(NSArray *)filesList;

// 按钮动作
- (IBAction)cancelBackup:(id)sender;

@end

@protocol BackupProgressDelegate <NSObject>
- (void)cancelBackup;
@end

NS_ASSUME_NONNULL_END
