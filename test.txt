V0 çš„ä»£ç ï¼š


//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Created based on libimobiledevice mobilesync API
//  Provides selective backup functionality using mobilesync protocol
//
//  Final Version - 2025.01.27
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// å¼•å…¥ libimobiledevice ç›¸å…³å¤´æ–‡ä»¶
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// å¸¸é‡å®šä¹‰
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// åŸºäºå®é™…iOSåŒæ­¥ç±»çš„æ•°æ®ç±»å‹æ˜ å°„
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        // åŸºäºå®é™…çš„iOSåŒæ­¥æœåŠ¡ç±»æ ‡è¯†ç¬¦
        map = @{
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.Bookmarks",
            @(BackupDataTypeMailAccounts): @"com.apple.MailAccounts",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper"
        };
    });
    return map;
}

// è·å–å·²çŸ¥çš„åŒæ­¥ç±»åˆ—è¡¨ - ç”¨äºæ£€æµ‹æ”¯æŒçš„æ•°æ®ç±»å‹
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.Bookmarks",
            @"com.apple.MailAccounts",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - SyncDataItem å®ç°

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
            self.name, self.identifier, @(self.recordCount)];
}

@end

#pragma mark - BackupOptionTask å†…éƒ¨æ¥å£

@interface BackupOptionTask () {
    // libimobiledevice C API æŒ‡é’ˆ
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // æ“ä½œçŠ¶æ€
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // åŒæ­¥ä¸Šä¸‹æ–‡
    dispatch_queue_t _operationQueue;
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;

    
    // å½“å‰æ“ä½œå‚æ•°
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // å†…éƒ¨çŠ¶æ€
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
}

// ç§æœ‰æ–¹æ³•å£°æ˜
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// çœŸå®æ•°æ®å¤„ç†æ–¹æ³•
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// æ•°æ®è·å–æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// åŒæ­¥æ“ä½œæ–¹æ³•
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// éªŒè¯å’Œé”™è¯¯å¤„ç†
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;

// å·¥å…·æ–¹æ³•
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;

@end

#pragma mark - BackupOptionTask å®ç°

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;

#pragma mark - å•ä¾‹å’Œåˆå§‹åŒ–

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        
        // è®¾ç½®é»˜è®¤æ•°æ®å­˜å‚¨è·¯å¾„
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        
        [self logMessage:[NSString stringWithFormat:@"BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}



#pragma mark - è®¾å¤‡è¿æ¥å’ŒæŸ¥è¯¢

- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
    
    if (!deviceUDID || deviceUDID.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Device UDID cannot be empty"];
        }
        return NO;
    }
    
    // å¦‚æœå·²ç»è¿æ¥åˆ°åŒä¸€è®¾å¤‡ï¼Œç›´æ¥è¿”å›æˆåŠŸ
    if ([_deviceUDID isEqualToString:deviceUDID] && _device && _lockdown && _mobilesync) {
        [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@", deviceUDID]];
        return YES;
    }
    
    // å…ˆæ–­å¼€ç°æœ‰è¿æ¥
    [self disconnectDevice];
    
    _deviceUDID = [deviceUDID copy];
    return [self connectToDeviceInternal:deviceUDID error:error];
}

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. è¿æ¥è®¾å¤‡
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. åˆ›å»ºlockdownå®¢æˆ·ç«¯
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // 3. å¯åŠ¨mobilesyncæœåŠ¡
    if (![self startMobileSyncService:error]) {
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@", deviceUDID]];
    [self setInternalStatus:SyncTaskStatusIdle];
    return YES;
}

// åœ¨ startMobileSyncService æ–¹æ³•ä¸­æ·»åŠ é‡è¯•é€»è¾‘
- (BOOL)startMobileSyncService:(NSError **)error {
    int maxRetries = 3;
    int retryDelay = 2; // ç§’
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            if (err == MOBILESYNC_E_SUCCESS) {
                return YES;  // æˆåŠŸ
            }
            
            [self logMessage:[NSString stringWithFormat:@"MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
        }
        
        // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"Retrying in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                         description:@"Failed to create mobilesync client after multiple attempts"];
    }
    return NO;
}

- (void)disconnectDevice {
    [self logMessage:@"Disconnecting device"];
    
    if (_mobilesync) {
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
    }
    
    if (_afc) {
        afc_client_free(_afc);
        _afc = NULL;
    }
    
    if (_np) {
        np_client_free(_np);
        _np = NULL;
    }
    
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
    }
    
    if (_device) {
        idevice_free(_device);
        _device = NULL;
    }
    
    [self setInternalStatus:SyncTaskStatusIdle];
}

- (BOOL)isConnected {
    return (_device != NULL && _lockdown != NULL && _mobilesync != NULL);
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    @try {
        // ä½¿ç”¨æ­£ç¡®çš„APIåˆ›å»ºanchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // å‡†å¤‡æ­£ç¡®çš„å‚æ•°
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // æ­£ç¡®è°ƒç”¨mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // å¦‚æœæˆåŠŸå¯åŠ¨ï¼Œéœ€è¦ç»“æŸä¼šè¯
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    // âœ… å…³é”®ä¿®å¤ï¼šé‡ç½®MobileSyncçŠ¶æ€
    if (_mobilesync) {
        mobilesync_finish(_mobilesync);
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [NSThread sleepForTimeInterval:0.5]; // è®©è®¾å¤‡çŠ¶æ€é‡ç½®
    }
    
    // é‡æ–°å¯åŠ¨MobileSyncæœåŠ¡
    if (![self startMobileSyncService:error]) {
        return BackupDataTypeNone;
    }
    
    [self logMessage:@"Getting supported data types with enhanced stability"];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // âœ… ä¿®å¤1ï¼šä½¿ç”¨ç¼“å­˜æœºåˆ¶é¿å…é‡å¤æ£€æµ‹
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ5åˆ†é’Ÿå†…ä¸”åŒä¸€è®¾å¤‡ï¼‰
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                         (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // âœ… ä¿®å¤2ï¼šç¡®ä¿è¿æ¥ç¨³å®šæ€§
    if (![self ensureStableConnection:error]) {
        return BackupDataTypeNone;
    }
    
    NSArray *allDataTypes = @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
    
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    for (NSNumber *dataTypeNum in allDataTypes) {
        BackupDataType dataType = [dataTypeNum unsignedIntegerValue];
        
        // âœ… ä¿®å¤3ï¼šä½¿ç”¨æ”¹è¿›çš„ç¨³å®šæ£€æµ‹æ–¹æ³•
        BOOL isSupported = [self isDataTypeSupportedStable:dataType];
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
            [self logMessage:[NSString stringWithFormat:@"âœ… Supported data type: %@",
                             [BackupOptionTask stringForDataType:dataType]]];
        } else {
            [self logMessage:[NSString stringWithFormat:@"âŒ Unsupported data type: %@",
                             [BackupOptionTask stringForDataType:dataType]]];
        }
        
        // âœ… ä¿®å¤4ï¼šæ·»åŠ å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        if (dataTypeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.1];
        }
    }
    
    // âœ… ä¿®å¤5ï¼šæ›´æ–°ç¼“å­˜
    if (successCount > 0) {
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cacheTime = [NSDate date];
    }
    
    [self logMessage:[NSString stringWithFormat:@"ğŸ“Š Final result: %lu/%lu data types supported",
                     (unsigned long)successCount, (unsigned long)totalCount]];
    
    return supportedTypes;
}


// âœ… æ–°å¢ï¼šç¨³å®šçš„è¿æ¥ç¡®ä¿æ–¹æ³•
- (BOOL)ensureStableConnection:(NSError **)error {
    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    if (![self isConnected]) {
        [self logMessage:@"Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // âœ… éªŒè¯è¿æ¥è´¨é‡ï¼šå°è¯•ç®€å•çš„lockdownæ“ä½œ
    if (_lockdown) {
        char *device_name = NULL;
        lockdownd_error_t ldret = lockdownd_get_device_name(_lockdown, &device_name);
        
        if (ldret == LOCKDOWN_E_SUCCESS && device_name) {
            free(device_name);
            [self logMessage:@"Connection quality verified"];
            return YES;
        } else {
            [self logMessage:[NSString stringWithFormat:@"Connection quality check failed: %d", ldret]];
            
            // è¿æ¥è´¨é‡ä¸å¥½ï¼Œå°è¯•é‡è¿
            [self disconnectDevice];
            [NSThread sleepForTimeInterval:0.5];
            return [self connectToDeviceInternal:_deviceUDID error:error];
        }
    }
    
    return YES;
}

// âœ… æ–°å¢ï¼šç¨³å®šçš„æ•°æ®ç±»å‹æ£€æµ‹æ–¹æ³•
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    // âœ… æ·»åŠ è¿æ¥æ£€æŸ¥
    if (!_mobilesync) {
        [self logMessage:@"MobileSyncæœªè¿æ¥ï¼Œè·³è¿‡æ£€æµ‹"];
        return NO;
    }
    
    @try {
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // âœ… é‡è¦ï¼šç«‹å³ç»“æŸä¼šè¯ï¼Œé¿å…çŠ¶æ€æ®‹ç•™
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // âœ… æ¯æ¬¡æ£€æµ‹åä¼‘æ¯ï¼Œé¿å…è®¾å¤‡è¿‡è½½
        [NSThread sleepForTimeInterval:0.2];
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"æ£€æµ‹å¼‚å¸¸: %@", exception.reason]];
        return NO;
    }
}


// âœ… å¢å¼ºçš„æ•°æ®è·å–æ–¹æ³•
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"å¢å¼ºæ–¹æ³•è·å– %@ çš„çœŸå®æ•°æ®", typeName);
    
    // âœ… è¿æ¥çŠ¶æ€æ£€æŸ¥
    if (![self isConnected]) {
        NSLog(@"âŒ è®¾å¤‡æœªè¿æ¥ï¼Œæ— æ³•è·å– %@ æ•°æ®", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // âœ… å¤šæ¬¡å°è¯•è·å–æ•°æ®
    int maxAttempts = 3;
    for (int attempt = 0; attempt < maxAttempts; attempt++) {
        if (attempt > 0) {
            NSLog(@"é‡è¯•è·å– %@ æ•°æ® (ç¬¬ %d æ¬¡å°è¯•)", typeName, attempt + 1);
            [NSThread sleepForTimeInterval:0.5];
        }
        
        items = [self getDataItemsForType:dataType error:&error];
        
        if (items && items.count > 0) {
            NSLog(@"âœ… ç¬¬ %d æ¬¡å°è¯•æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                  attempt + 1, typeName, (unsigned long)items.count);
            break;
        }
        
        if (error) {
            NSLog(@"âŒ ç¬¬ %d æ¬¡å°è¯•è·å– %@ æ•°æ®å¤±è´¥: %@",
                  attempt + 1, typeName, error.localizedDescription);
            error = nil; // æ¸…é™¤é”™è¯¯ä»¥ä¾¿ä¸‹æ¬¡å°è¯•
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"âŒ %@ æœ€ç»ˆæ— æ³•è·å–åˆ°æ•°æ®", typeName);
    return nil;
}




#pragma mark - æ•°æ®æŸ¥è¯¢

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // æ£€æŸ¥ç¼“å­˜
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // ä½¿ç”¨çœŸå®çš„æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // ç¼“å­˜ç»“æœ
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - çœŸå®æ•°æ®è·å–å®ç°

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"ğŸ”§ ä½¿ç”¨ä¿®å¤ç‰ˆè·å– %@ æ•°æ®", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // æ·»åŠ è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // âœ… å…³é”®ä¿®å¤ï¼šæ¯æ¬¡æ•°æ®è·å–å‰éƒ½é‡æ–°å»ºç«‹ MobileSync è¿æ¥
        [self logMessage:@"ğŸ”„ é‡æ–°å»ºç«‹ MobileSync è¿æ¥ä»¥ç¡®ä¿æ•°æ®è·å–ç¨³å®šæ€§"];
        
        // å¼ºåˆ¶æ–­å¼€å¹¶é‡å»º MobileSync è¿æ¥
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // çŸ­æš‚ç­‰å¾…ï¼Œè®©è®¾å¤‡é‡ç½®çŠ¶æ€
        [NSThread sleepForTimeInterval:0.5];
        
        // é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"âŒ é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡å¤±è´¥: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"âœ… MobileSync è¿æ¥å·²é‡æ–°å»ºç«‹"];
        
        // âœ… å…³é”®ä¿®å¤2ï¼šä½¿ç”¨ä¸æ£€æµ‹æ—¶ç›¸åŒçš„å‚æ•°
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"âŒ åˆ›å»ºanchorså¤±è´¥"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // âœ… å…³é”®ä¿®å¤3ï¼šä½¿ç”¨æ£€æµ‹æ—¶å®Œå…¨ç›¸åŒçš„å‚æ•°
        uint64_t data_class_version = 106;  // ä¸æ£€æµ‹æ—¶ä¿æŒä¸€è‡´
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"ğŸ”§ ä½¿ç”¨å¹²å‡€è¿æ¥å¯åŠ¨åŒæ­¥ä¼šè¯: %@", syncClass]];
        
        // âœ… å…³é”®ä¿®å¤4ï¼šå¯åŠ¨åŒæ­¥ä¼šè¯
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"âœ… %@ åŒæ­¥ä¼šè¯å¯åŠ¨æˆåŠŸï¼ˆå¹²å‡€è¿æ¥ï¼‰", syncClass]];
            
            // âœ… ä½¿ç”¨æ›´ç¨³å®šçš„æ•°æ®è·å–æ–¹æ³•
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"âœ… æˆåŠŸè¯·æ±‚ %@ çš„æ‰€æœ‰è®°å½•", syncClass]];
                
                // âœ… æ”¹è¿›çš„æ•°æ®æ¥æ”¶é€»è¾‘ - å¤„ç†è¶…æ—¶å’Œå¤šæ‰¹æ¬¡æ•°æ®
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // å‡å°‘æœ€å¤§æ‰¹æ¬¡æ•°é‡
                int timeoutCount = 0;
                int maxTimeouts = 2; // å…è®¸çš„æœ€å¤§è¶…æ—¶æ¬¡æ•°
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"ğŸ“¦ mobilesync_receive_changes è¿”å›çŠ¶æ€: %d (æ‰¹æ¬¡ %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // é‡ç½®è¶…æ—¶è®¡æ•°å™¨
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"ğŸ“¦ å¤„ç† %@ ç¬¬ %d æ‰¹æ•°æ®",
                                            syncClass, batchCount]];
                            
                            // ğŸ” è¯¦ç»†åˆ†ææ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"ğŸ“Š æ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // ğŸ”§ æ”¹è¿›çš„æ•°æ®å¤„ç†ï¼šæ”¯æŒå¤šç§æ•°æ®ç±»å‹
                            NSArray<SyncDataItem *> *batchItems = [self processReceivedDataEnhanced:entities
                                                                                            dataType:dataType
                                                                                           syncClass:syncClass
                                                                                          batchIndex:batchCount];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"âœ… ä»ç¬¬ %d æ‰¹è·å–åˆ° %lu é¡¹æ•°æ®",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ ç¬¬ %d æ‰¹æ•°æ®ä¸ºç©ºæˆ–å¤„ç†å¤±è´¥", batchCount]];
                            }
                            
                            // æ¸…ç†resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"ğŸ“­ ç¬¬ %d æ‰¹ %@ è¿”å›ç©ºæ•°æ®", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // ğŸ”§ æ”¹è¿›çš„è¶…æ—¶å¤„ç†
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"â° %@ æ¥æ”¶è¶…æ—¶ (ç¬¬ %d æ¬¡ï¼Œå…± %d æ¬¡)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ è¶…æ—¶æ¬¡æ•°è¾¾åˆ°ä¸Šé™ï¼Œåœæ­¢æ¥æ”¶", syncClass]];
                            break;
                        }
                        
                        // å¦‚æœå·²ç»è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸çš„ç»“æŸä¿¡å·
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ å·²è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸ç»“æŸ", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"âŒ æ¥æ”¶ %@ æ•°æ®æ—¶å‡ºé”™: %d",
                                        syncClass, receive_err]];
                        
                        // ğŸ”§ å¢å¼ºçš„é”™è¯¯å¤„ç†
                        [self handleReceiveError:receive_err forSyncClass:syncClass];
                        break;
                    }
                    
                    // é˜²æ­¢æ— é™å¾ªç¯
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ è¾¾åˆ°æœ€å¤§æ‰¹æ¬¡é™åˆ¶(%d)ï¼Œåœæ­¢æ¥æ”¶",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // å¦‚æœæ ‡è®°ä¸ºæœ€åä¸€æ¡è®°å½•ï¼Œç›´æ¥é€€å‡º
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"ğŸ %@ æ¥æ”¶åˆ°æœ€åè®°å½•æ ‡è®°ï¼Œæ­£å¸¸ç»“æŸ", syncClass]];
                        break;
                    }
                    
                    // æ·»åŠ å°å»¶è¿Ÿï¼Œé¿å…è¿‡åº¦è¯·æ±‚
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // ä½¿ç”¨å†…éƒ¨é€»è¾‘æ§åˆ¶å¾ªç¯
                
                [self logMessage:[NSString stringWithFormat:@"ğŸ“Š %@ æ•°æ®æ¥æ”¶å®Œæˆ: %d æ‰¹æ¬¡, %lu é¡¹",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"âŒ %@ get_all_recordså¤±è´¥: %d",
                                syncClass, get_all_err]];
                [self handleSyncError:get_all_err forDataType:dataType operation:@"get_all_records"];
                
                // ğŸ”§ ä¸ºæŸäº›é”™è¯¯æä¾›æ›´å¥½çš„é”™è¯¯ä¿¡æ¯
                if (error) {
                    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:get_all_err];
                    *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                     description:errorDesc];
                }
            }
            
            // âœ… ç¡®ä¿ä¼šè¯æ­£ç¡®ç»“æŸ
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"âœ… %@ åŒæ­¥ä¼šè¯å·²ç»“æŸ", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"âŒ %@ mobilesync_startå¤±è´¥ï¼ˆå¹²å‡€è¿æ¥åï¼‰: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"é”™è¯¯è¯¦æƒ…: %s", error_description]];
            }
            
            // âœ… å…³é”®ä¿®å¤5ï¼šå¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œè¯´æ˜æ˜¯çœŸæ­£çš„ä¸å…¼å®¹
            [self handleStartSyncError:start_err forSyncClass:syncClass error:error];
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // âœ… å³ä½¿æ²¡æœ‰è·å–åˆ°æ•°æ®ä¹Ÿä¸ç®—é”™è¯¯
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ²¡æœ‰å¯ç”¨æ•°æ®ï¼ˆä½¿ç”¨å¹²å‡€è¿æ¥åç¡®è®¤ï¼‰", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"ğŸ“Š %@ æœ€ç»ˆè·å–åˆ° %lu é¡¹çœŸå®æ•°æ®ï¼ˆå¹²å‡€è¿æ¥ï¼‰",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ æ•°æ®è·å–å¼‚å¸¸: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}


- (NSArray<SyncDataItem *> *)processReceivedDataEnhanced:(plist_t)entities
                                                dataType:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                              batchIndex:(int)batchIndex {
    
    if (!entities) {
        [self logMessage:[NSString stringWithFormat:@"ç¬¬ %d æ‰¹ %@ æ•°æ®ä¸ºç©º", batchIndex, syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(entities);
    
    // ğŸ”§ å¤„ç†ä¸åŒçš„æ•°æ®ç±»å‹
    switch (type) {
        case PLIST_ARRAY: {
            // æ ‡å‡†æ•°ç»„å¤„ç†
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ å¤„ç† %@ æ•°ç»„æ•°æ®", syncClass]];
            return [self processRealDataForType:dataType dataArray:entities syncClass:syncClass];
        }
        
        case PLIST_BOOLEAN: {
            // å¸ƒå°”å€¼å¯èƒ½è¡¨ç¤ºåŒæ­¥çŠ¶æ€æˆ–ç©ºæ•°æ®
            uint8_t bool_val = 0;
            plist_get_bool_val(entities, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ è¿”å›å¸ƒå°”å€¼: %s",
                             syncClass, bool_val ? "true" : "false"]];
            
            if (bool_val) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ åŒæ­¥æˆåŠŸä½†æ— æ•°æ®é¡¹", syncClass]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ åŒæ­¥å¤±è´¥æˆ–ä¸æ”¯æŒ", syncClass]];
            }
            return @[];
        }
        
        case PLIST_DICT: {
            // å­—å…¸å¯èƒ½åŒ…å«é”™è¯¯ä¿¡æ¯æˆ–çŠ¶æ€
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ è¿”å›å­—å…¸æ•°æ®ï¼Œå°è¯•è§£æ", syncClass]];
            
            // å…ˆæ£€æŸ¥å­—å…¸ä¸­çš„å†…å®¹
            uint32_t dict_size = plist_dict_get_size(entities);
            [self logMessage:[NSString stringWithFormat:@"ğŸ“Š å­—å…¸åŒ…å« %u ä¸ªé”®å€¼å¯¹", dict_size]];
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«é”™è¯¯ä¿¡æ¯
            plist_t error_node = plist_dict_get_item(entities, "Error");
            if (error_node) {
                char *error_msg = NULL;
                if (plist_get_node_type(error_node) == PLIST_STRING) {
                    plist_get_string_val(error_node, &error_msg);
                    if (error_msg) {
                        [self logMessage:[NSString stringWithFormat:@"âŒ %@ é”™è¯¯: %s", syncClass, error_msg]];
                        free(error_msg);
                    }
                }
                return @[];
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«çŠ¶æ€ä¿¡æ¯
            plist_t status_node = plist_dict_get_item(entities, "Status");
            if (status_node && plist_get_node_type(status_node) == PLIST_STRING) {
                char *status_msg = NULL;
                plist_get_string_val(status_node, &status_msg);
                if (status_msg) {
                    [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ çŠ¶æ€: %s", syncClass, status_msg]];
                    free(status_msg);
                }
            }
            
            // å¦‚æœå­—å…¸ä¸ºç©ºæˆ–åŒ…å«æœ‰ç”¨æ•°æ®ï¼Œå°è¯•å¤„ç†ä¸ºå•ä¸ªé¡¹ç›®
            if (dict_size > 0) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ å°è¯•å°† %@ å­—å…¸ä½œä¸ºæ•°æ®é¡¹å¤„ç†", syncClass]];
                SyncDataItem *item = [self createSyncItemFromPlist:entities dataType:dataType index:0];
                if (item) {
                    [self logMessage:[NSString stringWithFormat:@"âœ… æˆåŠŸåˆ›å»º %@ æ•°æ®é¡¹: %@", syncClass, item.name ?: @"æœªå‘½å"]];
                    return @[item];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"âŒ æ— æ³•ä» %@ å­—å…¸åˆ›å»ºæ•°æ®é¡¹", syncClass]];
                }
            }
            
            return @[];
        }
        
        case PLIST_STRING: {
            // å­—ç¬¦ä¸²å¯èƒ½æ˜¯é”™è¯¯æ¶ˆæ¯
            char *str_val = NULL;
            plist_get_string_val(entities, &str_val);
            if (str_val) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ è¿”å›å­—ç¬¦ä¸²: %s", syncClass, str_val]];
                free(str_val);
            }
            return @[];
        }
        
        case PLIST_UINT: {
            // æ•°å­—å¯èƒ½æ˜¯çŠ¶æ€ç 
            uint64_t uint_val = 0;
            plist_get_uint_val(entities, &uint_val);
            [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ è¿”å›æ•°å­—: %llu", syncClass, uint_val]];
            return @[];
        }
        
        default: {
            [self logMessage:[NSString stringWithFormat:@"âš ï¸ %@ è¿”å›æœªçŸ¥æ•°æ®ç±»å‹ %@ (%d)",
                             syncClass, [self stringForPlistType:type], type]];
            return @[];
        }
    }
}

// ğŸ”§ å¢å¼ºçš„é”™è¯¯å¤„ç† - æ”¹è¿›è¶…æ—¶å¤„ç†
- (void)handleReceiveError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass {
    NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
    
    switch (error) {
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:[NSString stringWithFormat:@"â° %@ æ•°æ®æ¥æ”¶è¶…æ—¶ï¼Œè¿™å¯èƒ½æ˜¯æ­£å¸¸çš„ç»“æŸä¿¡å·", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:[NSString stringWithFormat:@"ğŸ”Œ %@ è¿æ¥ä¸­æ–­ï¼Œè®¾å¤‡å¯èƒ½æ–­å¼€è¿æ¥", syncClass]];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ•°æ®æ ¼å¼é”™è¯¯ï¼Œplistè§£æå¤±è´¥", syncClass]];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"ğŸ“¤ %@ æ¥æ”¶é”™è¯¯: %@", syncClass, errorDesc]];
            break;
    }
}

- (void)handleStartSyncError:(mobilesync_error_t)error forSyncClass:(NSString *)syncClass error:(NSError **)outError {
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ åœ¨å¹²å‡€è¿æ¥åä»ç„¶å‚æ•°æ— æ•ˆï¼Œè¯¥è®¾å¤‡ç¡®å®ä¸æ”¯æŒæ­¤æ•°æ®ç±»å‹çš„æ•°æ®è·å–", syncClass]];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"ğŸ’¡ è¿æ¥é”™è¯¯ï¼Œè®¾å¤‡å¯èƒ½å·²æ–­å¼€"];
            if (outError) {
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                    description:@"Device connection lost during sync"];
            }
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ å¯åŠ¨åŒæ­¥å¤±è´¥ï¼Œé”™è¯¯ç : %d", syncClass, error]];
            if (outError) {
                NSString *errorDesc = [self getErrorDescriptionForMobileSyncError:error];
                *outError = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                    description:errorDesc];
            }
            break;
    }
    
    [self handleSyncError:error forDataType:0 operation:@"start_sync"];
}


// ğŸ”§ è·å–MobileSyncé”™è¯¯çš„æè¿°
- (NSString *)getErrorDescriptionForMobileSyncError:(mobilesync_error_t)error {
    switch (error) {
        case MOBILESYNC_E_SUCCESS:
            return @"Success";
        case MOBILESYNC_E_INVALID_ARG:
            return @"Invalid argument - check sync class name and parameters";
        case MOBILESYNC_E_PLIST_ERROR:
            return @"Plist parsing error - data format issue";
        case MOBILESYNC_E_MUX_ERROR:
            return @"Connection error - device may have disconnected";
        case MOBILESYNC_E_SSL_ERROR:
            return @"SSL error - secure connection failed";
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            return @"Receive timeout - device not responding";
        case MOBILESYNC_E_BAD_VERSION:
            return @"Version mismatch - sync protocol version not supported";
        default:
            return [NSString stringWithFormat:@"Unknown sync error: %d", error];
    }
}

// âœ… æ–°å¢ï¼šæ”¹è¿›çš„æ•°æ®å¤„ç†æ–¹æ³•ï¼Œæ›´å¥½åœ°å¤„ç†ç©ºæ•°æ®æƒ…å†µ
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ•°æ®ä¸ºç©ºï¼Œåˆ›å»ºç©ºæ•°æ®å­—å…¸", typeName]];
        
        // âœ… å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿåˆ›å»ºä¸€ä¸ªæœ‰æ•ˆçš„å­—å…¸
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ æ”¯æŒä½†å½“å‰æ— æ•°æ®", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

// âœ… æ–°å¢ï¼šæ”¹è¿›çš„å¢å¼ºæ•°æ®æ‰«ææ–¹æ³•
- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== ğŸ”§ å¼€å§‹ä¿®å¤ç‰ˆè®¾å¤‡çœŸå®æ•°æ®æ‰«æ ===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // âœ… é¦–å…ˆè·å–æ”¯æŒçš„æ•°æ®ç±»å‹
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"âŒ è·å–æ”¯æŒçš„æ•°æ®ç±»å‹å¤±è´¥: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"âŒ è®¾å¤‡ä¸æ”¯æŒä»»ä½•æ•°æ®ç±»å‹çš„é€‰æ‹©æ€§åŒæ­¥");
        return @{};
    }
    
    NSLog(@"âœ… è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // é€ä¸ªå¤„ç†æ”¯æŒçš„æ•°æ®ç±»å‹
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // åªå¤„ç†è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹
        if (!(supportedTypes & dataType)) {
            NSLog(@"â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: %@", typeName);
            continue;
        }
        
        NSLog(@"ğŸ” æ­£åœ¨è·å– %@ çš„çœŸå®æ•°æ®...", typeName);
        
        // âœ… ä½¿ç”¨æ”¹è¿›çš„æ•°æ®è·å–æ–¹æ³•
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"ğŸ“‹ %@ æ”¯æŒä½†æ— æ•°æ®: %@ é¡¹", typeName, itemCount);
            } else {
                NSLog(@"âœ… %@ è·å–æˆåŠŸ: %@ é¡¹", typeName, itemCount);
            }
        } else {
            NSLog(@"âŒ %@ è·å–å¤±è´¥æˆ–æ— å“åº”", typeName);
        }
        
        // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== ğŸ”§ ä¿®å¤ç‰ˆæ•°æ®æ‰«æå®Œæˆï¼Œå…±å¤„ç† %lu ç§æ•°æ®ç±»å‹ ===",
          (unsigned long)realData.count);
    return [realData copy];
}

#pragma mark - çœŸå®æ•°æ®å¤„ç†æ–¹æ³•

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¤„ç†éæ•°ç»„ç±»å‹çš„æƒ…å†µ
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ %@ è¿”å›éæ•°ç»„æ•°æ®ï¼Œå¯èƒ½è¡¨ç¤ºç©ºæ•°æ®é›†", syncClass]];
        
        // å¦‚æœæ˜¯å¸ƒå°”ç±»å‹ï¼Œå¯èƒ½è¡¨ç¤ºåŒæ­¥çŠ¶æ€
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥çŠ¶æ€: %s",
                             syncClass, bool_val ? "æˆåŠŸ" : "å¤±è´¥"]];
        }
        
        return @[]; // è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯å¤±è´¥
    }
    
    // ç»§ç»­å¤„ç†æ•°ç»„æ•°æ®...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}


- (BOOL)checkDeviceCompatibility:(NSError **)error {
    if (![self isConnected]) {
        return NO;
    }
    
    // è·å–è®¾å¤‡ä¿¡æ¯
    char *device_name = NULL;
    plist_t product_version_plist = NULL;
    
    // è·å–è®¾å¤‡åç§°
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"è®¾å¤‡åç§°: %s", device_name]];
        free(device_name);
    }
    
    // è·å–iOSç‰ˆæœ¬
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &product_version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && product_version_plist) {
        char *product_version = NULL;
        plist_get_string_val(product_version_plist, &product_version);
        
        if (product_version) {
            [self logMessage:[NSString stringWithFormat:@"iOSç‰ˆæœ¬: %s", product_version]];
            
            // æ£€æŸ¥iOSç‰ˆæœ¬å…¼å®¹æ€§
            NSString *versionStr = [NSString stringWithUTF8String:product_version];
            NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
            
            if (versionComponents.count > 0) {
                NSInteger majorVersion = [versionComponents[0] integerValue];
                
                if (majorVersion < 9) {
                    [self logMessage:@"âš ï¸ iOSç‰ˆæœ¬è¿‡ä½ï¼Œå¯èƒ½ä¸æ”¯æŒé€‰æ‹©æ€§åŒæ­¥"];
                } else if (majorVersion >= 15) {
                    [self logMessage:@"ğŸ’¡ iOS 15+è®¾å¤‡ï¼Œå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†"];
                }
            }
            
            free(product_version);
        }
        
        plist_free(product_version_plist);
    }
    
    return YES;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // æå–é€šç”¨å­—æ®µ
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // æ ¹æ®æ•°æ®ç±»å‹æå–ç‰¹å®šå­—æ®µ
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeMailAccounts:
            [self extractMailAccountSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // å¦‚æœæ²¡æœ‰æ ‡è¯†ç¬¦ï¼Œä½¿ç”¨ç´¢å¼•
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // å¦‚æœæ²¡æœ‰åç§°ï¼Œä½¿ç”¨é»˜è®¤åç§°
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // æå–è®°å½•ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // æå–ä¿®æ”¹æ—¶é—´
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // ä¼°ç®—æ•°æ®å¤§å°
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // é»˜è®¤å¤§å°
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å§“åå­—æ®µ
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // ç”µè¯å·ç 
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // é‚®ç®±åœ°å€
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æ—¥å†æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å¼€å§‹æ—¶é—´
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // ç»“æŸæ—¶é—´
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // ä¹¦ç­¾æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // ä¹¦ç­¾æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å¤‡å¿˜å½•æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å†…å®¹
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // å¤§æ¦‚ä¼°ç®—
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æé†’äº‹é¡¹æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å®ŒæˆçŠ¶æ€
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // ä¼˜å…ˆçº§
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å°è¯•å„ç§å¯èƒ½çš„åç§°å­—æ®µ
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // æ·»åŠ ä¸€äº›é€šç”¨å…ƒæ•°æ®
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

#pragma mark - é€‰æ‹©æ€§åŒæ­¥æ“ä½œ

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // å¼‚æ­¥æ‰§è¡ŒåŒæ­¥æ“ä½œ
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // åˆ†è§£æ•°æ®ç±»å‹ä¸ºå•ç‹¬çš„ç±»å‹
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // æŒ‰æ•°æ®ç±»å‹åˆ†ç»„
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // å¯¹æ¯ç§æ•°æ®ç±»å‹æ‰§è¡ŒåŒæ­¥
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // è¿™é‡Œå¯ä»¥å®ç°æ›´ç»†ç²’åº¦çš„é¡¹ç›®åŒæ­¥é€»è¾‘
        // ç›®å‰å…ˆä½¿ç”¨æ•°æ®ç±»å‹çº§åˆ«çš„åŒæ­¥
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // åˆ›å»ºå¤‡ä»½ç›®å½•
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - æ“ä½œæ§åˆ¶

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - åŒæ­¥æ“ä½œå®ç°

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // æ ¹æ®æ–¹å‘æ‰§è¡Œä¸åŒçš„æ“ä½œ
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // åŒå‘åŒæ­¥æš‚æ—¶ä¸å®ç°
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // è·å–æ•°æ®é¡¹
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // åˆ›å»ºæ•°æ®ç±»å‹ç›®å½•
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // ä¿å­˜æ•°æ®é¡¹ä¿¡æ¯
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // ä¿å­˜å¤‡ä»½å…ƒæ•°æ®
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - æ•°æ®ç±»å‹å·¥å…·æ–¹æ³•

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeMailAccounts:
            return @"MailAccounts";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æœ¬åœ°åŒ–æ”¯æŒ
    // ç›®å‰è¿”å›è‹±æ–‡ç‰ˆæœ¬
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeMailAccounts) [array addObject:@(BackupDataTypeMailAccounts)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper)
    ];
}

#pragma mark - ä¾¿æ·æ–¹æ³•

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *mailAccountsPath = [_dataStoragePath stringByAppendingPathComponent:@"MailAccounts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeMailAccounts
                                     toDirectory:mailAccountsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}



- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // è®¾ç½®å®Œæˆå›è°ƒæ¥æ•è·ç»“æœ
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - æ•°æ®éªŒè¯å’Œæ¢å¤

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // å°è¯•è¯»å–æ–‡ä»¶ä»¥éªŒè¯æ ¼å¼
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // å‚æ•°éªŒè¯
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // ç¡®ä¿æ˜¯ç›®å½•è€Œä¸æ˜¯æ–‡ä»¶
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // è·å–åŸºæœ¬ä¿¡æ¯ - æ·»åŠ é”™è¯¯å¤„ç†
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // è®¾ç½®é»˜è®¤å€¼
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // æ‰«ææ•°æ®ç±»å‹
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œé¿å…å†…å­˜ç´¯ç§¯
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // æ£€æŸ¥items.plistæ˜¯å¦å­˜åœ¨
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // å°è¯•è¯»å–itemsæ•°æ®
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // è®¡ç®—è¯¥æ•°æ®ç±»å‹çš„å¤§å°
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // è®¾ç½®æ±‡æ€»ä¿¡æ¯
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // æ·»åŠ å¤‡ä»½ç»Ÿè®¡ä¿¡æ¯
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - éªŒè¯å’Œé”™è¯¯å¤„ç†

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¢å¼ºçš„ç±»å‹æ£€æŸ¥å’Œæ—¥å¿—
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // å¦‚æœä¸æ˜¯æ•°ç»„ï¼Œå°è¯•å¤„ç†å…¶ä»–å¯èƒ½çš„ç±»å‹
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // å¯èƒ½è¡¨ç¤ºæ²¡æœ‰æ•°æ®æˆ–æ“ä½œå¤±è´¥
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // å¦‚æœæ˜¯trueï¼Œå¯èƒ½è¡¨ç¤ºæˆåŠŸä½†æ— æ•°æ®
        }
        
        [self logMessage:[NSString stringWithFormat:@"âš ï¸ Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

#pragma mark - æ–°å¢çš„è¾…åŠ©æ–¹æ³•

// ğŸ”§ è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥ - ä¿®å¤ç‰ˆæœ¬
- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"ğŸ“± è®¾å¤‡æœªè¿æ¥æˆ–lockdownæœªåˆå§‹åŒ–"];
        return;
    }
    
    // ä¿®å¤1ï¼šæ­£ç¡®è·å–è®¾å¤‡åç§°
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è®¾å¤‡åç§°: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è·å–è®¾å¤‡åç§°å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤2ï¼šæ­£ç¡®è·å–iOSç‰ˆæœ¬
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ“± iOSç‰ˆæœ¬: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"âš ï¸ iOSç‰ˆæœ¬è¿‡ä½ï¼Œå¯èƒ½ä¸æ”¯æŒé€‰æ‹©æ€§åŒæ­¥"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"ğŸ’¡ iOS 15+è®¾å¤‡ï¼Œæ•°æ®æ ¼å¼å¯èƒ½æœ‰å˜åŒ–"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"ğŸ’¡ iOS %ld è®¾å¤‡ï¼Œå…¼å®¹æ€§è‰¯å¥½", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è·å–iOSç‰ˆæœ¬å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤3ï¼šæ­£ç¡®è·å–è®¾å¤‡å‹å·
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"ğŸ“± è®¾å¤‡å‹å·: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“± è·å–è®¾å¤‡å‹å·å¤±è´¥: %d", ret]];
    }
}

// ğŸ”§ Plistç±»å‹è½¬æ¢ä¸ºå¯è¯»å­—ç¬¦ä¸²
- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}


- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // æ ¹æ®é”™è¯¯ç±»å‹é‡‡å–ä¸åŒçš„å¤„ç†ç­–ç•¥
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // å°è¯•é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æ”¯æŒæ­¤æ•°æ®ç±»å‹
    return [self isDataTypeSupported:dataType];
}

#pragma mark - è°ƒè¯•å’Œè¯Šæ–­å·¥å…·

- (void)diagnoseDeviceSyncCapabilities {
    
    if (![self isConnected]) {
        [self logMessage:@"Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"âœ…" : @"âŒ";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount)
            };
        }
    }
    
    return info;
}

#pragma mark - ç§æœ‰æ–¹æ³•å®ç°

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - å·¥å…·æ–¹æ³•

- (void)logMessage:(NSString *)message {
    NSString *timestamp = [self getCurrentTimestamp];
    NSString *logMessage = [NSString stringWithFormat:@"[%@] [BackupOptionTask] %@", timestamp, message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}



// âœ… æ ¼å¼åŒ–æ–‡ä»¶å¤§å°æ–¹æ³• - å¦‚æœä¸å­˜åœ¨çš„è¯
- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}



// getDataItemsSimplified æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"è·å–ç®€åŒ–æ•°æ®é¡¹ - ç±»å‹: %@, åŒæ­¥ç±»: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // éªŒè¯å‚æ•°
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"åŒæ­¥ç±»å‚æ•°ä¸èƒ½ä¸ºç©º"];
        }
        return @[];
    }
    
    // ç¡®ä¿è®¾å¤‡è¿æ¥
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"è®¾å¤‡æœªè¿æ¥"];
        }
        return @[];
    }
    
    // âœ… å…³é”®ä¿®å¤ï¼šç§»é™¤é‡å¤çš„æ”¯æŒæ£€æŸ¥
    // ä¸Šå±‚ä»£ç å·²ç»é€šè¿‡ getSupportedDataTypes éªŒè¯è¿‡æ”¯æŒæ€§ï¼Œé¿å…é‡å¤æ£€æŸ¥å¯¼è‡´çŠ¶æ€å†²çª
    [self logMessage:[NSString stringWithFormat:@"è·³è¿‡é‡å¤æ”¯æŒæ£€æŸ¥ï¼Œç›´æ¥è·å– %@ æ•°æ®", syncClass]];
    
    // ç›´æ¥è°ƒç”¨æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"âœ… æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"ğŸ“‹ %@ æ•°æ®ä¸ºç©ºæˆ–è·å–å¤±è´¥", syncClass]];
    }
    
    return items ?: @[];
}



@end


-------------------------------------

V1çš„ä»£ç ï¼š

//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Complete Enhanced Version with Photos/Camera Support - 2025.01.27
//  Based on libimobiledevice mobilesync and AFC APIs
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// å¼•å…¥ libimobiledevice ç›¸å…³å¤´æ–‡ä»¶
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// å¸¸é‡å®šä¹‰
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// ğŸ†• ç…§ç‰‡ç›¸å…³å¸¸é‡
NSString * const kPhotoLibraryPath = @"/DCIM";
NSString * const kCameraRollPath = @"/DCIM/100APPLE";
NSString * const kPhotoStreamPath = @"/PhotoData";
NSString * const kThumbnailsPath = @"/PhotoData/Thumbnails";

// æ”¯æŒçš„ç…§ç‰‡æ ¼å¼
static NSArray *SupportedPhotoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEIF", @"HEIC", @"JPEG", @"JPG", @"PNG", @"GIF", @"TIFF", @"BMP"];
    });
    return formats;
}

// æ”¯æŒçš„è§†é¢‘æ ¼å¼
static NSArray *SupportedVideoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEVC", @"H264", @"MP4", @"MOV", @"M4V", @"3GP"];
    });
    return formats;
}

// åŸºäºå®é™…iOSåŒæ­¥ç±»çš„æ•°æ®ç±»å‹æ˜ å°„ - å®Œæ•´ç‰ˆæœ¬
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            // åŸæœ‰çš„åŒæ­¥ç±»
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.Bookmarks",
            @(BackupDataTypeMailAccounts): @"com.apple.MailAccounts",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper",
            
            // ğŸ†• ç…§ç‰‡å’Œåª’ä½“ç›¸å…³çš„åŒæ­¥ç±»
            @(BackupDataTypePhotos): @"com.apple.Photos",
            @(BackupDataTypeVideos): @"com.apple.MediaAssets",
            @(BackupDataTypeCameraRoll): @"com.apple.CameraRoll",
            @(BackupDataTypePhotoAlbums): @"com.apple.PhotoAlbums",
            @(BackupDataTypePhotoStream): @"com.apple.PhotoStream",
            @(BackupDataTypeScreenshots): @"com.apple.Screenshots",
            @(BackupDataTypeSlowMotion): @"com.apple.SlowMotion",
            @(BackupDataTypeTimelapses): @"com.apple.Timelapses",
            @(BackupDataTypeBurstPhotos): @"com.apple.BurstPhotos",
            @(BackupDataTypeLivePhotos): @"com.apple.LivePhotos"
        };
    });
    return map;
}

// ğŸ†• ç…§ç‰‡è·¯å¾„æ˜ å°„
static NSDictionary *PhotoTypeToPathMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            @(BackupDataTypePhotos): @"/DCIM",
            @(BackupDataTypeVideos): @"/DCIM",
            @(BackupDataTypeCameraRoll): @"/DCIM/100APPLE",
            @(BackupDataTypePhotoAlbums): @"/PhotoData/Albums",
            @(BackupDataTypePhotoStream): @"/PhotoData/PhotoStream",
            @(BackupDataTypeScreenshots): @"/DCIM/Screenshots",
            @(BackupDataTypeSlowMotion): @"/DCIM/SlowMotion",
            @(BackupDataTypeTimelapses): @"/DCIM/Timelapses",
            @(BackupDataTypeBurstPhotos): @"/DCIM/Bursts",
            @(BackupDataTypeLivePhotos): @"/DCIM/LivePhotos"
        };
    });
    return map;
}

// è·å–å·²çŸ¥çš„åŒæ­¥ç±»åˆ—è¡¨ - ç”¨äºæ£€æµ‹æ”¯æŒçš„æ•°æ®ç±»å‹
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.Bookmarks",
            @"com.apple.MailAccounts",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - PhotoInfo å®ç°

@implementation PhotoInfo

- (instancetype)init {
    self = [super init];
    if (self) {
        _isVideo = NO;
        _isLivePhoto = NO;
        _isBurst = NO;
        _isScreenshot = NO;
        _isFavorite = NO;
        _videoDuration = 0;
        _width = 0;
        _height = 0;
        _fileSize = 0;
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<PhotoInfo: %@ (%@) - %lux%lu, %@ KB>",
            self.filename, self.format,
            (unsigned long)self.width, (unsigned long)self.height,
            @(self.fileSize / 1024)];
}

@end

#pragma mark - SyncDataItem å®Œæ•´å®ç°

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
        _isMediaFile = NO;
    }
    return self;
}

- (NSString *)description {
    if (self.isMediaFile && self.photoInfo) {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (Media: %@) - %@ records>",
                self.name, self.photoInfo.filename, @(self.recordCount)];
    } else {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
                self.name, self.identifier, @(self.recordCount)];
    }
}

@end

#pragma mark - BackupOptionTask å†…éƒ¨æ¥å£

// åœ¨ç±»çš„å†…éƒ¨æ¥å£ä¸­æ·»åŠ çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—
@interface BackupOptionTask () {
    // libimobiledevice C API æŒ‡é’ˆ
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // ğŸ†• AFC è¿æ¥ - ç”¨äºæ–‡ä»¶ä¼ è¾“
    afc_client_t _afc_photos;  // ä¸“ç”¨äºç…§ç‰‡ä¼ è¾“çš„AFCè¿æ¥
    
    // æ“ä½œçŠ¶æ€
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // åŒæ­¥ä¸Šä¸‹æ–‡
    dispatch_queue_t _operationQueue;
    dispatch_queue_t _photoQueue;  // ğŸ†• ä¸“ç”¨äºç…§ç‰‡æ“ä½œçš„é˜Ÿåˆ—
    dispatch_queue_t _connectionQueue;  // ğŸ†• ä¸“ç”¨äºè¿æ¥æ“ä½œçš„é˜Ÿåˆ—ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;
    NSMutableDictionary *_photoCache; // ğŸ†• ç…§ç‰‡ç¼“å­˜
    
    // å½“å‰æ“ä½œå‚æ•°
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // å†…éƒ¨çŠ¶æ€
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
    
    // ğŸ†• ç…§ç‰‡ç›¸å…³çŠ¶æ€
    NSUInteger _totalPhotosToProcess;
    NSUInteger _processedPhotos;
    NSUInteger _photoDownloadedBytes;
    NSUInteger _photoTotalBytes;
    
    // ğŸ†• çº¿ç¨‹å®‰å…¨æ ‡å¿—
    NSRecursiveLock *_connectionLock;
}

// ç§æœ‰æ–¹æ³•å£°æ˜
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// ğŸ†• AFC æœåŠ¡ç›¸å…³æ–¹æ³•
- (BOOL)startAFCService:(NSError **)error;
- (BOOL)startPhotoAFCService:(NSError **)error;
- (void)closeAFCServices;

// ğŸ†• ç…§ç‰‡æ‰«æå’Œå¤„ç†æ–¹æ³•
- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error;
- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                               afcClient:(afc_client_t)afcClient
                                   error:(NSError **)error;
- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath
                            afcClient:(afc_client_t)afcClient;
- (BOOL)isPhotoFile:(NSString *)filename;
- (BOOL)isVideoFile:(NSString *)filename;
- (NSString *)getFileExtension:(NSString *)filename;

// çœŸå®æ•°æ®å¤„ç†æ–¹æ³•
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// ğŸ†• ç…§ç‰‡æ•°æ®å¤„ç†æ–¹æ³•
- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error;
- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType;
- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType;

// æ•°æ®è·å–æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// åŒæ­¥æ“ä½œæ–¹æ³•
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// ğŸ†• ç…§ç‰‡ç‰¹å®šçš„å¤‡ä»½å’Œæ¢å¤æ–¹æ³•
- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;

// éªŒè¯å’Œé”™è¯¯å¤„ç†
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;
- (BOOL)ensureStableConnection:(NSError **)error;
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType;

// ğŸ†• ç…§ç‰‡ç›¸å…³éªŒè¯æ–¹æ³•
- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error;
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error;

// å·¥å…·æ–¹æ³•
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;
- (NSString *)stringForPlistType:(plist_type)type;
- (NSString *)formatDuration:(NSTimeInterval)duration;

// ğŸ†• å†…éƒ¨è¿æ¥æ–¹æ³•ï¼ˆä¸ä½¿ç”¨é”ï¼Œé¿å…é€’å½’é”ï¼‰
- (BOOL)isConnectedInternal;
- (void)disconnectDeviceInternal;


- (NSString *)generateThumbnailPath:(NSString *)originalPath;
- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize;
- (void)checkDeviceCompatibilityForSync;
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType;
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType;

@end

#pragma mark - BackupOptionTask å®Œæ•´å®ç°

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;

#pragma mark - å•ä¾‹å’Œåˆå§‹åŒ–

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _photoQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.photo", DISPATCH_QUEUE_CONCURRENT);
        _connectionQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.connection", DISPATCH_QUEUE_SERIAL);
        _connectionLock = [[NSRecursiveLock alloc] init];
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        _photoCache = [NSMutableDictionary dictionary];
        
        // ğŸ†• ç…§ç‰‡ä¼ è¾“è®¾ç½®é»˜è®¤å€¼
        _photoTransferMode = PhotoTransferModeOriginal;
        _enableThumbnailGeneration = YES;
        _maxPhotoResolution = 0; // æ— é™åˆ¶
        _preserveOriginalFormat = YES;
        _includeHiddenPhotos = NO;
        _includeLivePhotos = YES;
        _includeVideoFiles = YES;
        
        // è®¾ç½®é»˜è®¤æ•°æ®å­˜å‚¨è·¯å¾„
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        _totalPhotosToProcess = 0;
        _processedPhotos = 0;
        _photoDownloadedBytes = 0;
        _photoTotalBytes = 0;
        
        [self logMessage:[NSString stringWithFormat:@"Complete Enhanced BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}

//- (void)dealloc {
//    [self disconnectDevice];
//}

#pragma mark - è®¾å¤‡è¿æ¥å’ŒæŸ¥è¯¢

- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [_connectionLock lock];
    @try {
        [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
        
        if (!deviceUDID || deviceUDID.length == 0) {
            [self logMessage:@"[ERR] Device UDID cannot be empty"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                                 description:@"Device UDID cannot be empty"];
            }
            return NO;
        }
        
        // å¦‚æœå·²ç»è¿æ¥åˆ°åŒä¸€è®¾å¤‡ï¼Œæ£€æŸ¥è¿æ¥çŠ¶æ€
        if ([_deviceUDID isEqualToString:deviceUDID] && [self isConnectedInternal]) {
            [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@ (MobileSync: %@, AFC: %@)",
                             deviceUDID,
                             _mobilesync ? @"Yes" : @"No",
                             _afc ? @"Yes" : @"No"]];
            return YES;
        }
        
        // å®‰å…¨åœ°æ–­å¼€ç°æœ‰è¿æ¥
        if (_device || _lockdown || _mobilesync || _afc) {
            [self logMessage:@"[WAR] Disconnecting existing connection before reconnecting"];
            [self disconnectDeviceInternal];
            // çŸ­æš‚ç­‰å¾…ç¡®ä¿æ¸…ç†å®Œæˆ
            [NSThread sleepForTimeInterval:0.2];
        }
        
        _deviceUDID = [deviceUDID copy];
        return [self connectToDeviceInternal:deviceUDID error:error];
        
    } @finally {
        [_connectionLock unlock];
    }
}

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. è¿æ¥è®¾å¤‡
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. åˆ›å»ºlockdownå®¢æˆ·ç«¯
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        // æ¸…ç†å·²åˆ›å»ºçš„è®¾å¤‡è¿æ¥
        if (_device) {
            idevice_free(_device);
            _device = NULL;
        }
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // 3. å¯åŠ¨mobilesyncæœåŠ¡ - æ·»åŠ æ›´è¯¦ç»†çš„é”™è¯¯å¤„ç†
    NSError *syncError = nil;
    if (![self startMobileSyncService:&syncError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] MobileSync service failed to start: %@", syncError.localizedDescription]];
        [self logMessage:@"Continuing without MobileSync - photo features will still work via AFC"];
        // ä¸è¦å› ä¸ºMobileSyncå¤±è´¥å°±å®Œå…¨å¤±è´¥ï¼Œå› ä¸ºAFCè¿˜å¯ä»¥å·¥ä½œ
        // æ¸…é™¤é”™è¯¯ä»¥ä¾¿ç»§ç»­
        if (error) *error = nil;
    } else {
        [self logMessage:@"MobileSync service started successfully"];
    }
    
    // ğŸ†• 4. å¯åŠ¨AFCæœåŠ¡ï¼ˆç”¨äºæ–‡ä»¶ä¼ è¾“ï¼‰
    NSError *afcError = nil;
    if (![self startAFCService:&afcError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] AFC service failed to start: %@", afcError.localizedDescription]];
        [self logMessage:@"[WAR] Photo features will be limited without AFC"];
        // AFCå¤±è´¥ä¹Ÿä¸å®Œå…¨å¤±è´¥ï¼Œå› ä¸ºMobileSyncè¿˜å¯ä»¥å·¥ä½œ
    } else {
        [self logMessage:@"AFC service started successfully"];
    }
    
    // ğŸ†• 5. å¯åŠ¨ç…§ç‰‡ä¸“ç”¨AFCæœåŠ¡
    NSError *photoAfcError = nil;
    if (![self startPhotoAFCService:&photoAfcError]) {
        [self logMessage:@"Photo AFC service not available, using regular AFC for photos"];
        // è¿™ä¸ªå¤±è´¥æ˜¯æ­£å¸¸çš„ï¼Œå¾ˆå¤šè®¾å¤‡æ²¡æœ‰ä¸“ç”¨çš„AFC2æœåŠ¡
    } else {
        [self logMessage:@"Photo AFC service started successfully"];
    }
    
    // åªè¦æœ‰AFCæˆ–MobileSyncå…¶ä¸­ä¹‹ä¸€æˆåŠŸï¼Œå°±è®¤ä¸ºè¿æ¥æˆåŠŸ
    BOOL hasWorkingService = (_mobilesync != NULL) || (_afc != NULL);
    
    if (hasWorkingService) {
        [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@ (MobileSync: %@, AFC: %@)",
                         deviceUDID,
                         _mobilesync ? @"Yes" : @"No",
                         _afc ? @"Yes" : @"No"]];
        [self setInternalStatus:SyncTaskStatusIdle];
        return YES;
    } else {
        [self logMessage:@"[ERR] Neither MobileSync nor AFC services are available"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                             description:@"Neither MobileSync nor AFC services could be started"];
        }
        // å®Œå…¨æ¸…ç†è¿æ¥
        [self disconnectDevice];
        return NO;
    }
}

// ğŸ†• å¯åŠ¨AFCæœåŠ¡
- (BOOL)startAFCService:(NSError **)error {
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to start AFC service: %d", ldret]];
        }
        return NO;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to create AFC client: %d", afc_err]];
        }
        return NO;
    }
    
    [self logMessage:@"AFC service started successfully"];
    return YES;
}

// ğŸ†• å¯åŠ¨ç…§ç‰‡ä¸“ç”¨AFCæœåŠ¡
- (BOOL)startPhotoAFCService:(NSError **)error {
    // å°è¯•å¯åŠ¨ç…§ç‰‡ä¸“ç”¨çš„AFCæœåŠ¡
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc2", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        // å¦‚æœæ²¡æœ‰afc2ï¼Œå°è¯•ä½¿ç”¨æ™®é€šçš„afc
        [self logMessage:@"AFC2 service not available, using regular AFC for photos"];
        _afc_photos = _afc; // ä½¿ç”¨åŒä¸€ä¸ªAFCå®¢æˆ·ç«¯
        return YES;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc_photos);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:@"Failed to create photo AFC client, using regular AFC"];
        _afc_photos = _afc; // å›é€€åˆ°æ™®é€šAFC
        return YES;
    }
    
    [self logMessage:@"Photo AFC service started successfully"];
    return YES;
}

- (BOOL)startMobileSyncService:(NSError **)error {
    [self logMessage:@"Starting MobileSync service..."];
    
    int maxRetries = 3;
    int retryDelay = 1; // å‡å°‘å»¶è¿Ÿæ—¶é—´
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        [self logMessage:[NSString stringWithFormat:@"MobileSync service start attempt %d: lockdownd_start_service returned %d",
                         attempt + 1, ldret]];
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            [self logMessage:[NSString stringWithFormat:@"MobileSync service descriptor created successfully (port: %d)", service->port]];
            
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            [self logMessage:[NSString stringWithFormat:@"mobilesync_client_new returned %d", err]];
            
            if (err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:@"MobileSync client created successfully"];
                return YES;  // æˆåŠŸ
            } else {
                [self logMessage:[NSString stringWithFormat:@"[ERR] MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"[ERR] Failed to start MobileSync service (attempt %d): ldret=%d, service=%p, port=%d",
                             attempt + 1, ldret, service, service ? service->port : 0]];
            
            if (service) {
                lockdownd_service_descriptor_free(service);
            }
        }
        
        // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Retrying MobileSync in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥
    NSString *errorDesc = [NSString stringWithFormat:@"Failed to create MobileSync client after %d attempts", maxRetries];
    [self logMessage:[NSString stringWithFormat:@"[ERR] %@", errorDesc]];
    
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
    }
    return NO;
}

- (void)disconnectDevice {
    [_connectionLock lock];
    @try {
        [self disconnectDeviceInternal];
        [self logMessage:@"Device disconnection completed"];
    } @finally {
        [_connectionLock unlock];
    }
}

// ğŸ†• å…³é—­AFCæœåŠ¡ - å¢å¼ºç‰ˆæœ¬ï¼Œç¡®ä¿å®‰å…¨æ¸…ç†
- (void)closeAFCServices {
    // æ¸…ç†ç…§ç‰‡ä¸“ç”¨AFCæœåŠ¡
    if (_afc_photos && _afc_photos != _afc) {
        @try {
            afc_client_free(_afc_photos);
            [self logMessage:@"Photo AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing photo AFC: %@", exception.reason]];
        }
        _afc_photos = NULL;
    }
    
    // æ¸…ç†æ™®é€šAFCæœåŠ¡
    if (_afc) {
        @try {
            afc_client_free(_afc);
            [self logMessage:@"AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing AFC: %@", exception.reason]];
        }
        _afc = NULL;
    }
    
    // å¦‚æœç…§ç‰‡AFCæŒ‡å‘æ™®é€šAFCï¼Œä¹Ÿæ¸…ç©º
    if (_afc_photos == _afc) {
        _afc_photos = NULL;
    }
}

- (BOOL)isConnected {
    [_connectionLock lock];
    @try {
        // åªè¦æœ‰è®¾å¤‡è¿æ¥å’Œlockdownï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªæœåŠ¡ï¼ˆMobileSyncæˆ–AFCï¼‰å¯ç”¨å°±è®¤ä¸ºå·²è¿æ¥
        BOOL connected = (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
        return connected;
    } @finally {
        [_connectionLock unlock];
    }
}

#pragma mark - ğŸ†• å†…éƒ¨è¿æ¥ç®¡ç†æ–¹æ³•

// ğŸ†• å†…éƒ¨è¿æ¥æ£€æŸ¥æ–¹æ³•ï¼ˆä¸ä½¿ç”¨é”ï¼‰
- (BOOL)isConnectedInternal {
    return (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
}

// ğŸ†• å†…éƒ¨æ–­å¼€è¿æ¥æ–¹æ³•ï¼ˆä¸ä½¿ç”¨é”ï¼‰
- (void)disconnectDeviceInternal {
    [self logMessage:@"Internal disconnecting device..."];
    
    // è®¾ç½®çŠ¶æ€ä¸ºç©ºé—²
    [self setInternalStatus:SyncTaskStatusIdle];
    
    // ğŸ†• å…³é—­AFCæœåŠ¡ - å®‰å…¨åœ°æ¸…ç†
    [self closeAFCServices];
    
    // æ¸…ç†MobileSyncè¿æ¥
    if (_mobilesync) {
        @try {
            mobilesync_finish(_mobilesync);
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception during mobilesync_finish: %@", exception.reason]];
        }
        
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [self logMessage:@"MobileSync client freed"];
    }
    
    // æ¸…ç†é€šçŸ¥ä»£ç†
    if (_np) {
        np_client_free(_np);
        _np = NULL;
        [self logMessage:@"Notification proxy freed"];
    }
    
    // æ¸…ç†lockdownè¿æ¥
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
        [self logMessage:@"Lockdown client freed"];
    }
    
    // æ¸…ç†è®¾å¤‡è¿æ¥
    if (_device) {
        idevice_free(_device);
        _device = NULL;
        [self logMessage:@"Device connection freed"];
    }
}

#pragma mark - ğŸ†• ç…§ç‰‡åº“è®¿é—®åŠŸèƒ½

- (BOOL)checkPhotoLibraryAccess:(NSError **)error {
    [self logMessage:@"Checking photo library access"];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Device not connected"];
        }
        return NO;
    }
    
    if (!_afc && !_afc_photos) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // æµ‹è¯•è®¿é—®DCIMç›®å½•
    afc_client_t afc_client = _afc_photos ?: _afc;
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, "/DCIM", &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        [self logMessage:@"Photo library access confirmed"];
        return YES;
    } else if (afc_err == AFC_E_READ_ERROR) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoLibraryLocked
                             description:@"Photo library is locked or access denied"];
        }
        return NO;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to access photo library: %d", afc_err]];
        }
        return NO;
    }
}

- (NSArray<PhotoInfo *> *)scanPhotoLibrary:(NSArray<NSString *> *)albumNames error:(NSError **)error {
    [self logMessage:@"Starting photo library scan"];
    
    if (![self checkPhotoLibraryAccess:error]) {
        return nil;
    }
    
    NSMutableArray<PhotoInfo *> *allPhotos = [NSMutableArray array];
    
    if (!albumNames || albumNames.count == 0) {
        // æ‰«ææ‰€æœ‰é»˜è®¤ç›®å½•
        NSArray *defaultPaths = @[@"/DCIM/100APPLE", @"/DCIM/101APPLE", @"/DCIM/102APPLE"];
        
        for (NSString *path in defaultPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    } else {
        // æ‰«ææŒ‡å®šç›¸å†Œ
        for (NSString *albumName in albumNames) {
            NSString *albumPath = [NSString stringWithFormat:@"/PhotoData/Albums/%@", albumName];
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:albumPath recursive:YES error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo library scan completed: %lu photos found", (unsigned long)allPhotos.count]];
    return [allPhotos copy];
}

- (void)scanPhotoLibraryAsync:(NSArray<NSString *> *)albumNames
                     progress:(PhotoScanProgressCallback)progressCallback
                   completion:(PhotoCompletionCallback)completion {
    
    dispatch_async(_photoQueue, ^{
        NSError *error = nil;
        NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:albumNames error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(photos, error);
            }
        });
    });
}

- (NSDictionary *)getPhotoLibraryStatistics:(NSError **)error {
    [self logMessage:@"Getting photo library statistics"];
    
    NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:nil error:error];
    if (!photos) {
        return nil;
    }
    
    NSUInteger photoCount = 0;
    NSUInteger videoCount = 0;
    NSUInteger livePhotoCount = 0;
    NSUInteger burstCount = 0;
    NSUInteger screenshotCount = 0;
    NSUInteger totalSize = 0;
    
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (PhotoInfo *photo in photos) {
        if (photo.isVideo) {
            videoCount++;
        } else {
            photoCount++;
        }
        
        if (photo.isLivePhoto) livePhotoCount++;
        if (photo.isBurst) burstCount++;
        if (photo.isScreenshot) screenshotCount++;
        
        totalSize += photo.fileSize;
        
        if (!oldestDate || [photo.dateCreated compare:oldestDate] == NSOrderedAscending) {
            oldestDate = photo.dateCreated;
        }
        if (!newestDate || [photo.dateCreated compare:newestDate] == NSOrderedDescending) {
            newestDate = photo.dateCreated;
        }
    }
    
    return @{
        @"totalItems": @(photos.count),
        @"photoCount": @(photoCount),
        @"videoCount": @(videoCount),
        @"livePhotoCount": @(livePhotoCount),
        @"burstCount": @(burstCount),
        @"screenshotCount": @(screenshotCount),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"averageFileSize": @(photos.count > 0 ? totalSize / photos.count : 0)
    };
}

- (BOOL)downloadPhoto:(PhotoInfo *)photoInfo
        toDestination:(NSString *)destinationPath
                error:(NSError **)error {
    
    if (!photoInfo || !destinationPath) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo info or destination path cannot be nil"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Downloading photo: %@", photoInfo.filename]];
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // æ„å»ºè®¾å¤‡ä¸Šçš„å®Œæ•´è·¯å¾„
    NSString *devicePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // æ‰“å¼€è®¾å¤‡ä¸Šçš„æ–‡ä»¶
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afc_client, [devicePath UTF8String], AFC_FOPEN_RDONLY, &handle);
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to open photo file: %d", afc_err]];
        }
        return NO;
    }
    
    // åˆ›å»ºæœ¬åœ°æ–‡ä»¶
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *destDir = [destinationPath stringByDeletingLastPathComponent];
    if (![fileManager fileExistsAtPath:destDir]) {
        [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    NSFileHandle *destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    if (!destFile) {
        [fileManager createFileAtPath:destinationPath contents:nil attributes:nil];
        destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    }
    
    if (!destFile) {
        afc_file_close(afc_client, handle);
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to create destination file"];
        }
        return NO;
    }
    
    // è¯»å–å¹¶å†™å…¥æ–‡ä»¶
    const uint32_t bufferSize = 65536; // 64KB buffer
    uint32_t bytesRead = 0;
    NSUInteger totalBytesRead = 0;
    
    do {
        char buffer[bufferSize];
        afc_err = afc_file_read(afc_client, handle, buffer, bufferSize, &bytesRead);
        
        if (afc_err == AFC_E_SUCCESS && bytesRead > 0) {
            NSData *data = [NSData dataWithBytes:buffer length:bytesRead];
            [destFile writeData:data];
            totalBytesRead += bytesRead;
            
            // æŠ¥å‘Šè¿›åº¦
            if (self.photoDownloadCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.photoDownloadCallback(photoInfo.filename, totalBytesRead, photoInfo.fileSize);
                });
            }
        }
    } while (afc_err == AFC_E_SUCCESS && bytesRead > 0);
    
    [destFile closeFile];
    afc_file_close(afc_client, handle);
    
    if (afc_err == AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Successfully downloaded photo: %@ (%lu bytes)",
                         photoInfo.filename, (unsigned long)totalBytesRead]];
        return YES;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to read photo data: %d", afc_err]];
        }
        return NO;
    }
}

- (void)downloadPhotos:(NSArray<PhotoInfo *> *)photos
      toDestinationDir:(NSString *)destinationDir
              progress:(PhotoDownloadProgressCallback)progressCallback
            completion:(void (^)(NSUInteger successCount, NSUInteger failedCount, NSError *error))completion {
    
    dispatch_async(_photoQueue, ^{
        NSUInteger successCount = 0;
        NSUInteger failedCount = 0;
        NSError *lastError = nil;
        
        for (NSUInteger i = 0; i < photos.count; i++) {
            if (self->_cancelRequested) {
                break;
            }
            
            PhotoInfo *photo = photos[i];
            NSString *destPath = [destinationDir stringByAppendingPathComponent:photo.filename];
            
            NSError *downloadError = nil;
            BOOL success = [self downloadPhoto:photo toDestination:destPath error:&downloadError];
            
            if (success) {
                successCount++;
            } else {
                failedCount++;
                lastError = downloadError;
            }
            
            // æŠ¥å‘Šæ€»ä½“è¿›åº¦
            if (progressCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    progressCallback(photo.filename, i + 1, photos.count);
                });
            }
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(successCount, failedCount, lastError);
            }
        });
    });
}

#pragma mark - ğŸ†• ç…§ç‰‡æ‰«æå’Œå¤„ç†å®ç°

- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error {
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return @[];
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Failed to read directory %@: %d", directory, afc_err]];
        return @[];
    }
    
    NSMutableArray<PhotoInfo *> *photos = [NSMutableArray array];
    
    if (dir_list) {
        for (int i = 0; dir_list[i] != NULL; i++) {
            NSString *filename = [NSString stringWithUTF8String:dir_list[i]];
            
            // è·³è¿‡éšè—æ–‡ä»¶å’Œç›®å½•
            if ([filename hasPrefix:@"."]) continue;
            
            NSString *fullPath = [directory stringByAppendingPathComponent:filename];
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡æˆ–è§†é¢‘æ–‡ä»¶
            if ([self isPhotoFile:filename] || [self isVideoFile:filename]) {
                PhotoInfo *photoInfo = [self createPhotoInfoFromPath:fullPath
                                                           afcClient:afc_client
                                                               error:nil];
                if (photoInfo) {
                    [photos addObject:photoInfo];
                }
            } else if (recursive) {
                // é€’å½’æ‰«æå­ç›®å½•
                char **subdir_info = NULL;
                afc_err = afc_get_file_info(afc_client, [fullPath UTF8String], &subdir_info);
                
                if (afc_err == AFC_E_SUCCESS && subdir_info) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç›®å½•
                    for (int j = 0; subdir_info[j] != NULL; j += 2) {
                        if (strcmp(subdir_info[j], "st_ifmt") == 0) {
                            if (strcmp(subdir_info[j + 1], "S_IFDIR") == 0) {
                                NSArray<PhotoInfo *> *subdirPhotos = [self scanPhotosInDirectory:fullPath
                                                                                     recursive:recursive
                                                                                         error:nil];
                                if (subdirPhotos) {
                                    [photos addObjectsFromArray:subdirPhotos];
                                }
                            }
                            break;
                        }
                    }
                    afc_dictionary_free(subdir_info);
                }
            }
        }
        afc_dictionary_free(dir_list);
    }
    
    [self logMessage:[NSString stringWithFormat:@"Found %lu photos in directory: %@",
                     (unsigned long)photos.count, directory]];
    return [photos copy];
}

- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                             afcClient:(afc_client_t)afcClient
                                 error:(NSError **)error {
    
    PhotoInfo *photoInfo = [[PhotoInfo alloc] init];
    photoInfo.filename = [photoPath lastPathComponent];
    photoInfo.format = [[self getFileExtension:photoInfo.filename] uppercaseString];
    photoInfo.isVideo = [self isVideoFile:photoInfo.filename];
    
    // è·å–æ–‡ä»¶ä¿¡æ¯
    char **file_info = NULL;
    afc_error_t afc_err = afc_get_file_info(afcClient, [photoPath UTF8String], &file_info);
    
    if (afc_err == AFC_E_SUCCESS && file_info) {
        for (int i = 0; file_info[i] != NULL; i += 2) {
            NSString *key = [NSString stringWithUTF8String:file_info[i]];
            NSString *value = [NSString stringWithUTF8String:file_info[i + 1]];
            
            if ([key isEqualToString:@"st_size"]) {
                // ä½¿ç”¨å®‰å…¨çš„è½¬æ¢æ–¹æ³•
                photoInfo.fileSize = [self unsignedLongLongValueFromString:value];
            } else if ([key isEqualToString:@"st_mtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateModified = [NSDate dateWithTimeIntervalSince1970:timestamp];
            } else if ([key isEqualToString:@"st_birthtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateCreated = [NSDate dateWithTimeIntervalSince1970:timestamp];
            }
        }
        afc_dictionary_free(file_info);
    } else {
        [self logMessage:[NSString stringWithFormat:@"Failed to get file info for %@: %d", photoPath, afc_err]];
    }
    
    // è®¾ç½®é»˜è®¤å€¼
    if (!photoInfo.dateCreated) {
        photoInfo.dateCreated = photoInfo.dateModified ?: [NSDate date];
    }
    if (!photoInfo.dateModified) {
        photoInfo.dateModified = photoInfo.dateCreated;
    }
    
    // ç”Ÿæˆå”¯ä¸€ID
    photoInfo.photoID = [NSString stringWithFormat:@"%@_%lu",
                        [[photoInfo.filename stringByDeletingPathExtension]
                         stringByReplacingOccurrencesOfString:@" " withString:@"_"],
                        (unsigned long)[photoInfo.dateCreated timeIntervalSince1970]];
    
    // æ£€æµ‹ç‰¹æ®Šç±»å‹
    NSString *lowercaseFilename = [photoInfo.filename lowercaseString];
    photoInfo.isLivePhoto = [lowercaseFilename containsString:@"live"];
    photoInfo.isBurst = [lowercaseFilename containsString:@"burst"];
    photoInfo.isScreenshot = [lowercaseFilename hasPrefix:@"img_"] && [lowercaseFilename containsString:@"screenshot"];
    
    // å°è¯•æå–EXIFæ•°æ®ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    if (!photoInfo.isVideo) {
        photoInfo.exifData = [self extractEXIFFromPath:photoPath afcClient:afcClient];
        
        // ä»EXIFæå–å°ºå¯¸ä¿¡æ¯
        if (photoInfo.exifData) {
            NSNumber *width = photoInfo.exifData[@"PixelXDimension"];
            NSNumber *height = photoInfo.exifData[@"PixelYDimension"];
            if (width && height) {
                photoInfo.width = [width unsignedIntegerValue];
                photoInfo.height = [height unsignedIntegerValue];
            }
        }
    }
    
    return photoInfo;
}

- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath afcClient:(afc_client_t)afcClient {
    // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„EXIFæå–å®ç°
    // åœ¨çœŸå®å®ç°ä¸­ï¼Œä½ éœ€è¦ä¸€ä¸ªå®Œæ•´çš„EXIFè§£æåº“
    
    // è¯»å–æ–‡ä»¶çš„å‰å‡ ä¸ªå­—èŠ‚æ¥æ£€æµ‹æ ¼å¼å’ŒåŸºæœ¬ä¿¡æ¯
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afcClient, [photoPath UTF8String], AFC_FOPEN_RDONLY, &handle);
    
    if (afc_err != AFC_E_SUCCESS) {
        return nil;
    }
    
    char header[1024];
    uint32_t bytesRead = 0;
    afc_err = afc_file_read(afcClient, handle, header, sizeof(header), &bytesRead);
    afc_file_close(afcClient, handle);
    
    if (afc_err != AFC_E_SUCCESS || bytesRead < 10) {
        return nil;
    }
    
    NSMutableDictionary *exifData = [NSMutableDictionary dictionary];
    
    // æ£€æµ‹JPEGæ ¼å¼
    if (bytesRead >= 2 && header[0] == (char)0xFF && header[1] == (char)0xD8) {
        exifData[@"Format"] = @"JPEG";
        // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„EXIFè§£æé€»è¾‘
    }
    // æ£€æµ‹HEIFæ ¼å¼
    else if (bytesRead >= 8 && strncmp(&header[4], "ftyp", 4) == 0) {
        exifData[@"Format"] = @"HEIF";
    }
    // æ£€æµ‹PNGæ ¼å¼
    else if (bytesRead >= 8 && strncmp(header, "\x89PNG\r\n\x1a\n", 8) == 0) {
        exifData[@"Format"] = @"PNG";
    }
    
    // æ·»åŠ åŸºæœ¬ä¿¡æ¯
    exifData[@"FileSize"] = @(photoPath.length);
    exifData[@"ExtractedAt"] = [NSDate date];
    
    return [exifData copy];
}

- (BOOL)isPhotoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedPhotoFormats() containsObject:extension];
}

- (BOOL)isVideoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedVideoFormats() containsObject:extension];
}

- (NSString *)getFileExtension:(NSString *)filename {
    return [[filename pathExtension] uppercaseString];
}

#pragma mark - æ•°æ®æŸ¥è¯¢å¢å¼º

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡/åª’ä½“ç±»å‹
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self processPhotoDataForType:dataType error:error];
    }
    
    // æ£€æŸ¥ç¼“å­˜
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // ä½¿ç”¨çœŸå®çš„æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // ç¼“å­˜ç»“æœ
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - ğŸ†• ç…§ç‰‡æ•°æ®å¤„ç†æ–¹æ³•

- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Processing photo data for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // æ£€æŸ¥ç…§ç‰‡ç¼“å­˜
    NSString *cacheKey = [NSString stringWithFormat:@"photo_datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _photoCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached photo items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    // æ ¹æ®æ•°æ®ç±»å‹ç¡®å®šæ‰«æè·¯å¾„
    NSString *scanPath = PhotoTypeToPathMap()[@(dataType)];
    if (!scanPath) {
        scanPath = @"/DCIM"; // é»˜è®¤è·¯å¾„
    }
    
    // æ‰«æç…§ç‰‡
    NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:scanPath recursive:YES error:error];
    if (!photos) {
        return @[];
    }
    
    // æ ¹æ®æ•°æ®ç±»å‹è¿‡æ»¤ç…§ç‰‡
    NSPredicate *filter = [self createFilterPredicateForDataType:dataType];
    if (filter) {
        photos = [photos filteredArrayUsingPredicate:filter];
    }
    
    // è½¬æ¢ä¸ºSyncDataItem
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    for (PhotoInfo *photo in photos) {
        SyncDataItem *item = [self createSyncItemFromPhotoInfo:photo dataType:dataType];
        if (item) {
            [items addObject:item];
        }
    }
    
    // ç¼“å­˜ç»“æœ
    _photoCache[cacheKey] = items;
    
    [self logMessage:[NSString stringWithFormat:@"Processed %lu photo items for type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return [items copy];
}

- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypePhotos:
            return [NSPredicate predicateWithFormat:@"isVideo == NO"];
        case BackupDataTypeVideos:
            return [NSPredicate predicateWithFormat:@"isVideo == YES"];
        case BackupDataTypeScreenshots:
            return [NSPredicate predicateWithFormat:@"isScreenshot == YES"];
        case BackupDataTypeLivePhotos:
            return [NSPredicate predicateWithFormat:@"isLivePhoto == YES"];
        case BackupDataTypeBurstPhotos:
            return [NSPredicate predicateWithFormat:@"isBurst == YES"];
        default:
            return nil; // æ— è¿‡æ»¤å™¨ï¼Œè¿”å›æ‰€æœ‰ç…§ç‰‡
    }
}

- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    
    item.identifier = photoInfo.photoID;
    item.name = photoInfo.filename;
    item.dataType = dataType;
    item.modificationDate = photoInfo.dateModified;
    item.recordCount = 1;
    item.dataSize = photoInfo.fileSize;
    item.isSelected = NO;
    item.isMediaFile = YES;
    item.photoInfo = photoInfo;
    
    // è®¾ç½®è¿œç¨‹è·¯å¾„
    item.remotePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // åˆ›å»ºå…ƒæ•°æ®
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    metadata[@"isPhoto"] = @(!photoInfo.isVideo);
    metadata[@"isVideo"] = @(photoInfo.isVideo);
    metadata[@"format"] = photoInfo.format ?: @"Unknown";
    metadata[@"fileSize"] = @(photoInfo.fileSize);
    metadata[@"formattedSize"] = [self formatFileSize:photoInfo.fileSize];
    
    if (photoInfo.width > 0 && photoInfo.height > 0) {
        metadata[@"dimensions"] = [NSString stringWithFormat:@"%lux%lu",
                                  (unsigned long)photoInfo.width, (unsigned long)photoInfo.height];
        metadata[@"width"] = @(photoInfo.width);
        metadata[@"height"] = @(photoInfo.height);
        metadata[@"megapixels"] = @((photoInfo.width * photoInfo.height) / 1000000.0);
    }
    
    if (photoInfo.isVideo && photoInfo.videoDuration > 0) {
        metadata[@"duration"] = @(photoInfo.videoDuration);
        metadata[@"formattedDuration"] = [self formatDuration:photoInfo.videoDuration];
    }
    
    if (photoInfo.isLivePhoto) metadata[@"isLivePhoto"] = @YES;
    if (photoInfo.isBurst) metadata[@"isBurst"] = @YES;
    if (photoInfo.isScreenshot) metadata[@"isScreenshot"] = @YES;
    if (photoInfo.isFavorite) metadata[@"isFavorite"] = @YES;
    
    item.metadata = [metadata copy];
    
    return item;
}

- (NSString *)formatDuration:(NSTimeInterval)duration {
    NSInteger hours = (NSInteger)duration / 3600;
    NSInteger minutes = ((NSInteger)duration % 3600) / 60;
    NSInteger seconds = (NSInteger)duration % 60;
    
    if (hours > 0) {
        return [NSString stringWithFormat:@"%ld:%02ld:%02ld", (long)hours, (long)minutes, (long)seconds];
    } else {
        return [NSString stringWithFormat:@"%ld:%02ld", (long)minutes, (long)seconds];
    }
}

#pragma mark - è·å–æ”¯æŒçš„æ•°æ®ç±»å‹

- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    [self logMessage:@"Getting supported data types with enhanced stability (including photos)"];
    
    if (![self isConnected]) {
        [self logMessage:@"[ERR] Device not connected"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // âœ… ä½¿ç”¨ç¼“å­˜æœºåˆ¶é¿å…é‡å¤æ£€æµ‹
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ5åˆ†é’Ÿå†…ä¸”åŒä¸€è®¾å¤‡ï¼‰
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                         (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // ğŸ“Š å¼€å§‹æ£€æµ‹æ”¯æŒçš„æ•°æ®ç±»å‹
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    [self logMessage:[NSString stringWithFormat:@"Checking %lu data types for support...", (unsigned long)totalCount]];
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        BOOL isSupported = NO;
        
        // ğŸ†• ç…§ç‰‡ç±»å‹ä½¿ç”¨AFCæ£€æŸ¥ï¼Œå…¶ä»–ç±»å‹ä½¿ç”¨MobileSyncæ£€æŸ¥
        if ([BackupOptionTask isPhotoMediaType:dataType]) {
            // ç…§ç‰‡ç±»å‹ï¼šæ£€æŸ¥AFCè®¿é—®èƒ½åŠ›
            if (_afc || _afc_photos) {
                NSString *testPath = PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM";
                isSupported = [self canAccessPhotoDirectory:testPath error:nil];
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ test (path: %@): %@",
                                 typeName, testPath, isSupported ? @"âœ… Supported" : @"âŒ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ skipped: AFC not available", typeName]];
                isSupported = NO;
            }
        } else {
            // éç…§ç‰‡ç±»å‹ï¼šä½¿ç”¨MobileSyncæ£€æŸ¥ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (_mobilesync) {
                isSupported = [self isDataTypeSupportedStable:dataType];
                [self logMessage:[NSString stringWithFormat:@"Data type %@ test: %@",
                                 typeName, isSupported ? @"âœ… Supported" : @"âŒ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Data type %@ skipped: MobileSync not available", typeName]];
                isSupported = NO;
            }
        }
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
        }
        
        // æ·»åŠ å°å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        if (typeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.05];  // å‡å°‘å»¶è¿Ÿæ—¶é—´
        }
    }
    
    // æ›´æ–°ç¼“å­˜
    if (successCount > 0) {
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cacheTime = [NSDate date];
        
        [self logMessage:[NSString stringWithFormat:@"Detection complete: %lu/%lu data types supported (cached for 5 minutes)",
                         (unsigned long)successCount, (unsigned long)totalCount]];
    } else {
        [self logMessage:@"[WAR] No data types detected as supported"];
    }
    
    return supportedTypes;
}

// ğŸ†• æ£€æŸ¥ç…§ç‰‡ç›®å½•è®¿é—®èƒ½åŠ›
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error {
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        return NO;
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        return YES;
    }
    
    return NO;
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    // ğŸ†• ç…§ç‰‡ç±»å‹ä½¿ç”¨AFCæ£€æŸ¥
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self canAccessPhotoDirectory:PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM" error:nil];
    }
    
    @try {
        // ä½¿ç”¨æ­£ç¡®çš„APIåˆ›å»ºanchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // å‡†å¤‡æ­£ç¡®çš„å‚æ•°
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // æ­£ç¡®è°ƒç”¨mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // å¦‚æœæˆåŠŸå¯åŠ¨ï¼Œéœ€è¦ç»“æŸä¼šè¯
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

// âœ… æ–°å¢ï¼šç¨³å®šçš„æ•°æ®ç±»å‹æ£€æµ‹æ–¹æ³•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    // âœ… æ·»åŠ è¿æ¥æ£€æŸ¥
    if (!_mobilesync) {
        [self logMessage:@"MobileSyncæœªè¿æ¥ï¼Œè·³è¿‡æ£€æµ‹"];
        return NO;
    }
    
    @try {
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // âœ… é‡è¦ï¼šç«‹å³ç»“æŸä¼šè¯ï¼Œé¿å…çŠ¶æ€æ®‹ç•™
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // âœ… æ¯æ¬¡æ£€æµ‹åä¼‘æ¯ï¼Œé¿å…è®¾å¤‡è¿‡è½½
        [NSThread sleepForTimeInterval:0.2];
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"æ£€æµ‹å¼‚å¸¸: %@", exception.reason]];
        return NO;
    }
}

// âœ… æ–°å¢ï¼šç¡®ä¿ç¨³å®šè¿æ¥æ–¹æ³•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ä½†é¿å…è¿‡åº¦é‡è¿ï¼‰
- (BOOL)ensureStableConnection:(NSError **)error {
    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            [self logMessage:@"[ERR] No device UDID for reconnection"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // âœ… ç®€åŒ–è¿æ¥è´¨é‡æ£€æŸ¥ï¼Œé¿å…ä¸å¿…è¦çš„é‡è¿
    if (_lockdown) {
        // åªåšç®€å•çš„è¿æ¥æµ‹è¯•ï¼Œä¸è¦è¿‡åº¦æ£€æŸ¥
        [self logMessage:@"Connection appears stable"];
        return YES;
    }
    
    [self logMessage:@"[WAR] Connection quality check failed, but not attempting risky reconnection"];
    return YES; // è¿”å›YESé¿å…è§¦å‘é‡è¿å¾ªç¯
}

#pragma mark - æ‰«æè®¾å¤‡æ•°æ®å¢å¼ºç‰ˆ

- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== ğŸ”§ å¼€å§‹å¢å¼ºç‰ˆè®¾å¤‡çœŸå®æ•°æ®æ‰«æï¼ˆåŒ…å«ç…§ç‰‡ï¼‰===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // âœ… é¦–å…ˆè·å–æ”¯æŒçš„æ•°æ®ç±»å‹
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"[WAR] è·å–æ”¯æŒçš„æ•°æ®ç±»å‹å¤±è´¥: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"[WAR] è®¾å¤‡ä¸æ”¯æŒä»»ä½•æ•°æ®ç±»å‹çš„é€‰æ‹©æ€§åŒæ­¥");
        return @{};
    }
    
    NSLog(@"è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // é€ä¸ªå¤„ç†æ”¯æŒçš„æ•°æ®ç±»å‹
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // åªå¤„ç†è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹
        if (!(supportedTypes & dataType)) {
            NSLog(@"è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: %@", typeName);
            continue;
        }
        
        NSLog(@"æ­£åœ¨è·å– %@ çš„çœŸå®æ•°æ®...", typeName);
        
        // âœ… ä½¿ç”¨æ”¹è¿›çš„æ•°æ®è·å–æ–¹æ³•
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"%@ æ”¯æŒä½†æ— æ•°æ®: %@ é¡¹", typeName, itemCount);
            } else {
                NSLog(@"%@ è·å–æˆåŠŸ: %@ é¡¹", typeName, itemCount);
            }
        } else {
            NSLog(@"[WAR] %@ è·å–å¤±è´¥æˆ–æ— å“åº”", typeName);
        }
        
        // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== ğŸ”§ å¢å¼ºç‰ˆæ•°æ®æ‰«æå®Œæˆï¼Œå…±å¤„ç† %lu ç§æ•°æ®ç±»å‹ï¼ˆåŒ…å«ç…§ç‰‡ï¼‰===",
          (unsigned long)realData.count);
    return [realData copy];
}

// âœ… å¢å¼ºçš„æ•°æ®è·å–æ–¹æ³•
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"å¢å¼ºæ–¹æ³•è·å– %@ çš„çœŸå®æ•°æ®", typeName);
    
    // âœ… è¿æ¥çŠ¶æ€æ£€æŸ¥
    if (![self isConnected]) {
        NSLog(@"[WAR] è®¾å¤‡æœªè¿æ¥ï¼Œæ— æ³•è·å– %@ æ•°æ®", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // ğŸ†• æ ¹æ®æ•°æ®ç±»å‹é€‰æ‹©è·å–æ–¹æ³•
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        // ç…§ç‰‡ç±»å‹ï¼šä½¿ç”¨AFCæ–¹æ³•
        items = [self processPhotoDataForType:dataType error:&error];
    } else {
        // éç…§ç‰‡ç±»å‹ï¼šä½¿ç”¨MobileSyncæ–¹æ³•
        int maxAttempts = 3;
        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            if (attempt > 0) {
                NSLog(@"é‡è¯•è·å– %@ æ•°æ® (ç¬¬ %d æ¬¡å°è¯•)", typeName, attempt + 1);
                [NSThread sleepForTimeInterval:0.5];
            }
            
            items = [self getDataItemsForType:dataType error:&error];
            
            if (items && items.count > 0) {
                NSLog(@"ç¬¬ %d æ¬¡å°è¯•æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                      attempt + 1, typeName, (unsigned long)items.count);
                break;
            }
            
            if (error) {
                NSLog(@"[WAR] ç¬¬ %d æ¬¡å°è¯•è·å– %@ æ•°æ®å¤±è´¥: %@",
                      attempt + 1, typeName, error.localizedDescription);
                error = nil; // æ¸…é™¤é”™è¯¯ä»¥ä¾¿ä¸‹æ¬¡å°è¯•
            }
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"[WAR] %@ æœ€ç»ˆæ— æ³•è·å–åˆ°æ•°æ®", typeName);
    return nil;
}

// âœ… æ–°å¢ï¼šæ”¹è¿›çš„æ•°æ®å¤„ç†æ–¹æ³•ï¼Œæ›´å¥½åœ°å¤„ç†ç©ºæ•°æ®æƒ…å†µ
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"%@ æ•°æ®ä¸ºç©ºï¼Œåˆ›å»ºç©ºæ•°æ®å­—å…¸", typeName]];
        
        // âœ… å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿåˆ›å»ºä¸€ä¸ªæœ‰æ•ˆçš„å­—å…¸
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ æ”¯æŒä½†å½“å‰æ— æ•°æ®", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

#pragma mark - ğŸ†• æ•°æ®ç±»å‹å·¥å…·æ–¹æ³•å¢å¼º

+ (BOOL)isPhotoMediaType:(BackupDataType)dataType {
    BackupDataType photoTypes = (BackupDataTypePhotos | BackupDataTypeVideos | BackupDataTypeCameraRoll |
                                BackupDataTypePhotoAlbums | BackupDataTypePhotoStream | BackupDataTypeScreenshots |
                                BackupDataTypeSlowMotion | BackupDataTypeTimelapses | BackupDataTypeBurstPhotos |
                                BackupDataTypeLivePhotos);
    return (dataType & photoTypes) != 0;
}

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeMailAccounts:
            return @"MailAccounts";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
            
        // ğŸ†• ç…§ç‰‡å’Œåª’ä½“ç±»å‹
        case BackupDataTypePhotos:
            return @"Photos";
        case BackupDataTypeVideos:
            return @"Videos";
        case BackupDataTypeCameraRoll:
            return @"Camera Roll";
        case BackupDataTypePhotoAlbums:
            return @"Photo Albums";
        case BackupDataTypePhotoStream:
            return @"Photo Stream";
        case BackupDataTypeScreenshots:
            return @"Screenshots";
        case BackupDataTypeSlowMotion:
            return @"Slow Motion";
        case BackupDataTypeTimelapses:
            return @"Time-lapses";
        case BackupDataTypeBurstPhotos:
            return @"Burst Photos";
        case BackupDataTypeLivePhotos:
            return @"Live Photos";
            
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æœ¬åœ°åŒ–æ”¯æŒ
    // ç›®å‰è¿”å›è‹±æ–‡ç‰ˆæœ¬
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeMailAccounts) [array addObject:@(BackupDataTypeMailAccounts)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    // ğŸ†• ç…§ç‰‡å’Œåª’ä½“ç±»å‹
    if (dataTypes & BackupDataTypePhotos) [array addObject:@(BackupDataTypePhotos)];
    if (dataTypes & BackupDataTypeVideos) [array addObject:@(BackupDataTypeVideos)];
    if (dataTypes & BackupDataTypeCameraRoll) [array addObject:@(BackupDataTypeCameraRoll)];
    if (dataTypes & BackupDataTypePhotoAlbums) [array addObject:@(BackupDataTypePhotoAlbums)];
    if (dataTypes & BackupDataTypePhotoStream) [array addObject:@(BackupDataTypePhotoStream)];
    if (dataTypes & BackupDataTypeScreenshots) [array addObject:@(BackupDataTypeScreenshots)];
    if (dataTypes & BackupDataTypeSlowMotion) [array addObject:@(BackupDataTypeSlowMotion)];
    if (dataTypes & BackupDataTypeTimelapses) [array addObject:@(BackupDataTypeTimelapses)];
    if (dataTypes & BackupDataTypeBurstPhotos) [array addObject:@(BackupDataTypeBurstPhotos)];
    if (dataTypes & BackupDataTypeLivePhotos) [array addObject:@(BackupDataTypeLivePhotos)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        // åŸæœ‰æ•°æ®ç±»å‹
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper),
        
        // ğŸ†• æ–°å¢ç…§ç‰‡å’Œåª’ä½“ç±»å‹
        @(BackupDataTypePhotos),
        @(BackupDataTypeVideos),
        @(BackupDataTypeCameraRoll),
        @(BackupDataTypePhotoAlbums),
        @(BackupDataTypePhotoStream),
        @(BackupDataTypeScreenshots),
        @(BackupDataTypeSlowMotion),
        @(BackupDataTypeTimelapses),
        @(BackupDataTypeBurstPhotos),
        @(BackupDataTypeLivePhotos)
    ];
}

#pragma mark - é€‰æ‹©æ€§åŒæ­¥æ“ä½œ

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // å¼‚æ­¥æ‰§è¡ŒåŒæ­¥æ“ä½œ
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // åˆ†è§£æ•°æ®ç±»å‹ä¸ºå•ç‹¬çš„ç±»å‹
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // æŒ‰æ•°æ®ç±»å‹åˆ†ç»„
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // å¯¹æ¯ç§æ•°æ®ç±»å‹æ‰§è¡ŒåŒæ­¥
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // è¿™é‡Œå¯ä»¥å®ç°æ›´ç»†ç²’åº¦çš„é¡¹ç›®åŒæ­¥é€»è¾‘
        // ç›®å‰å…ˆä½¿ç”¨æ•°æ®ç±»å‹çº§åˆ«çš„åŒæ­¥
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // åˆ›å»ºå¤‡ä»½ç›®å½•
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - æ“ä½œæ§åˆ¶

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - åŒæ­¥æ“ä½œå®ç°

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // æ ¹æ®æ–¹å‘æ‰§è¡Œä¸åŒçš„æ“ä½œ
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // åŒå‘åŒæ­¥æš‚æ—¶ä¸å®ç°
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡ç±»å‹ï¼Œä½¿ç”¨ä¸åŒçš„å¤‡ä»½æ–¹æ³•
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self backupPhotoDataType:dataType toPath:path error:error];
    }
    
    // è·å–æ•°æ®é¡¹
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // åˆ›å»ºæ•°æ®ç±»å‹ç›®å½•
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // ä¿å­˜æ•°æ®é¡¹ä¿¡æ¯
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // ä¿å­˜å¤‡ä»½å…ƒæ•°æ®
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡ç±»å‹ï¼Œä½¿ç”¨ä¸åŒçš„æ¢å¤æ–¹æ³•
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self restorePhotoDataType:dataType fromPath:path error:error];
    }
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - ğŸ†• ç…§ç‰‡ç‰¹å®šçš„å¤‡ä»½å’Œæ¢å¤æ–¹æ³•

- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up photo data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // è·å–ç…§ç‰‡æ•°æ®é¡¹
    NSArray<SyncDataItem *> *items = [self processPhotoDataForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // åˆ›å»ºæ•°æ®ç±»å‹ç›®å½•
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // åˆ›å»ºç…§ç‰‡å­ç›®å½•
    NSString *photosDir = [dataTypeDir stringByAppendingPathComponent:@"Media"];
    NSString *thumbnailsDir = [dataTypeDir stringByAppendingPathComponent:@"Thumbnails"];
    
    [fileManager createDirectoryAtPath:photosDir withIntermediateDirectories:YES attributes:nil error:nil];
    if (self.enableThumbnailGeneration) {
        [fileManager createDirectoryAtPath:thumbnailsDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    // ä¸‹è½½ç…§ç‰‡æ–‡ä»¶
    NSUInteger successCount = 0;
    NSUInteger totalCount = items.count;
    
    for (NSUInteger i = 0; i < items.count; i++) {
        if (_cancelRequested) {
            break;
        }
        
        SyncDataItem *item = items[i];
        if (!item.isMediaFile || !item.photoInfo) {
            continue;
        }
        
        // æ›´æ–°è¿›åº¦
        [self updateProgress:(i * 100.0 / totalCount)
                   operation:[NSString stringWithFormat:@"Downloading %@", item.photoInfo.filename]
                     current:i
                       total:totalCount];
        
        // ä¸‹è½½åŸå§‹æ–‡ä»¶
        NSString *destPath = [photosDir stringByAppendingPathComponent:item.photoInfo.filename];
        NSError *downloadError = nil;
        BOOL success = [self downloadPhoto:item.photoInfo toDestination:destPath error:&downloadError];
        
        if (success) {
            successCount++;
            item.localPath = destPath;
            
            // ç”Ÿæˆç¼©ç•¥å›¾
            if (self.enableThumbnailGeneration && !item.photoInfo.isVideo) {
                NSString *thumbnailPath = [self generateThumbnailPath:destPath];
                [self createThumbnail:destPath destinationPath:thumbnailPath maxSize:200];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"Failed to download %@: %@",
                             item.photoInfo.filename, downloadError.localizedDescription]];
        }
    }
    
    // ä¿å­˜ç…§ç‰‡é¡¹ä¿¡æ¯
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"isMediaFile": @(item.isMediaFile),
            @"localPath": item.localPath ?: @"",
            @"remotePath": item.remotePath ?: @"",
            @"metadata": item.metadata ?: @{},
            @"photoInfo": item.photoInfo ? @{
                @"filename": item.photoInfo.filename ?: @"",
                @"photoID": item.photoInfo.photoID ?: @"",
                @"format": item.photoInfo.format ?: @"",
                @"fileSize": @(item.photoInfo.fileSize),
                @"width": @(item.photoInfo.width),
                @"height": @(item.photoInfo.height),
                @"isVideo": @(item.photoInfo.isVideo),
                @"isLivePhoto": @(item.photoInfo.isLivePhoto),
                @"isBurst": @(item.photoInfo.isBurst),
                @"isScreenshot": @(item.photoInfo.isScreenshot),
                @"isFavorite": @(item.photoInfo.isFavorite),
                @"dateCreated": item.photoInfo.dateCreated ?: [NSDate date],
                @"dateModified": item.photoInfo.dateModified ?: [NSDate date]
            } : @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save photo items data"];
        }
        return NO;
    }
    
    // ä¿å­˜å¤‡ä»½å…ƒæ•°æ®
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"successCount": @(successCount),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown",
        @"photoTransferMode": @(self.photoTransferMode),
        @"includeThumbnails": @(self.enableThumbnailGeneration),
        @"preserveOriginalFormat": @(self.preserveOriginalFormat)
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu/%lu photos of type: %@",
                     (unsigned long)successCount, (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    
    return successCount > 0;
}

- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring photo data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Photo backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Photo backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo restore not yet implemented for %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // TODO: å®ç°ç…§ç‰‡ä¸Šä¼ åˆ°è®¾å¤‡çš„åŠŸèƒ½
    // è¿™éœ€è¦ä½¿ç”¨AFCå†™å…¥æ–‡ä»¶åˆ°è®¾å¤‡çš„/DCIMç›®å½•
    
    return YES;
}

#pragma mark - ä¾¿æ·æ–¹æ³•

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *mailAccountsPath = [_dataStoragePath stringByAppendingPathComponent:@"MailAccounts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeMailAccounts
                                     toDirectory:mailAccountsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupPhotos:(PhotoTransferMode)transferMode
               completion:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *photosPath = [_dataStoragePath stringByAppendingPathComponent:@"Photos"];
    
    // è®¾ç½®ä¼ è¾“æ¨¡å¼
    self.photoTransferMode = transferMode;
    
    // å¼€å§‹å¤‡ä»½
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypePhotos
                                     toDirectory:photosPath
                                           error:&error];
    
    if (completion) {
        // è·å–ç…§ç‰‡æ•°é‡
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypePhotos error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupCameraRoll:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *cameraRollPath = [_dataStoragePath stringByAppendingPathComponent:@"CameraRoll"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCameraRoll
                                     toDirectory:cameraRollPath
                                           error:&error];
    
    if (completion) {
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypeCameraRoll error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // è®¾ç½®å®Œæˆå›è°ƒæ¥æ•è·ç»“æœ
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - æ•°æ®éªŒè¯å’Œæ¢å¤

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // å°è¯•è¯»å–æ–‡ä»¶ä»¥éªŒè¯æ ¼å¼
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // å‚æ•°éªŒè¯
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // ç¡®ä¿æ˜¯ç›®å½•è€Œä¸æ˜¯æ–‡ä»¶
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // è·å–åŸºæœ¬ä¿¡æ¯ - æ·»åŠ é”™è¯¯å¤„ç†
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // è®¾ç½®é»˜è®¤å€¼
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // æ‰«ææ•°æ®ç±»å‹
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œé¿å…å†…å­˜ç´¯ç§¯
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // æ£€æŸ¥items.plistæ˜¯å¦å­˜åœ¨
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // å°è¯•è¯»å–itemsæ•°æ®
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // è®¡ç®—è¯¥æ•°æ®ç±»å‹çš„å¤§å°
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // è®¾ç½®æ±‡æ€»ä¿¡æ¯
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // æ·»åŠ å¤‡ä»½ç»Ÿè®¡ä¿¡æ¯
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - è°ƒè¯•å’Œè¯Šæ–­å·¥å…·

- (void)diagnoseDeviceSyncCapabilities {
    
    if (![self isConnected]) {
        [self logMessage:@"Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"âœ…" : @"âŒ";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    info[@"isPhotoMediaType"] = @([BackupOptionTask isPhotoMediaType:dataType]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount),
                @"isMediaFile": @(firstItem.isMediaFile)
            };
        }
    }
    
    return info;
}

- (void)diagnosePhotoLibraryAccess {
    [self logMessage:@"=== Photo Library Access Diagnosis ==="];
    
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Device not connected"];
        return;
    }
    
    // æ£€æŸ¥AFCæœåŠ¡
    if (!_afc) {
        [self logMessage:@"[WAR] AFC service not available"];
    } else {
        [self logMessage:@"AFC service available"];
    }
    
    if (!_afc_photos) {
        [self logMessage:@"[WAR] Photo AFC service not available, using regular AFC"];
    } else if (_afc_photos == _afc) {
        [self logMessage:@"Using regular AFC for photo access"];
    } else {
        [self logMessage:@"Dedicated photo AFC service available"];
    }
    
    // æµ‹è¯•DCIMç›®å½•è®¿é—®
    NSError *error = nil;
    BOOL hasAccess = [self checkPhotoLibraryAccess:&error];
    
    if (hasAccess) {
        [self logMessage:@"Photo library access confirmed"];
        
        // æ‰«æå„ä¸ªç…§ç‰‡ç›®å½•
        NSArray *testPaths = @[@"/DCIM", @"/DCIM/100APPLE", @"/PhotoData"];
        
        for (NSString *path in testPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            [self logMessage:[NSString stringWithFormat:@"%@: %lu items", path, (unsigned long)photos.count]];
        }
        
        // è·å–ç»Ÿè®¡ä¿¡æ¯
        NSDictionary *stats = [self getPhotoLibraryStatistics:nil];
        if (stats) {
            [self logMessage:[NSString stringWithFormat:@"Total photos: %@", stats[@"photoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total videos: %@", stats[@"videoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total size: %@", stats[@"formattedSize"]]];
        }
        
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] Photo library access failed: %@", error.localizedDescription]];
    }
    
    [self logMessage:@"=== Photo Library Diagnosis Complete ==="];
}

#pragma mark - çœŸå®æ•°æ®å¤„ç†æ–¹æ³•å®ç°

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¤„ç†éæ•°ç»„ç±»å‹çš„æƒ…å†µ
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ è¿”å›éæ•°ç»„æ•°æ®ï¼Œå¯èƒ½è¡¨ç¤ºç©ºæ•°æ®é›†", syncClass]];
        
        // å¦‚æœæ˜¯å¸ƒå°”ç±»å‹ï¼Œå¯èƒ½è¡¨ç¤ºåŒæ­¥çŠ¶æ€
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥çŠ¶æ€: %s",
                             syncClass, bool_val ? "æˆåŠŸ" : "å¤±è´¥"]];
        }
        
        return @[]; // è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯å¤±è´¥
    }
    
    // ç»§ç»­å¤„ç†æ•°ç»„æ•°æ®...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // æå–é€šç”¨å­—æ®µ
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // æ ¹æ®æ•°æ®ç±»å‹æå–ç‰¹å®šå­—æ®µ
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeMailAccounts:
            [self extractMailAccountSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // å¦‚æœæ²¡æœ‰æ ‡è¯†ç¬¦ï¼Œä½¿ç”¨ç´¢å¼•
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // å¦‚æœæ²¡æœ‰åç§°ï¼Œä½¿ç”¨é»˜è®¤åç§°
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // æå–è®°å½•ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // æå–ä¿®æ”¹æ—¶é—´
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // ä¼°ç®—æ•°æ®å¤§å°
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // é»˜è®¤å¤§å°
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å§“åå­—æ®µ
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // ç”µè¯å·ç 
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // é‚®ç®±åœ°å€
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æ—¥å†æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å¼€å§‹æ—¶é—´
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // ç»“æŸæ—¶é—´
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // ä¹¦ç­¾æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // è´¦æˆ·åç§°
    plist_t account_name = plist_dict_get_item(item_dict, "AccountName");
    if (!account_name) account_name = plist_dict_get_item(item_dict, "EmailAddress");
    
    if (account_name && plist_get_node_type(account_name) == PLIST_STRING) {
        char *name_str = NULL;
        plist_get_string_val(account_name, &name_str);
        if (name_str) {
            item.name = [NSString stringWithUTF8String:name_str];
            free(name_str);
        }
    }
    
    // æœåŠ¡å™¨ä¿¡æ¯
    plist_t hostname = plist_dict_get_item(item_dict, "Hostname");
    if (hostname && plist_get_node_type(hostname) == PLIST_STRING) {
        char *host_str = NULL;
        plist_get_string_val(hostname, &host_str);
        if (host_str) {
            metadata[@"hostname"] = [NSString stringWithUTF8String:host_str];
            free(host_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å¤‡å¿˜å½•æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å†…å®¹
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // å¤§æ¦‚ä¼°ç®—
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æé†’äº‹é¡¹æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å®ŒæˆçŠ¶æ€
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // ä¼˜å…ˆçº§
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å°è¯•å„ç§å¯èƒ½çš„åç§°å­—æ®µ
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // æ·»åŠ ä¸€äº›é€šç”¨å…ƒæ•°æ®
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

// getDataItemsSimplified æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"è·å–ç®€åŒ–æ•°æ®é¡¹ - ç±»å‹: %@, åŒæ­¥ç±»: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // éªŒè¯å‚æ•°
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"åŒæ­¥ç±»å‚æ•°ä¸èƒ½ä¸ºç©º"];
        }
        return @[];
    }
    
    // ç¡®ä¿è®¾å¤‡è¿æ¥
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"è®¾å¤‡æœªè¿æ¥"];
        }
        return @[];
    }
    
    // âœ… å…³é”®ä¿®å¤ï¼šç§»é™¤é‡å¤çš„æ”¯æŒæ£€æŸ¥
    // ä¸Šå±‚ä»£ç å·²ç»é€šè¿‡ getSupportedDataTypes éªŒè¯è¿‡æ”¯æŒæ€§ï¼Œé¿å…é‡å¤æ£€æŸ¥å¯¼è‡´çŠ¶æ€å†²çª
    [self logMessage:[NSString stringWithFormat:@"è·³è¿‡é‡å¤æ”¯æŒæ£€æŸ¥ï¼Œç›´æ¥è·å– %@ æ•°æ®", syncClass]];
    
    // ç›´æ¥è°ƒç”¨æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"%@ æ•°æ®ä¸ºç©ºæˆ–è·å–å¤±è´¥", syncClass]];
    }
    
    return items ?: @[];
}

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"ä½¿ç”¨ä¿®å¤ç‰ˆè·å– %@ æ•°æ®", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // æ·»åŠ è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // âœ… å…³é”®ä¿®å¤ï¼šæ¯æ¬¡æ•°æ®è·å–å‰éƒ½é‡æ–°å»ºç«‹ MobileSync è¿æ¥
        [self logMessage:@"é‡æ–°å»ºç«‹ MobileSync è¿æ¥ä»¥ç¡®ä¿æ•°æ®è·å–ç¨³å®šæ€§"];
        
        // å¼ºåˆ¶æ–­å¼€å¹¶é‡å»º MobileSync è¿æ¥
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // çŸ­æš‚ç­‰å¾…ï¼Œè®©è®¾å¤‡é‡ç½®çŠ¶æ€
        [NSThread sleepForTimeInterval:0.5];
        
        // é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡å¤±è´¥: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"MobileSync è¿æ¥å·²é‡æ–°å»ºç«‹"];
        
        // âœ… å…³é”®ä¿®å¤2ï¼šä½¿ç”¨ä¸æ£€æµ‹æ—¶ç›¸åŒçš„å‚æ•°
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"[ERR] åˆ›å»ºanchorså¤±è´¥"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // âœ… å…³é”®ä¿®å¤3ï¼šä½¿ç”¨æ£€æµ‹æ—¶å®Œå…¨ç›¸åŒçš„å‚æ•°
        uint64_t data_class_version = 106;  // ä¸æ£€æµ‹æ—¶ä¿æŒä¸€è‡´
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"ä½¿ç”¨å¹²å‡€è¿æ¥å¯åŠ¨åŒæ­¥ä¼šè¯: %@", syncClass]];
        
        // âœ… å…³é”®ä¿®å¤4ï¼šå¯åŠ¨åŒæ­¥ä¼šè¯
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥ä¼šè¯å¯åŠ¨æˆåŠŸï¼ˆå¹²å‡€è¿æ¥ï¼‰", syncClass]];
            
            // âœ… ä½¿ç”¨æ›´ç¨³å®šçš„æ•°æ®è·å–æ–¹æ³•
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"æˆåŠŸè¯·æ±‚ %@ çš„æ‰€æœ‰è®°å½•", syncClass]];
                
                // âœ… æ”¹è¿›çš„æ•°æ®æ¥æ”¶é€»è¾‘ - å¤„ç†è¶…æ—¶å’Œå¤šæ‰¹æ¬¡æ•°æ®
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // å‡å°‘æœ€å¤§æ‰¹æ¬¡æ•°é‡
                int timeoutCount = 0;
                int maxTimeouts = 2; // å…è®¸çš„æœ€å¤§è¶…æ—¶æ¬¡æ•°
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"mobilesync_receive_changes è¿”å›çŠ¶æ€: %d (æ‰¹æ¬¡ %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // é‡ç½®è¶…æ—¶è®¡æ•°å™¨
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"å¤„ç† %@ ç¬¬ %d æ‰¹æ•°æ®",
                                            syncClass, batchCount]];
                            
                            // ğŸ” è¯¦ç»†åˆ†ææ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"æ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // ğŸ”§ æ”¹è¿›çš„æ•°æ®å¤„ç†ï¼šæ”¯æŒå¤šç§æ•°æ®ç±»å‹
                            NSArray<SyncDataItem *> *batchItems = [self processRealDataForType:dataType
                                                                                     dataArray:entities
                                                                                     syncClass:syncClass];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"ä»ç¬¬ %d æ‰¹è·å–åˆ° %lu é¡¹æ•°æ®",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"ç¬¬ %d æ‰¹æ•°æ®ä¸ºç©ºæˆ–å¤„ç†å¤±è´¥", batchCount]];
                            }
                            
                            // æ¸…ç†resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"ç¬¬ %d æ‰¹ %@ è¿”å›ç©ºæ•°æ®", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // ğŸ”§ æ”¹è¿›çš„è¶…æ—¶å¤„ç†
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"%@ æ¥æ”¶è¶…æ—¶ (ç¬¬ %d æ¬¡ï¼Œå…± %d æ¬¡)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ è¶…æ—¶æ¬¡æ•°è¾¾åˆ°ä¸Šé™ï¼Œåœæ­¢æ¥æ”¶", syncClass]];
                            break;
                        }
                        
                        // å¦‚æœå·²ç»è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸çš„ç»“æŸä¿¡å·
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"%@ å·²è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸ç»“æŸ", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[ERR] æ¥æ”¶ %@ æ•°æ®æ—¶å‡ºé”™: %d",
                                        syncClass, receive_err]];
                        break;
                    }
                    
                    // é˜²æ­¢æ— é™å¾ªç¯
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ è¾¾åˆ°æœ€å¤§æ‰¹æ¬¡é™åˆ¶(%d)ï¼Œåœæ­¢æ¥æ”¶",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // å¦‚æœæ ‡è®°ä¸ºæœ€åä¸€æ¡è®°å½•ï¼Œç›´æ¥é€€å‡º
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"%@ æ¥æ”¶åˆ°æœ€åè®°å½•æ ‡è®°ï¼Œæ­£å¸¸ç»“æŸ", syncClass]];
                        break;
                    }
                    
                    // æ·»åŠ å°å»¶è¿Ÿï¼Œé¿å…è¿‡åº¦è¯·æ±‚
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // ä½¿ç”¨å†…éƒ¨é€»è¾‘æ§åˆ¶å¾ªç¯
                
                [self logMessage:[NSString stringWithFormat:@"%@ æ•°æ®æ¥æ”¶å®Œæˆ: %d æ‰¹æ¬¡, %lu é¡¹",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"[WAR] %@ get_all_recordså¤±è´¥: %d",
                                syncClass, get_all_err]];
            }
            
            // âœ… ç¡®ä¿ä¼šè¯æ­£ç¡®ç»“æŸ
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥ä¼šè¯å·²ç»“æŸ", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ mobilesync_startå¤±è´¥ï¼ˆå¹²å‡€è¿æ¥åï¼‰: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"é”™è¯¯è¯¦æƒ…: %s", error_description]];
            }
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // âœ… å³ä½¿æ²¡æœ‰è·å–åˆ°æ•°æ®ä¹Ÿä¸ç®—é”™è¯¯
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"%@ æ²¡æœ‰å¯ç”¨æ•°æ®ï¼ˆä½¿ç”¨å¹²å‡€è¿æ¥åç¡®è®¤ï¼‰", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"%@ æœ€ç»ˆè·å–åˆ° %lu é¡¹çœŸå®æ•°æ®ï¼ˆå¹²å‡€è¿æ¥ï¼‰",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ æ•°æ®è·å–å¼‚å¸¸: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}

#pragma mark - éªŒè¯å’Œé”™è¯¯å¤„ç†

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¢å¼ºçš„ç±»å‹æ£€æŸ¥å’Œæ—¥å¿—
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // å¦‚æœä¸æ˜¯æ•°ç»„ï¼Œå°è¯•å¤„ç†å…¶ä»–å¯èƒ½çš„ç±»å‹
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // å¯èƒ½è¡¨ç¤ºæ²¡æœ‰æ•°æ®æˆ–æ“ä½œå¤±è´¥
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // å¦‚æœæ˜¯trueï¼Œå¯èƒ½è¡¨ç¤ºæˆåŠŸä½†æ— æ•°æ®
        }
        
        [self logMessage:[NSString stringWithFormat:@"[WAR] Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // æ ¹æ®é”™è¯¯ç±»å‹é‡‡å–ä¸åŒçš„å¤„ç†ç­–ç•¥
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // å°è¯•é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æ”¯æŒæ­¤æ•°æ®ç±»å‹
    return [self isDataTypeSupported:dataType];
}

- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error {
    if (!photoPath || photoPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo path cannot be empty"];
        }
        return NO;
    }
    
    NSString *filename = [photoPath lastPathComponent];
    if (![self isPhotoFile:filename] && ![self isVideoFile:filename]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoFormatUnsupported
                             description:[NSString stringWithFormat:@"Unsupported file format: %@", filename]];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - ç§æœ‰æ–¹æ³•å®ç°

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
        case SyncTaskStatusScanningPhotos:
            return @"Scanning photos";
        case SyncTaskStatusDownloadingPhotos:
            return @"Downloading photos";
        case SyncTaskStatusProcessingMetadata:
            return @"Processing metadata";
        case SyncTaskStatusGeneratingThumbnails:
            return @"Generating thumbnails";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - å·¥å…·æ–¹æ³•

- (void)logMessage:(NSString *)message {
    NSString *logMessage = [NSString stringWithFormat:@"%@", message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}

- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}

- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}

- (NSString *)sanitizeFilename:(NSString *)filename {
    NSMutableString *sanitized = [filename mutableCopy];
    NSArray *invalidChars = @[@"/", @"\\", @":", @"*", @"?", @"\"", @"<", @">", @"|"];
    
    for (NSString *invalidChar in invalidChars) {
        [sanitized replaceOccurrencesOfString:invalidChar
                                   withString:@"_"
                                      options:NSLiteralSearch
                                        range:NSMakeRange(0, sanitized.length)];
    }
    
    return [sanitized copy];
}

- (NSString *)generateThumbnailPath:(NSString *)originalPath {
    NSString *directory = [[originalPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"Thumbnails"];
    NSString *filename = [originalPath lastPathComponent];
    NSString *nameWithoutExt = [filename stringByDeletingPathExtension];
    NSString *extension = [filename pathExtension];
    
    NSString *thumbnailFilename = [NSString stringWithFormat:@"%@_thumb.%@", nameWithoutExt, extension];
    return [directory stringByAppendingPathComponent:thumbnailFilename];
}

- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize {
    // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ç¼©ç•¥å›¾ç”Ÿæˆå®ç°
    // åœ¨çœŸå®åº”ç”¨ä¸­ï¼Œä½ éœ€è¦ä½¿ç”¨å›¾åƒå¤„ç†åº“ï¼ˆå¦‚CoreGraphicsã€ImageIOç­‰ï¼‰
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // åˆ›å»ºç›®å½•
    NSString *destDir = [destPath stringByDeletingLastPathComponent];
    [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    
    // ç®€å•çš„æ–‡ä»¶å¤åˆ¶ä½œä¸ºå ä½ç¬¦
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥è¿›è¡Œå›¾åƒç¼©æ”¾
    NSError *error = nil;
    BOOL success = [fileManager copyItemAtPath:sourcePath toPath:destPath error:&error];
    
    if (!success) {
        [self logMessage:[NSString stringWithFormat:@"Failed to create thumbnail: %@", error.localizedDescription]];
    }
    
    return success;
}

// ğŸ†• å®‰å…¨çš„å­—ç¬¦ä¸²è½¬æ— ç¬¦å·é•¿é•¿æ•´å‹æ–¹æ³•
- (unsigned long long)unsignedLongLongValueFromString:(NSString *)string {
    if (!string || string.length == 0) {
        return 0;
    }
    
    // æ–¹æ³•1: ä½¿ç”¨Cå‡½æ•°strtoullï¼ˆæ¨èï¼‰
    const char *cString = [string UTF8String];
    char *endPtr = NULL;
    unsigned long long result = strtoull(cString, &endPtr, 10);
    
    // å¦‚æœè½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
    if (endPtr == cString) {
        // æ–¹æ³•2: ä½¿ç”¨NSScannerä½œä¸ºå¤‡ç”¨
        NSScanner *scanner = [NSScanner scannerWithString:string];
        unsigned long long scannerResult = 0;
        if ([scanner scanUnsignedLongLong:&scannerResult]) {
            return scannerResult;
        }
        
        // æ–¹æ³•3: æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼Œä½¿ç”¨longLongValue
        long long signedValue = [string longLongValue];
        return (unsigned long long)MAX(0, signedValue);
    }
    
    return result;
}

- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"è®¾å¤‡æœªè¿æ¥æˆ–lockdownæœªåˆå§‹åŒ–"];
        return;
    }
    
    // ä¿®å¤1ï¼šæ­£ç¡®è·å–è®¾å¤‡åç§°
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"è®¾å¤‡åç§°: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"è·å–è®¾å¤‡åç§°å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤2ï¼šæ­£ç¡®è·å–iOSç‰ˆæœ¬
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"iOSç‰ˆæœ¬: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"[WAR] iOSç‰ˆæœ¬è¿‡ä½ï¼Œå¯èƒ½ä¸æ”¯æŒé€‰æ‹©æ€§åŒæ­¥"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"[WAR] iOS 15+è®¾å¤‡ï¼Œæ•°æ®æ ¼å¼å¯èƒ½æœ‰å˜åŒ–"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] iOS %ld è®¾å¤‡ï¼Œå…¼å®¹æ€§è‰¯å¥½", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] è·å–iOSç‰ˆæœ¬å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤3ï¼šæ­£ç¡®è·å–è®¾å¤‡å‹å·
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"è®¾å¤‡å‹å·: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"è·å–è®¾å¤‡å‹å·å¤±è´¥: %d", ret]];
    }
}

@end

-------------------------------

v2çš„ä»£ç ï¼š

//
//  BackupOptionTask.m
//  iOSBackupManager
//
//  Complete Enhanced Version with Photos/Camera Support - 2025.01.27
//  Based on libimobiledevice mobilesync and AFC APIs
//

#import "BackupOptionTask.h"
#import "DatalogsSettings.h"
#import <CommonCrypto/CommonCrypto.h>

// å¼•å…¥ libimobiledevice ç›¸å…³å¤´æ–‡ä»¶
#include <libimfccore/libimfccore.h>
#include <libimfccore/lockdown.h>
#include <libimfccore/mobilesync.h>
#include <libimfccore/notification_proxy.h>
#include <libimfccore/afc.h>
#include <plist/plist.h>
#include <stdio.h>
#include <sys/stat.h>

// å¸¸é‡å®šä¹‰
NSString * const kBackupOptionTaskErrorDomain = @"com.mfcbox.BackupOptionTaskErrorDomain";

// ğŸ†• ç…§ç‰‡ç›¸å…³å¸¸é‡
NSString * const kPhotoLibraryPath = @"/DCIM";
NSString * const kCameraRollPath = @"/DCIM/100APPLE";
NSString * const kPhotoStreamPath = @"/PhotoData";
NSString * const kThumbnailsPath = @"/PhotoData/Thumbnails";

// æ”¯æŒçš„ç…§ç‰‡æ ¼å¼
static NSArray *SupportedPhotoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEIF", @"HEIC", @"JPEG", @"JPG", @"PNG", @"GIF", @"TIFF", @"BMP"];
    });
    return formats;
}

// æ”¯æŒçš„è§†é¢‘æ ¼å¼
static NSArray *SupportedVideoFormats() {
    static NSArray *formats = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        formats = @[@"HEVC", @"H264", @"MP4", @"MOV", @"M4V", @"3GP"];
    });
    return formats;
}

// åŸºäºå®é™…iOSåŒæ­¥ç±»çš„æ•°æ®ç±»å‹æ˜ å°„ - å®Œæ•´ç‰ˆæœ¬
static NSDictionary *DataTypeToSyncClassMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            // åŸæœ‰çš„åŒæ­¥ç±»
            @(BackupDataTypeContacts): @"com.apple.Contacts",
            @(BackupDataTypeCalendars): @"com.apple.Calendars",
            @(BackupDataTypeBookmarks): @"com.apple.Bookmarks",
            @(BackupDataTypeMailAccounts): @"com.apple.MailAccounts",
            @(BackupDataTypeNotes): @"com.apple.Notes",
            @(BackupDataTypeReminders): @"com.apple.Reminders",
            @(BackupDataTypeApplications): @"com.apple.MobileApplication",
            @(BackupDataTypeConfiguration): @"com.apple.SystemConfiguration",
            @(BackupDataTypeKeychain): @"com.apple.Keychain",
            @(BackupDataTypeVoiceMemos): @"com.apple.VoiceMemos",
            @(BackupDataTypeWallpaper): @"com.apple.Wallpaper",
            
            // ğŸ†• ç…§ç‰‡å’Œåª’ä½“ç›¸å…³çš„åŒæ­¥ç±»
            @(BackupDataTypePhotos): @"com.apple.Photos",
            @(BackupDataTypeVideos): @"com.apple.MediaAssets",
            @(BackupDataTypeCameraRoll): @"com.apple.CameraRoll",
            @(BackupDataTypePhotoAlbums): @"com.apple.PhotoAlbums",
            @(BackupDataTypePhotoStream): @"com.apple.PhotoStream",
            @(BackupDataTypeScreenshots): @"com.apple.Screenshots",
            @(BackupDataTypeSlowMotion): @"com.apple.SlowMotion",
            @(BackupDataTypeTimelapses): @"com.apple.Timelapses",
            @(BackupDataTypeBurstPhotos): @"com.apple.BurstPhotos",
            @(BackupDataTypeLivePhotos): @"com.apple.LivePhotos"
        };
    });
    return map;
}

// ğŸ†• ç…§ç‰‡è·¯å¾„æ˜ å°„
static NSDictionary *PhotoTypeToPathMap() {
    static NSDictionary *map = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        map = @{
            @(BackupDataTypePhotos): @"/DCIM",
            @(BackupDataTypeVideos): @"/DCIM",
            @(BackupDataTypeCameraRoll): @"/DCIM/100APPLE",
            @(BackupDataTypePhotoAlbums): @"/PhotoData/Albums",
            @(BackupDataTypePhotoStream): @"/PhotoData/PhotoStream",
            @(BackupDataTypeScreenshots): @"/DCIM/Screenshots",
            @(BackupDataTypeSlowMotion): @"/DCIM/SlowMotion",
            @(BackupDataTypeTimelapses): @"/DCIM/Timelapses",
            @(BackupDataTypeBurstPhotos): @"/DCIM/Bursts",
            @(BackupDataTypeLivePhotos): @"/DCIM/LivePhotos"
        };
    });
    return map;
}

// è·å–å·²çŸ¥çš„åŒæ­¥ç±»åˆ—è¡¨ - ç”¨äºæ£€æµ‹æ”¯æŒçš„æ•°æ®ç±»å‹
static NSArray *GetKnownSyncClasses() {
    static NSArray *classes = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        classes = @[
            @"com.apple.Contacts",
            @"com.apple.Calendars",
            @"com.apple.Bookmarks",
            @"com.apple.MailAccounts",
            @"com.apple.Notes",
            @"com.apple.Reminders",
            @"com.apple.MobileApplication"
        ];
    });
    return classes;
}

#pragma mark - PhotoInfo å®ç°

@implementation PhotoInfo

- (instancetype)init {
    self = [super init];
    if (self) {
        _isVideo = NO;
        _isLivePhoto = NO;
        _isBurst = NO;
        _isScreenshot = NO;
        _isFavorite = NO;
        _videoDuration = 0;
        _width = 0;
        _height = 0;
        _fileSize = 0;
    }
    return self;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<PhotoInfo: %@ (%@) - %lux%lu, %@ KB>",
            self.filename, self.format,
            (unsigned long)self.width, (unsigned long)self.height,
            @(self.fileSize / 1024)];
}

@end

#pragma mark - SyncDataItem å®Œæ•´å®ç°

@implementation SyncDataItem

- (instancetype)init {
    self = [super init];
    if (self) {
        _isSelected = NO;
        _recordCount = 1;
        _dataSize = 0;
        _modificationDate = [NSDate date];
        _isMediaFile = NO;
    }
    return self;
}

- (NSString *)description {
    if (self.isMediaFile && self.photoInfo) {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (Media: %@) - %@ records>",
                self.name, self.photoInfo.filename, @(self.recordCount)];
    } else {
        return [NSString stringWithFormat:@"<SyncDataItem: %@ (%@) - %@ records>",
                self.name, self.identifier, @(self.recordCount)];
    }
}

@end

#pragma mark - BackupOptionTask å†…éƒ¨æ¥å£

// åœ¨ç±»çš„å†…éƒ¨æ¥å£ä¸­æ·»åŠ çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—
@interface BackupOptionTask () {
    // libimobiledevice C API æŒ‡é’ˆ
    idevice_t _device;
    lockdownd_client_t _lockdown;
    mobilesync_client_t _mobilesync;
    afc_client_t _afc;
    np_client_t _np;
    
    // ğŸ†• AFC è¿æ¥ - ç”¨äºæ–‡ä»¶ä¼ è¾“
    afc_client_t _afc_photos;  // ä¸“ç”¨äºç…§ç‰‡ä¼ è¾“çš„AFCè¿æ¥
    
    // æ“ä½œçŠ¶æ€
    SyncTaskStatus _status;
    float _progress;
    NSError *_lastError;
    BOOL _isOperating;
    BOOL _isPaused;
    BOOL _cancelRequested;
    
    // åŒæ­¥ä¸Šä¸‹æ–‡
    dispatch_queue_t _operationQueue;
    dispatch_queue_t _photoQueue;  // ğŸ†• ä¸“ç”¨äºç…§ç‰‡æ“ä½œçš„é˜Ÿåˆ—
    dispatch_queue_t _connectionQueue;  // ğŸ†• ä¸“ç”¨äºè¿æ¥æ“ä½œçš„é˜Ÿåˆ—ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨
    NSMutableDictionary *_syncAnchors;
    NSMutableDictionary *_dataCache;
    NSMutableDictionary *_photoCache; // ğŸ†• ç…§ç‰‡ç¼“å­˜
    
    // å½“å‰æ“ä½œå‚æ•°
    BackupDataType _currentDataTypes;
    SyncDirection _currentDirection;
    NSString *_currentBackupPath;
    
    // å†…éƒ¨çŠ¶æ€
    NSDate *_lastSyncTime;
    NSUInteger _totalItemsToProcess;
    NSUInteger _processedItems;
    
    // ğŸ†• ç…§ç‰‡ç›¸å…³çŠ¶æ€
    NSUInteger _totalPhotosToProcess;
    NSUInteger _processedPhotos;
    NSUInteger _photoDownloadedBytes;
    NSUInteger _photoTotalBytes;
    
    // ğŸ†• çº¿ç¨‹å®‰å…¨æ ‡å¿—
    NSRecursiveLock *_connectionLock;
    
    // âœ… æ–°å¢ï¼šè¿æ¥èƒ½åŠ›çŠ¶æ€
    DeviceConnectionCapability _connectionCapability;
}

// ç§æœ‰æ–¹æ³•å£°æ˜
- (void)cleanupBasicConnection;
- (BOOL)validateServiceDependency:(BackupDataType)dataType error:(NSError **)error;


- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error;
- (BOOL)startMobileSyncService:(NSError **)error;
- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description;
- (void)setInternalStatus:(SyncTaskStatus)status;
- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total;
- (NSString *)stringForStatus:(SyncTaskStatus)status;

// ğŸ†• AFC æœåŠ¡ç›¸å…³æ–¹æ³•
- (BOOL)startAFCService:(NSError **)error;
- (BOOL)startPhotoAFCService:(NSError **)error;
- (void)closeAFCServices;

// ğŸ†• ç…§ç‰‡æ‰«æå’Œå¤„ç†æ–¹æ³•
- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error;
- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                               afcClient:(afc_client_t)afcClient
                                   error:(NSError **)error;
- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath
                            afcClient:(afc_client_t)afcClient;
- (BOOL)isPhotoFile:(NSString *)filename;
- (BOOL)isVideoFile:(NSString *)filename;
- (NSString *)getFileExtension:(NSString *)filename;

// çœŸå®æ•°æ®å¤„ç†æ–¹æ³•
- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType dataArray:(plist_t)data_array syncClass:(NSString *)syncClass;
- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index;
- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;
- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item;

// ğŸ†• ç…§ç‰‡æ•°æ®å¤„ç†æ–¹æ³•
- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error;
- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType;
- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType;

// æ•°æ®è·å–æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;
- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType syncClass:(NSString *)syncClass error:(NSError **)error;

// åŒæ­¥æ“ä½œæ–¹æ³•
- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error;
- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;
- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction;

// ğŸ†• ç…§ç‰‡ç‰¹å®šçš„å¤‡ä»½å’Œæ¢å¤æ–¹æ³•
- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error;
- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error;

// éªŒè¯å’Œé”™è¯¯å¤„ç†
- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType;
- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation;
- (BOOL)ensureDeviceConnection:(NSError **)error;
- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error;
- (BOOL)ensureStableConnection:(NSError **)error;
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType;

// ğŸ†• ç…§ç‰‡ç›¸å…³éªŒè¯æ–¹æ³•
- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error;
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error;

// å·¥å…·æ–¹æ³•
- (void)logMessage:(NSString *)message;
- (NSString *)formatFileSize:(NSUInteger)bytes;
- (NSString *)getCurrentTimestamp;
- (NSUInteger)calculateDirectorySize:(NSString *)dirPath;
- (NSString *)stringForPlistType:(plist_type)type;
- (NSString *)formatDuration:(NSTimeInterval)duration;

// ğŸ†• å†…éƒ¨è¿æ¥æ–¹æ³•ï¼ˆä¸ä½¿ç”¨é”ï¼Œé¿å…é€’å½’é”ï¼‰
- (BOOL)isConnectedInternal;
- (void)disconnectDeviceInternal;


- (NSString *)generateThumbnailPath:(NSString *)originalPath;
- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize;
- (void)checkDeviceCompatibilityForSync;
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType;
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType;

@end

#pragma mark - BackupOptionTask å®Œæ•´å®ç°

@implementation BackupOptionTask

@synthesize deviceUDID = _deviceUDID;
@synthesize status = _status;
@synthesize progress = _progress;
@synthesize lastError = _lastError;
@synthesize isOperating = _isOperating;
@synthesize isPaused = _isPaused;
@synthesize connectionCapability = _connectionCapability;

#pragma mark - å•ä¾‹å’Œåˆå§‹åŒ–

+ (instancetype)sharedInstance {
    static BackupOptionTask *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    return [self initWithDeviceUDID:nil];
}

- (instancetype)initWithDeviceUDID:(NSString *)deviceUDID {
    self = [super init];
    if (self) {
        _deviceUDID = [deviceUDID copy];
        _status = SyncTaskStatusIdle;
        _progress = 0.0;
        _isOperating = NO;
        _isPaused = NO;
        _cancelRequested = NO;
        
        _operationQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.operation", DISPATCH_QUEUE_SERIAL);
        _photoQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.photo", DISPATCH_QUEUE_CONCURRENT);
        _connectionQueue = dispatch_queue_create("com.mfcbox.backupoptiontask.connection", DISPATCH_QUEUE_SERIAL);
        _connectionLock = [[NSRecursiveLock alloc] init];
        _syncAnchors = [NSMutableDictionary dictionary];
        _dataCache = [NSMutableDictionary dictionary];
        _photoCache = [NSMutableDictionary dictionary];
        
        // ğŸ†• ç…§ç‰‡ä¼ è¾“è®¾ç½®é»˜è®¤å€¼
        _photoTransferMode = PhotoTransferModeOriginal;
        _enableThumbnailGeneration = YES;
        _maxPhotoResolution = 0; // æ— é™åˆ¶
        _preserveOriginalFormat = YES;
        _includeHiddenPhotos = NO;
        _includeLivePhotos = YES;
        _includeVideoFiles = YES;
        
        // è®¾ç½®é»˜è®¤æ•°æ®å­˜å‚¨è·¯å¾„
        _dataStoragePath = [DatalogsSettings defaultBackupPath];
        
        _lastSyncTime = nil;
        _totalItemsToProcess = 0;
        _processedItems = 0;
        _totalPhotosToProcess = 0;
        _processedPhotos = 0;
        _photoDownloadedBytes = 0;
        _photoTotalBytes = 0;
        
        [self logMessage:[NSString stringWithFormat:@"Complete Enhanced BackupOptionTask initialized with device UDID: %@", deviceUDID ?: @"(none)"]];
    }
    return self;
}

//- (void)dealloc {
//    [self disconnectDevice];
//}

#pragma mark - è®¾å¤‡è¿æ¥å’ŒæŸ¥è¯¢

- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error {
    [_connectionLock lock];
    @try {
        [self logMessage:[NSString stringWithFormat:@"Connecting to device: %@", deviceUDID]];
        
        if (!deviceUDID || deviceUDID.length == 0) {
            [self logMessage:@"[ERR] Device UDID cannot be empty"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                                 description:@"Device UDID cannot be empty"];
            }
            return NO;
        }
        
        // å¦‚æœå·²ç»è¿æ¥åˆ°åŒä¸€è®¾å¤‡ï¼Œæ£€æŸ¥è¿æ¥çŠ¶æ€
        if ([_deviceUDID isEqualToString:deviceUDID] && [self isConnectedInternal]) {
            [self logMessage:[NSString stringWithFormat:@"Already connected to device: %@ (MobileSync: %@, AFC: %@)",
                             deviceUDID,
                             _mobilesync ? @"Yes" : @"No",
                             _afc ? @"Yes" : @"No"]];
            return YES;
        }
        
        // å®‰å…¨åœ°æ–­å¼€ç°æœ‰è¿æ¥
        if (_device || _lockdown || _mobilesync || _afc) {
            [self logMessage:@"[WAR] Disconnecting existing connection before reconnecting"];
            [self disconnectDeviceInternal];
            // çŸ­æš‚ç­‰å¾…ç¡®ä¿æ¸…ç†å®Œæˆ
            [NSThread sleepForTimeInterval:0.2];
        }
        
        _deviceUDID = [deviceUDID copy];
        return [self connectToDeviceInternal:deviceUDID error:error];
        
    } @finally {
        [_connectionLock unlock];
    }
}

/*
- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. è¿æ¥è®¾å¤‡
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. åˆ›å»ºlockdownå®¢æˆ·ç«¯
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        // æ¸…ç†å·²åˆ›å»ºçš„è®¾å¤‡è¿æ¥
        if (_device) {
            idevice_free(_device);
            _device = NULL;
        }
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // 3. å¯åŠ¨mobilesyncæœåŠ¡ - æ·»åŠ æ›´è¯¦ç»†çš„é”™è¯¯å¤„ç†
    NSError *syncError = nil;
    if (![self startMobileSyncService:&syncError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] MobileSync service failed to start: %@", syncError.localizedDescription]];
        [self logMessage:@"Continuing without MobileSync - photo features will still work via AFC"];
        // ä¸è¦å› ä¸ºMobileSyncå¤±è´¥å°±å®Œå…¨å¤±è´¥ï¼Œå› ä¸ºAFCè¿˜å¯ä»¥å·¥ä½œ
        // æ¸…é™¤é”™è¯¯ä»¥ä¾¿ç»§ç»­
        if (error) *error = nil;
    } else {
        [self logMessage:@"MobileSync service started successfully"];
    }
    
    // ğŸ†• 4. å¯åŠ¨AFCæœåŠ¡ï¼ˆç”¨äºæ–‡ä»¶ä¼ è¾“ï¼‰
    NSError *afcError = nil;
    if (![self startAFCService:&afcError]) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] AFC service failed to start: %@", afcError.localizedDescription]];
        [self logMessage:@"[WAR] Photo features will be limited without AFC"];
        // AFCå¤±è´¥ä¹Ÿä¸å®Œå…¨å¤±è´¥ï¼Œå› ä¸ºMobileSyncè¿˜å¯ä»¥å·¥ä½œ
    } else {
        [self logMessage:@"AFC service started successfully"];
    }
    
    // ğŸ†• 5. å¯åŠ¨ç…§ç‰‡ä¸“ç”¨AFCæœåŠ¡
    NSError *photoAfcError = nil;
    if (![self startPhotoAFCService:&photoAfcError]) {
        [self logMessage:@"Photo AFC service not available, using regular AFC for photos"];
        // è¿™ä¸ªå¤±è´¥æ˜¯æ­£å¸¸çš„ï¼Œå¾ˆå¤šè®¾å¤‡æ²¡æœ‰ä¸“ç”¨çš„AFC2æœåŠ¡
    } else {
        [self logMessage:@"Photo AFC service started successfully"];
    }
    
    // åªè¦æœ‰AFCæˆ–MobileSyncå…¶ä¸­ä¹‹ä¸€æˆåŠŸï¼Œå°±è®¤ä¸ºè¿æ¥æˆåŠŸ
    BOOL hasWorkingService = (_mobilesync != NULL) || (_afc != NULL);
    
    if (hasWorkingService) {
        [self logMessage:[NSString stringWithFormat:@"Successfully connected to device: %@ (MobileSync: %@, AFC: %@)",
                         deviceUDID,
                         _mobilesync ? @"Yes" : @"No",
                         _afc ? @"Yes" : @"No"]];
        [self setInternalStatus:SyncTaskStatusIdle];
        return YES;
    } else {
        [self logMessage:@"[ERR] Neither MobileSync nor AFC services are available"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed
                             description:@"Neither MobileSync nor AFC services could be started"];
        }
        // å®Œå…¨æ¸…ç†è¿æ¥
        [self disconnectDevice];
        return NO;
    }
}*/

- (BOOL)connectToDeviceInternal:(NSString *)deviceUDID error:(NSError **)error {
    [self setInternalStatus:SyncTaskStatusConnecting];
    
    // 1. åŸºç¡€è®¾å¤‡è¿æ¥
    idevice_error_t ret = idevice_new(&_device, [deviceUDID UTF8String]);
    if (ret != IDEVICE_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to device: %d", ret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        return NO;
    }
    
    [self logMessage:@"Device connection established"];
    
    // 2. åˆ›å»ºlockdownå®¢æˆ·ç«¯
    lockdownd_error_t ldret = lockdownd_client_new_with_handshake(_device, &_lockdown, "BackupOptionTask");
    if (ldret != LOCKDOWN_E_SUCCESS) {
        NSString *desc = [NSString stringWithFormat:@"Failed to connect to lockdownd: %d", ldret];
        [self logMessage:desc];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed description:desc];
        }
        [self cleanupBasicConnection];
        return NO;
    }
    
    [self logMessage:@"Lockdown connection established"];
    
    // âœ… å…³é”®ä¿®å¤ï¼šé‡ç½®è¿æ¥èƒ½åŠ›ï¼Œç‹¬ç«‹éªŒè¯å„ä¸ªæœåŠ¡
    _connectionCapability = DeviceConnectionCapabilityNone;
    
    // 3. å°è¯•å¯åŠ¨MobileSyncæœåŠ¡ï¼ˆä¼ ç»Ÿæ•°æ®ç±»å‹å¿…éœ€ï¼‰
    NSError *mobileSyncError = nil;
    if ([self startMobileSyncService:&mobileSyncError]) {
        _connectionCapability |= DeviceConnectionCapabilityMobileSync;
        [self logMessage:@"âœ… MobileSync service available - Traditional data types (Contacts, Calendars, etc.) supported"];
    } else {
        [self logMessage:[NSString stringWithFormat:@"âŒ MobileSync service failed: %@ - Traditional data types will NOT be available",
                         mobileSyncError.localizedDescription ?: @"Unknown error"]];
        // âœ… å…³é”®ä¿®å¤ï¼šä¸æ©ç›–MobileSyncå¤±è´¥ï¼Œå¦‚å®è®°å½•
    }
    
    // 4. å°è¯•å¯åŠ¨AFCæœåŠ¡ï¼ˆç…§ç‰‡æ•°æ®ç±»å‹å¿…éœ€ï¼‰
    NSError *afcError = nil;
    if ([self startAFCService:&afcError]) {
        _connectionCapability |= DeviceConnectionCapabilityAFC;
        [self logMessage:@"âœ… AFC service available - Photo data types supported"];
        
        // 5. å°è¯•å¯åŠ¨ç…§ç‰‡ä¸“ç”¨AFCæœåŠ¡ï¼ˆå¯é€‰ï¼‰
        NSError *photoAfcError = nil;
        if ([self startPhotoAFCService:&photoAfcError]) {
            [self logMessage:@"âœ… Photo AFC service started successfully"];
        } else {
            [self logMessage:@"Photo AFC service not available, using regular AFC for photos"];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"âŒ AFC service failed: %@ - Photo data types will NOT be available",
                         afcError.localizedDescription ?: @"Unknown error"]];
    }
    
    // âœ… å…³é”®ä¿®å¤ï¼šæ˜ç¡®çš„è¿æ¥æˆåŠŸæ ‡å‡†
    if (_connectionCapability == DeviceConnectionCapabilityNone) {
        NSString *errorDesc = @"No services available - neither MobileSync nor AFC could be started. Device connection failed.";
        [self logMessage:[NSString stringWithFormat:@"âŒ %@", errorDesc]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
        }
        [self cleanupBasicConnection];
        return NO;
    }
    
    // âœ… è¿æ¥æˆåŠŸï¼Œè®°å½•è¯¦ç»†çš„èƒ½åŠ›ä¿¡æ¯
    [self logMessage:[NSString stringWithFormat:@"âœ… Successfully connected to device: %@", deviceUDID]];
    [self logMessage:[NSString stringWithFormat:@"ğŸ“Š Connection capability: %@", [self getConnectionCapabilityDescription]]];
    
    [self setInternalStatus:SyncTaskStatusIdle];
    return YES;
}

// âœ… æ–°å¢ï¼šæ¸…ç†åŸºç¡€è¿æ¥çš„è¾…åŠ©æ–¹æ³•
- (void)cleanupBasicConnection {
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
    }
    
    if (_device) {
        idevice_free(_device);
        _device = NULL;
    }
}

// ğŸ†• å¯åŠ¨AFCæœåŠ¡
- (BOOL)startAFCService:(NSError **)error {
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to start AFC service: %d", ldret]];
        }
        return NO;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to create AFC client: %d", afc_err]];
        }
        return NO;
    }
    
    [self logMessage:@"AFC service started successfully"];
    return YES;
}

// ğŸ†• å¯åŠ¨ç…§ç‰‡ä¸“ç”¨AFCæœåŠ¡
- (BOOL)startPhotoAFCService:(NSError **)error {
    // å°è¯•å¯åŠ¨ç…§ç‰‡ä¸“ç”¨çš„AFCæœåŠ¡
    lockdownd_service_descriptor_t service = NULL;
    lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.afc2", &service);
    
    if (ldret != LOCKDOWN_E_SUCCESS) {
        // å¦‚æœæ²¡æœ‰afc2ï¼Œå°è¯•ä½¿ç”¨æ™®é€šçš„afc
        [self logMessage:@"AFC2 service not available, using regular AFC for photos"];
        _afc_photos = _afc; // ä½¿ç”¨åŒä¸€ä¸ªAFCå®¢æˆ·ç«¯
        return YES;
    }
    
    afc_error_t afc_err = afc_client_new(_device, service, &_afc_photos);
    lockdownd_service_descriptor_free(service);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:@"Failed to create photo AFC client, using regular AFC"];
        _afc_photos = _afc; // å›é€€åˆ°æ™®é€šAFC
        return YES;
    }
    
    [self logMessage:@"Photo AFC service started successfully"];
    return YES;
}

- (BOOL)startMobileSyncService:(NSError **)error {
    [self logMessage:@"Starting MobileSync service..."];
    
    int maxRetries = 3;
    int retryDelay = 1; // å‡å°‘å»¶è¿Ÿæ—¶é—´
    
    for (int attempt = 0; attempt < maxRetries; attempt++) {
        lockdownd_service_descriptor_t service = NULL;
        lockdownd_error_t ldret = lockdownd_start_service(_lockdown, "com.apple.mobilesync", &service);
        
        [self logMessage:[NSString stringWithFormat:@"MobileSync service start attempt %d: lockdownd_start_service returned %d",
                         attempt + 1, ldret]];
        
        if (ldret == LOCKDOWN_E_SUCCESS && service && service->port > 0) {
            [self logMessage:[NSString stringWithFormat:@"MobileSync service descriptor created successfully (port: %d)", service->port]];
            
            mobilesync_error_t err = mobilesync_client_new(_device, service, &_mobilesync);
            lockdownd_service_descriptor_free(service);
            
            [self logMessage:[NSString stringWithFormat:@"mobilesync_client_new returned %d", err]];
            
            if (err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:@"MobileSync client created successfully"];
                return YES;  // æˆåŠŸ
            } else {
                [self logMessage:[NSString stringWithFormat:@"[ERR] MobileSync client creation failed (attempt %d): %d", attempt + 1, err]];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"[ERR] Failed to start MobileSync service (attempt %d): ldret=%d, service=%p, port=%d",
                             attempt + 1, ldret, service, service ? service->port : 0]];
            
            if (service) {
                lockdownd_service_descriptor_free(service);
            }
        }
        
        // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
        if (attempt < maxRetries - 1) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Retrying MobileSync in %d seconds...", retryDelay]];
            sleep(retryDelay);
        }
    }
    
    // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥
    NSString *errorDesc = [NSString stringWithFormat:@"Failed to create MobileSync client after %d attempts", maxRetries];
    [self logMessage:[NSString stringWithFormat:@"[ERR] %@", errorDesc]];
    
    if (error) {
        *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
    }
    return NO;
}

- (void)disconnectDevice {
    [_connectionLock lock];
    @try {
        [self disconnectDeviceInternal];
        [self logMessage:@"Device disconnection completed"];
    } @finally {
        [_connectionLock unlock];
    }
}

// ğŸ†• å…³é—­AFCæœåŠ¡ - å¢å¼ºç‰ˆæœ¬ï¼Œç¡®ä¿å®‰å…¨æ¸…ç†
- (void)closeAFCServices {
    // æ¸…ç†ç…§ç‰‡ä¸“ç”¨AFCæœåŠ¡
    if (_afc_photos && _afc_photos != _afc) {
        @try {
            afc_client_free(_afc_photos);
            [self logMessage:@"Photo AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing photo AFC: %@", exception.reason]];
        }
        _afc_photos = NULL;
    }
    
    // æ¸…ç†æ™®é€šAFCæœåŠ¡
    if (_afc) {
        @try {
            afc_client_free(_afc);
            [self logMessage:@"AFC client freed"];
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception freeing AFC: %@", exception.reason]];
        }
        _afc = NULL;
    }
    
    // å¦‚æœç…§ç‰‡AFCæŒ‡å‘æ™®é€šAFCï¼Œä¹Ÿæ¸…ç©º
    if (_afc_photos == _afc) {
        _afc_photos = NULL;
    }
}

/*
- (BOOL)isConnected {
    [_connectionLock lock];
    @try {
        // åªè¦æœ‰è®¾å¤‡è¿æ¥å’Œlockdownï¼Œå¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ªæœåŠ¡ï¼ˆMobileSyncæˆ–AFCï¼‰å¯ç”¨å°±è®¤ä¸ºå·²è¿æ¥
        BOOL connected = (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
        return connected;
    } @finally {
        [_connectionLock unlock];
    }
}*/

- (BOOL)isConnected {
    [_connectionLock lock];
    @try {
        // âœ… ä¿®å¤ï¼šåŸºäºè¿æ¥èƒ½åŠ›åˆ¤æ–­ï¼Œè€Œä¸æ˜¯ç®€å•çš„æœåŠ¡å­˜åœ¨æ£€æŸ¥
        BOOL basicConnectionExists = (_device != NULL && _lockdown != NULL);
        BOOL hasAnyCapability = (_connectionCapability != DeviceConnectionCapabilityNone);
        
        return basicConnectionExists && hasAnyCapability;
    } @finally {
        [_connectionLock unlock];
    }
}

#pragma mark - ğŸ†• å†…éƒ¨è¿æ¥ç®¡ç†æ–¹æ³•

// ğŸ†• å†…éƒ¨è¿æ¥æ£€æŸ¥æ–¹æ³•ï¼ˆä¸ä½¿ç”¨é”ï¼‰
- (BOOL)isConnectedInternal {
    return (_device != NULL && _lockdown != NULL && (_mobilesync != NULL || _afc != NULL));
}

// ğŸ†• å†…éƒ¨æ–­å¼€è¿æ¥æ–¹æ³•ï¼ˆä¸ä½¿ç”¨é”ï¼‰
/*
- (void)disconnectDeviceInternal {
    [self logMessage:@"Internal disconnecting device..."];
    
    // è®¾ç½®çŠ¶æ€ä¸ºç©ºé—²
    [self setInternalStatus:SyncTaskStatusIdle];
    
    // ğŸ†• å…³é—­AFCæœåŠ¡ - å®‰å…¨åœ°æ¸…ç†
    [self closeAFCServices];
    
    // æ¸…ç†MobileSyncè¿æ¥
    if (_mobilesync) {
        @try {
            mobilesync_finish(_mobilesync);
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception during mobilesync_finish: %@", exception.reason]];
        }
        
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [self logMessage:@"MobileSync client freed"];
    }
    
    // æ¸…ç†é€šçŸ¥ä»£ç†
    if (_np) {
        np_client_free(_np);
        _np = NULL;
        [self logMessage:@"Notification proxy freed"];
    }
    
    // æ¸…ç†lockdownè¿æ¥
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
        [self logMessage:@"Lockdown client freed"];
    }
    
    // æ¸…ç†è®¾å¤‡è¿æ¥
    if (_device) {
        idevice_free(_device);
        _device = NULL;
        [self logMessage:@"Device connection freed"];
    }
}
*/

- (void)disconnectDeviceInternal {
    [self logMessage:@"Internal disconnecting device..."];
    
    // âœ… é‡ç½®è¿æ¥èƒ½åŠ›
    _connectionCapability = DeviceConnectionCapabilityNone;
    
    // è®¾ç½®çŠ¶æ€ä¸ºç©ºé—²
    [self setInternalStatus:SyncTaskStatusIdle];
    
    // å…³é—­AFCæœåŠ¡ - å®‰å…¨åœ°æ¸…ç†
    [self closeAFCServices];
    
    // æ¸…ç†MobileSyncè¿æ¥
    if (_mobilesync) {
        @try {
            mobilesync_finish(_mobilesync);
        } @catch (NSException *exception) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] Exception during mobilesync_finish: %@", exception.reason]];
        }
        
        mobilesync_client_free(_mobilesync);
        _mobilesync = NULL;
        [self logMessage:@"MobileSync client freed"];
    }
    
    // æ¸…ç†é€šçŸ¥ä»£ç†
    if (_np) {
        np_client_free(_np);
        _np = NULL;
        [self logMessage:@"Notification proxy freed"];
    }
    
    // æ¸…ç†lockdownè¿æ¥
    if (_lockdown) {
        lockdownd_client_free(_lockdown);
        _lockdown = NULL;
        [self logMessage:@"Lockdown client freed"];
    }
    
    // æ¸…ç†è®¾å¤‡è¿æ¥
    if (_device) {
        idevice_free(_device);
        _device = NULL;
        [self logMessage:@"Device connection freed"];
    }
    
    [self logMessage:@"Device disconnection completed, capability reset to None"];
}

#pragma mark - ğŸ†• ç…§ç‰‡åº“è®¿é—®åŠŸèƒ½

- (BOOL)checkPhotoLibraryAccess:(NSError **)error {
    [self logMessage:@"Checking photo library access"];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Device not connected"];
        }
        return NO;
    }
    
    if (!_afc && !_afc_photos) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // æµ‹è¯•è®¿é—®DCIMç›®å½•
    afc_client_t afc_client = _afc_photos ?: _afc;
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, "/DCIM", &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        [self logMessage:@"Photo library access confirmed"];
        return YES;
    } else if (afc_err == AFC_E_READ_ERROR) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoLibraryLocked
                             description:@"Photo library is locked or access denied"];
        }
        return NO;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:[NSString stringWithFormat:@"Failed to access photo library: %d", afc_err]];
        }
        return NO;
    }
}

- (NSArray<PhotoInfo *> *)scanPhotoLibrary:(NSArray<NSString *> *)albumNames error:(NSError **)error {
    [self logMessage:@"Starting photo library scan"];
    
    if (![self checkPhotoLibraryAccess:error]) {
        return nil;
    }
    
    NSMutableArray<PhotoInfo *> *allPhotos = [NSMutableArray array];
    
    if (!albumNames || albumNames.count == 0) {
        // æ‰«ææ‰€æœ‰é»˜è®¤ç›®å½•
        NSArray *defaultPaths = @[@"/DCIM/100APPLE", @"/DCIM/101APPLE", @"/DCIM/102APPLE"];
        
        for (NSString *path in defaultPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    } else {
        // æ‰«ææŒ‡å®šç›¸å†Œ
        for (NSString *albumName in albumNames) {
            NSString *albumPath = [NSString stringWithFormat:@"/PhotoData/Albums/%@", albumName];
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:albumPath recursive:YES error:nil];
            if (photos) {
                [allPhotos addObjectsFromArray:photos];
            }
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo library scan completed: %lu photos found", (unsigned long)allPhotos.count]];
    return [allPhotos copy];
}

- (void)scanPhotoLibraryAsync:(NSArray<NSString *> *)albumNames
                     progress:(PhotoScanProgressCallback)progressCallback
                   completion:(PhotoCompletionCallback)completion {
    
    dispatch_async(_photoQueue, ^{
        NSError *error = nil;
        NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:albumNames error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(photos, error);
            }
        });
    });
}

- (NSDictionary *)getPhotoLibraryStatistics:(NSError **)error {
    [self logMessage:@"Getting photo library statistics"];
    
    NSArray<PhotoInfo *> *photos = [self scanPhotoLibrary:nil error:error];
    if (!photos) {
        return nil;
    }
    
    NSUInteger photoCount = 0;
    NSUInteger videoCount = 0;
    NSUInteger livePhotoCount = 0;
    NSUInteger burstCount = 0;
    NSUInteger screenshotCount = 0;
    NSUInteger totalSize = 0;
    
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (PhotoInfo *photo in photos) {
        if (photo.isVideo) {
            videoCount++;
        } else {
            photoCount++;
        }
        
        if (photo.isLivePhoto) livePhotoCount++;
        if (photo.isBurst) burstCount++;
        if (photo.isScreenshot) screenshotCount++;
        
        totalSize += photo.fileSize;
        
        if (!oldestDate || [photo.dateCreated compare:oldestDate] == NSOrderedAscending) {
            oldestDate = photo.dateCreated;
        }
        if (!newestDate || [photo.dateCreated compare:newestDate] == NSOrderedDescending) {
            newestDate = photo.dateCreated;
        }
    }
    
    return @{
        @"totalItems": @(photos.count),
        @"photoCount": @(photoCount),
        @"videoCount": @(videoCount),
        @"livePhotoCount": @(livePhotoCount),
        @"burstCount": @(burstCount),
        @"screenshotCount": @(screenshotCount),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"averageFileSize": @(photos.count > 0 ? totalSize / photos.count : 0)
    };
}

- (BOOL)downloadPhoto:(PhotoInfo *)photoInfo
        toDestination:(NSString *)destinationPath
                error:(NSError **)error {
    
    if (!photoInfo || !destinationPath) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo info or destination path cannot be nil"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Downloading photo: %@", photoInfo.filename]];
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return NO;
    }
    
    // æ„å»ºè®¾å¤‡ä¸Šçš„å®Œæ•´è·¯å¾„
    NSString *devicePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // æ‰“å¼€è®¾å¤‡ä¸Šçš„æ–‡ä»¶
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afc_client, [devicePath UTF8String], AFC_FOPEN_RDONLY, &handle);
    if (afc_err != AFC_E_SUCCESS) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to open photo file: %d", afc_err]];
        }
        return NO;
    }
    
    // åˆ›å»ºæœ¬åœ°æ–‡ä»¶
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *destDir = [destinationPath stringByDeletingLastPathComponent];
    if (![fileManager fileExistsAtPath:destDir]) {
        [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    NSFileHandle *destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    if (!destFile) {
        [fileManager createFileAtPath:destinationPath contents:nil attributes:nil];
        destFile = [NSFileHandle fileHandleForWritingAtPath:destinationPath];
    }
    
    if (!destFile) {
        afc_file_close(afc_client, handle);
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to create destination file"];
        }
        return NO;
    }
    
    // è¯»å–å¹¶å†™å…¥æ–‡ä»¶
    const uint32_t bufferSize = 65536; // 64KB buffer
    uint32_t bytesRead = 0;
    NSUInteger totalBytesRead = 0;
    
    do {
        char buffer[bufferSize];
        afc_err = afc_file_read(afc_client, handle, buffer, bufferSize, &bytesRead);
        
        if (afc_err == AFC_E_SUCCESS && bytesRead > 0) {
            NSData *data = [NSData dataWithBytes:buffer length:bytesRead];
            [destFile writeData:data];
            totalBytesRead += bytesRead;
            
            // æŠ¥å‘Šè¿›åº¦
            if (self.photoDownloadCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.photoDownloadCallback(photoInfo.filename, totalBytesRead, photoInfo.fileSize);
                });
            }
        }
    } while (afc_err == AFC_E_SUCCESS && bytesRead > 0);
    
    [destFile closeFile];
    afc_file_close(afc_client, handle);
    
    if (afc_err == AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Successfully downloaded photo: %@ (%lu bytes)",
                         photoInfo.filename, (unsigned long)totalBytesRead]];
        return YES;
    } else {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Failed to read photo data: %d", afc_err]];
        }
        return NO;
    }
}

- (void)downloadPhotos:(NSArray<PhotoInfo *> *)photos
      toDestinationDir:(NSString *)destinationDir
              progress:(PhotoDownloadProgressCallback)progressCallback
            completion:(void (^)(NSUInteger successCount, NSUInteger failedCount, NSError *error))completion {
    
    dispatch_async(_photoQueue, ^{
        NSUInteger successCount = 0;
        NSUInteger failedCount = 0;
        NSError *lastError = nil;
        
        for (NSUInteger i = 0; i < photos.count; i++) {
            if (self->_cancelRequested) {
                break;
            }
            
            PhotoInfo *photo = photos[i];
            NSString *destPath = [destinationDir stringByAppendingPathComponent:photo.filename];
            
            NSError *downloadError = nil;
            BOOL success = [self downloadPhoto:photo toDestination:destPath error:&downloadError];
            
            if (success) {
                successCount++;
            } else {
                failedCount++;
                lastError = downloadError;
            }
            
            // æŠ¥å‘Šæ€»ä½“è¿›åº¦
            if (progressCallback) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    progressCallback(photo.filename, i + 1, photos.count);
                });
            }
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (completion) {
                completion(successCount, failedCount, lastError);
            }
        });
    });
}

#pragma mark - ğŸ†• ç…§ç‰‡æ‰«æå’Œå¤„ç†å®ç°

- (NSArray<PhotoInfo *> *)scanPhotosInDirectory:(NSString *)directory
                                      recursive:(BOOL)recursive
                                          error:(NSError **)error {
    
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed
                             description:@"AFC service not available"];
        }
        return @[];
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err != AFC_E_SUCCESS) {
        [self logMessage:[NSString stringWithFormat:@"Failed to read directory %@: %d", directory, afc_err]];
        return @[];
    }
    
    NSMutableArray<PhotoInfo *> *photos = [NSMutableArray array];
    
    if (dir_list) {
        for (int i = 0; dir_list[i] != NULL; i++) {
            NSString *filename = [NSString stringWithUTF8String:dir_list[i]];
            
            // è·³è¿‡éšè—æ–‡ä»¶å’Œç›®å½•
            if ([filename hasPrefix:@"."]) continue;
            
            NSString *fullPath = [directory stringByAppendingPathComponent:filename];
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡æˆ–è§†é¢‘æ–‡ä»¶
            if ([self isPhotoFile:filename] || [self isVideoFile:filename]) {
                PhotoInfo *photoInfo = [self createPhotoInfoFromPath:fullPath
                                                           afcClient:afc_client
                                                               error:nil];
                if (photoInfo) {
                    [photos addObject:photoInfo];
                }
            } else if (recursive) {
                // é€’å½’æ‰«æå­ç›®å½•
                char **subdir_info = NULL;
                afc_err = afc_get_file_info(afc_client, [fullPath UTF8String], &subdir_info);
                
                if (afc_err == AFC_E_SUCCESS && subdir_info) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç›®å½•
                    for (int j = 0; subdir_info[j] != NULL; j += 2) {
                        if (strcmp(subdir_info[j], "st_ifmt") == 0) {
                            if (strcmp(subdir_info[j + 1], "S_IFDIR") == 0) {
                                NSArray<PhotoInfo *> *subdirPhotos = [self scanPhotosInDirectory:fullPath
                                                                                     recursive:recursive
                                                                                         error:nil];
                                if (subdirPhotos) {
                                    [photos addObjectsFromArray:subdirPhotos];
                                }
                            }
                            break;
                        }
                    }
                    afc_dictionary_free(subdir_info);
                }
            }
        }
        afc_dictionary_free(dir_list);
    }
    
    [self logMessage:[NSString stringWithFormat:@"Found %lu photos in directory: %@",
                     (unsigned long)photos.count, directory]];
    return [photos copy];
}

- (PhotoInfo *)createPhotoInfoFromPath:(NSString *)photoPath
                             afcClient:(afc_client_t)afcClient
                                 error:(NSError **)error {
    
    PhotoInfo *photoInfo = [[PhotoInfo alloc] init];
    photoInfo.filename = [photoPath lastPathComponent];
    photoInfo.format = [[self getFileExtension:photoInfo.filename] uppercaseString];
    photoInfo.isVideo = [self isVideoFile:photoInfo.filename];
    
    // è·å–æ–‡ä»¶ä¿¡æ¯
    char **file_info = NULL;
    afc_error_t afc_err = afc_get_file_info(afcClient, [photoPath UTF8String], &file_info);
    
    if (afc_err == AFC_E_SUCCESS && file_info) {
        for (int i = 0; file_info[i] != NULL; i += 2) {
            NSString *key = [NSString stringWithUTF8String:file_info[i]];
            NSString *value = [NSString stringWithUTF8String:file_info[i + 1]];
            
            if ([key isEqualToString:@"st_size"]) {
                // ä½¿ç”¨å®‰å…¨çš„è½¬æ¢æ–¹æ³•
                photoInfo.fileSize = [self unsignedLongLongValueFromString:value];
            } else if ([key isEqualToString:@"st_mtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateModified = [NSDate dateWithTimeIntervalSince1970:timestamp];
            } else if ([key isEqualToString:@"st_birthtime"]) {
                NSTimeInterval timestamp = [value doubleValue];
                photoInfo.dateCreated = [NSDate dateWithTimeIntervalSince1970:timestamp];
            }
        }
        afc_dictionary_free(file_info);
    } else {
        [self logMessage:[NSString stringWithFormat:@"Failed to get file info for %@: %d", photoPath, afc_err]];
    }
    
    // è®¾ç½®é»˜è®¤å€¼
    if (!photoInfo.dateCreated) {
        photoInfo.dateCreated = photoInfo.dateModified ?: [NSDate date];
    }
    if (!photoInfo.dateModified) {
        photoInfo.dateModified = photoInfo.dateCreated;
    }
    
    // ç”Ÿæˆå”¯ä¸€ID
    photoInfo.photoID = [NSString stringWithFormat:@"%@_%lu",
                        [[photoInfo.filename stringByDeletingPathExtension]
                         stringByReplacingOccurrencesOfString:@" " withString:@"_"],
                        (unsigned long)[photoInfo.dateCreated timeIntervalSince1970]];
    
    // æ£€æµ‹ç‰¹æ®Šç±»å‹
    NSString *lowercaseFilename = [photoInfo.filename lowercaseString];
    photoInfo.isLivePhoto = [lowercaseFilename containsString:@"live"];
    photoInfo.isBurst = [lowercaseFilename containsString:@"burst"];
    photoInfo.isScreenshot = [lowercaseFilename hasPrefix:@"img_"] && [lowercaseFilename containsString:@"screenshot"];
    
    // å°è¯•æå–EXIFæ•°æ®ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    if (!photoInfo.isVideo) {
        photoInfo.exifData = [self extractEXIFFromPath:photoPath afcClient:afcClient];
        
        // ä»EXIFæå–å°ºå¯¸ä¿¡æ¯
        if (photoInfo.exifData) {
            NSNumber *width = photoInfo.exifData[@"PixelXDimension"];
            NSNumber *height = photoInfo.exifData[@"PixelYDimension"];
            if (width && height) {
                photoInfo.width = [width unsignedIntegerValue];
                photoInfo.height = [height unsignedIntegerValue];
            }
        }
    }
    
    return photoInfo;
}

- (NSDictionary *)extractEXIFFromPath:(NSString *)photoPath afcClient:(afc_client_t)afcClient {
    // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„EXIFæå–å®ç°
    // åœ¨çœŸå®å®ç°ä¸­ï¼Œä½ éœ€è¦ä¸€ä¸ªå®Œæ•´çš„EXIFè§£æåº“
    
    // è¯»å–æ–‡ä»¶çš„å‰å‡ ä¸ªå­—èŠ‚æ¥æ£€æµ‹æ ¼å¼å’ŒåŸºæœ¬ä¿¡æ¯
    uint64_t handle = 0;
    afc_error_t afc_err = afc_file_open(afcClient, [photoPath UTF8String], AFC_FOPEN_RDONLY, &handle);
    
    if (afc_err != AFC_E_SUCCESS) {
        return nil;
    }
    
    char header[1024];
    uint32_t bytesRead = 0;
    afc_err = afc_file_read(afcClient, handle, header, sizeof(header), &bytesRead);
    afc_file_close(afcClient, handle);
    
    if (afc_err != AFC_E_SUCCESS || bytesRead < 10) {
        return nil;
    }
    
    NSMutableDictionary *exifData = [NSMutableDictionary dictionary];
    
    // æ£€æµ‹JPEGæ ¼å¼
    if (bytesRead >= 2 && header[0] == (char)0xFF && header[1] == (char)0xD8) {
        exifData[@"Format"] = @"JPEG";
        // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„EXIFè§£æé€»è¾‘
    }
    // æ£€æµ‹HEIFæ ¼å¼
    else if (bytesRead >= 8 && strncmp(&header[4], "ftyp", 4) == 0) {
        exifData[@"Format"] = @"HEIF";
    }
    // æ£€æµ‹PNGæ ¼å¼
    else if (bytesRead >= 8 && strncmp(header, "\x89PNG\r\n\x1a\n", 8) == 0) {
        exifData[@"Format"] = @"PNG";
    }
    
    // æ·»åŠ åŸºæœ¬ä¿¡æ¯
    exifData[@"FileSize"] = @(photoPath.length);
    exifData[@"ExtractedAt"] = [NSDate date];
    
    return [exifData copy];
}

- (BOOL)isPhotoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedPhotoFormats() containsObject:extension];
}

- (BOOL)isVideoFile:(NSString *)filename {
    NSString *extension = [[self getFileExtension:filename] uppercaseString];
    return [SupportedVideoFormats() containsObject:extension];
}

- (NSString *)getFileExtension:(NSString *)filename {
    return [[filename pathExtension] uppercaseString];
}

#pragma mark - æ•°æ®æŸ¥è¯¢å¢å¼º
/*
- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡/åª’ä½“ç±»å‹
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self processPhotoDataForType:dataType error:error];
    }
    
    // æ£€æŸ¥ç¼“å­˜
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // ä½¿ç”¨çœŸå®çš„æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // ç¼“å­˜ç»“æœ
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}*/

- (NSArray<SyncDataItem *> *)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Getting data items for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return nil;
    }
    
    // âœ… å…³é”®ä¿®å¤ï¼šåœ¨æ•°æ®è·å–å‰éªŒè¯æœåŠ¡ä¾èµ–
    if (![self validateServiceDependency:dataType error:error]) {
        return nil;
    }
    
    // ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡/åª’ä½“ç±»å‹
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self processPhotoDataForType:dataType error:error];
    }
    
    // æ£€æŸ¥ç¼“å­˜
    NSString *cacheKey = [NSString stringWithFormat:@"datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _dataCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached data items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Unsupported data type"];
        }
        return nil;
    }
    
    // ä½¿ç”¨çœŸå®çš„æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getDataItemsSimplified:dataType syncClass:syncClass error:error];
    
    // ç¼“å­˜ç»“æœ
    if (items) {
        _dataCache[cacheKey] = items;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Retrieved %lu data items", (unsigned long)items.count]];
    return items;
}

// âœ… æ–°å¢ï¼šéªŒè¯æœåŠ¡ä¾èµ–çš„ç»Ÿä¸€æ–¹æ³•
- (BOOL)validateServiceDependency:(BackupDataType)dataType error:(NSError **)error {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        // ç…§ç‰‡ç±»å‹éœ€è¦AFCæœåŠ¡
        if (!(_connectionCapability & DeviceConnectionCapabilityAFC)) {
            NSString *errorDesc = [NSString stringWithFormat:@"Cannot access %@ data: AFC service is not available. Photo data types require AFC service for file system access.", typeName];
            [self logMessage:[NSString stringWithFormat:@"âŒ %@", errorDesc]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeAFCServiceFailed description:errorDesc];
            }
            return NO;
        }
        [self logMessage:[NSString stringWithFormat:@"âœ… %@ data access validated: AFC service available", typeName]];
        return YES;
    } else {
        // ä¼ ç»Ÿç±»å‹éœ€è¦MobileSyncæœåŠ¡
        if (!(_connectionCapability & DeviceConnectionCapabilityMobileSync)) {
            NSString *errorDesc = [NSString stringWithFormat:@"Cannot access %@ data: MobileSync service is not available. Traditional data types (Contacts, Calendars, etc.) require MobileSync service for data synchronization.", typeName];
            [self logMessage:[NSString stringWithFormat:@"âŒ %@", errorDesc]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeServiceStartFailed description:errorDesc];
            }
            return NO;
        }
        [self logMessage:[NSString stringWithFormat:@"âœ… %@ data access validated: MobileSync service available", typeName]];
        return YES;
    }
}

#pragma mark - âœ… æ–°å¢ï¼šè¿æ¥èƒ½åŠ›æŸ¥è¯¢æ–¹æ³•

- (BOOL)canSyncTraditionalDataTypes {
    return (_connectionCapability & DeviceConnectionCapabilityMobileSync) != 0;
}

- (BOOL)canSyncPhotoDataTypes {
    return (_connectionCapability & DeviceConnectionCapabilityAFC) != 0;
}

- (NSString *)getConnectionCapabilityDescription {
    switch (_connectionCapability) {
        case DeviceConnectionCapabilityNone:
            return @"No services available";
        case DeviceConnectionCapabilityMobileSync:
            return @"Traditional data only (Contacts, Calendars, etc.) - MobileSync available, AFC unavailable";
        case DeviceConnectionCapabilityAFC:
            return @"Photos only - AFC available, MobileSync unavailable";
        case DeviceConnectionCapabilityFull:
            return @"Full capability (Traditional data + Photos) - Both MobileSync and AFC available";
        default:
            return [NSString stringWithFormat:@"Unknown capability state: %lu", (unsigned long)_connectionCapability];
    }
}

- (void)diagnoseServiceCapabilities {
    [self logMessage:@"=== ğŸ“Š Service Capabilities Diagnosis ==="];
    
    // åŸºç¡€è¿æ¥çŠ¶æ€
    BOOL isConnected = [self isConnected];
    [self logMessage:[NSString stringWithFormat:@"Device connected: %@", isConnected ? @"âœ… YES" : @"âŒ NO"]];
    
    if (!isConnected) {
        [self logMessage:@"Device is not connected. Cannot diagnose service capabilities."];
        [self logMessage:@"=== Diagnosis Complete ==="];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    // æœåŠ¡çŠ¶æ€è¯¦æƒ…
    [self logMessage:@"--- Service Status ---"];
    [self logMessage:[NSString stringWithFormat:@"MobileSync service: %@", _mobilesync ? @"âœ… Available" : @"âŒ Not available"]];
    [self logMessage:[NSString stringWithFormat:@"AFC service: %@", _afc ? @"âœ… Available" : @"âŒ Not available"]];
    [self logMessage:[NSString stringWithFormat:@"Photo AFC service: %@",
                     (_afc_photos && _afc_photos != _afc) ? @"âœ… Available (dedicated)" :
                     (_afc_photos == _afc) ? @"âœ… Available (shared with regular AFC)" : @"âŒ Not available"]];
    
    // è¿æ¥èƒ½åŠ›æ€»ç»“
    [self logMessage:@"--- Connection Capabilities ---"];
    [self logMessage:[NSString stringWithFormat:@"Overall capability: %@", [self getConnectionCapabilityDescription]]];
    [self logMessage:[NSString stringWithFormat:@"Can sync traditional data: %@", [self canSyncTraditionalDataTypes] ? @"âœ… YES" : @"âŒ NO"]];
    [self logMessage:[NSString stringWithFormat:@"Can sync photo data: %@", [self canSyncPhotoDataTypes] ? @"âœ… YES" : @"âŒ NO"]];
    
    // æ•°æ®ç±»å‹æ”¯æŒæƒ…å†µ
    [self logMessage:@"--- Data Type Support Summary ---"];
    if ([self canSyncTraditionalDataTypes]) {
        [self logMessage:@"âœ… Traditional data types supported: Contacts, Calendars, Bookmarks, MailAccounts, Notes, Reminders, Applications, Configuration, Keychain, VoiceMemos, Wallpaper"];
    } else {
        [self logMessage:@"âŒ Traditional data types NOT supported: MobileSync service required but not available"];
        [self logMessage:@"ğŸ’¡ To enable traditional data types, ensure device is unlocked and 'Trust This Computer' is confirmed"];
    }
    
    if ([self canSyncPhotoDataTypes]) {
        [self logMessage:@"âœ… Photo data types supported: Photos, Videos, CameraRoll, PhotoAlbums, PhotoStream, Screenshots, SlowMotion, Timelapses, BurstPhotos, LivePhotos"];
    } else {
        [self logMessage:@"âŒ Photo data types NOT supported: AFC service required but not available"];
        [self logMessage:@"ğŸ’¡ To enable photo data types, ensure device is unlocked and file system access is available"];
    }
    
    // å»ºè®®å’Œä¸‹ä¸€æ­¥æ“ä½œ
    [self logMessage:@"--- Recommendations ---"];
    if (_connectionCapability == DeviceConnectionCapabilityNone) {
        [self logMessage:@"âš ï¸  No data can be synchronized. Check device connection and trust status."];
    } else if (_connectionCapability == DeviceConnectionCapabilityFull) {
        [self logMessage:@"ğŸ‰ All data types are supported. Device is ready for comprehensive backup."];
    } else {
        [self logMessage:@"âš ï¸  Partial functionality available. Some data types may not be accessible."];
        if (!(_connectionCapability & DeviceConnectionCapabilityMobileSync)) {
            [self logMessage:@"ğŸ’¡ To enable traditional data sync: Ensure device is unlocked, trusted, and iOS sync services are running"];
        }
        if (!(_connectionCapability & DeviceConnectionCapabilityAFC)) {
            [self logMessage:@"ğŸ’¡ To enable photo sync: Ensure device allows file system access and AFC services are available"];
        }
    }
    
    [self logMessage:@"=== Diagnosis Complete ==="];
}


- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion {
    if (!completion) return;
    
    dispatch_async(_operationQueue, ^{
        NSError *error = nil;
        NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:&error];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(items, error);
        });
    });
}

- (NSDictionary *)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error {
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return nil;
    }
    
    NSUInteger totalRecords = 0;
    NSUInteger totalSize = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    for (SyncDataItem *item in items) {
        totalRecords += item.recordCount;
        totalSize += item.dataSize;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": [BackupOptionTask stringForDataType:dataType]
    };
}

#pragma mark - ğŸ†• ç…§ç‰‡æ•°æ®å¤„ç†æ–¹æ³•

- (NSArray<SyncDataItem *> *)processPhotoDataForType:(BackupDataType)dataType error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Processing photo data for type: %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // æ£€æŸ¥ç…§ç‰‡ç¼“å­˜
    NSString *cacheKey = [NSString stringWithFormat:@"photo_datatype_%lu", (unsigned long)dataType];
    NSArray *cachedItems = _photoCache[cacheKey];
    if (cachedItems) {
        [self logMessage:[NSString stringWithFormat:@"Returning cached photo items: %lu", (unsigned long)cachedItems.count]];
        return cachedItems;
    }
    
    // æ ¹æ®æ•°æ®ç±»å‹ç¡®å®šæ‰«æè·¯å¾„
    NSString *scanPath = PhotoTypeToPathMap()[@(dataType)];
    if (!scanPath) {
        scanPath = @"/DCIM"; // é»˜è®¤è·¯å¾„
    }
    
    // æ‰«æç…§ç‰‡
    NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:scanPath recursive:YES error:error];
    if (!photos) {
        return @[];
    }
    
    // æ ¹æ®æ•°æ®ç±»å‹è¿‡æ»¤ç…§ç‰‡
    NSPredicate *filter = [self createFilterPredicateForDataType:dataType];
    if (filter) {
        photos = [photos filteredArrayUsingPredicate:filter];
    }
    
    // è½¬æ¢ä¸ºSyncDataItem
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    for (PhotoInfo *photo in photos) {
        SyncDataItem *item = [self createSyncItemFromPhotoInfo:photo dataType:dataType];
        if (item) {
            [items addObject:item];
        }
    }
    
    // ç¼“å­˜ç»“æœ
    _photoCache[cacheKey] = items;
    
    [self logMessage:[NSString stringWithFormat:@"Processed %lu photo items for type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return [items copy];
}

- (NSPredicate *)createFilterPredicateForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypePhotos:
            return [NSPredicate predicateWithFormat:@"isVideo == NO"];
        case BackupDataTypeVideos:
            return [NSPredicate predicateWithFormat:@"isVideo == YES"];
        case BackupDataTypeScreenshots:
            return [NSPredicate predicateWithFormat:@"isScreenshot == YES"];
        case BackupDataTypeLivePhotos:
            return [NSPredicate predicateWithFormat:@"isLivePhoto == YES"];
        case BackupDataTypeBurstPhotos:
            return [NSPredicate predicateWithFormat:@"isBurst == YES"];
        default:
            return nil; // æ— è¿‡æ»¤å™¨ï¼Œè¿”å›æ‰€æœ‰ç…§ç‰‡
    }
}

- (SyncDataItem *)createSyncItemFromPhotoInfo:(PhotoInfo *)photoInfo dataType:(BackupDataType)dataType {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    
    item.identifier = photoInfo.photoID;
    item.name = photoInfo.filename;
    item.dataType = dataType;
    item.modificationDate = photoInfo.dateModified;
    item.recordCount = 1;
    item.dataSize = photoInfo.fileSize;
    item.isSelected = NO;
    item.isMediaFile = YES;
    item.photoInfo = photoInfo;
    
    // è®¾ç½®è¿œç¨‹è·¯å¾„
    item.remotePath = [NSString stringWithFormat:@"/DCIM/100APPLE/%@", photoInfo.filename];
    
    // åˆ›å»ºå…ƒæ•°æ®
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    metadata[@"isPhoto"] = @(!photoInfo.isVideo);
    metadata[@"isVideo"] = @(photoInfo.isVideo);
    metadata[@"format"] = photoInfo.format ?: @"Unknown";
    metadata[@"fileSize"] = @(photoInfo.fileSize);
    metadata[@"formattedSize"] = [self formatFileSize:photoInfo.fileSize];
    
    if (photoInfo.width > 0 && photoInfo.height > 0) {
        metadata[@"dimensions"] = [NSString stringWithFormat:@"%lux%lu",
                                  (unsigned long)photoInfo.width, (unsigned long)photoInfo.height];
        metadata[@"width"] = @(photoInfo.width);
        metadata[@"height"] = @(photoInfo.height);
        metadata[@"megapixels"] = @((photoInfo.width * photoInfo.height) / 1000000.0);
    }
    
    if (photoInfo.isVideo && photoInfo.videoDuration > 0) {
        metadata[@"duration"] = @(photoInfo.videoDuration);
        metadata[@"formattedDuration"] = [self formatDuration:photoInfo.videoDuration];
    }
    
    if (photoInfo.isLivePhoto) metadata[@"isLivePhoto"] = @YES;
    if (photoInfo.isBurst) metadata[@"isBurst"] = @YES;
    if (photoInfo.isScreenshot) metadata[@"isScreenshot"] = @YES;
    if (photoInfo.isFavorite) metadata[@"isFavorite"] = @YES;
    
    item.metadata = [metadata copy];
    
    return item;
}

- (NSString *)formatDuration:(NSTimeInterval)duration {
    NSInteger hours = (NSInteger)duration / 3600;
    NSInteger minutes = ((NSInteger)duration % 3600) / 60;
    NSInteger seconds = (NSInteger)duration % 60;
    
    if (hours > 0) {
        return [NSString stringWithFormat:@"%ld:%02ld:%02ld", (long)hours, (long)minutes, (long)seconds];
    } else {
        return [NSString stringWithFormat:@"%ld:%02ld", (long)minutes, (long)seconds];
    }
}

#pragma mark - è·å–æ”¯æŒçš„æ•°æ®ç±»å‹

/*
- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    [self logMessage:@"Getting supported data types with enhanced stability (including photos)"];
    
    if (![self isConnected]) {
        [self logMessage:@"[ERR] Device not connected"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // âœ… ä½¿ç”¨ç¼“å­˜æœºåˆ¶é¿å…é‡å¤æ£€æµ‹
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ5åˆ†é’Ÿå†…ä¸”åŒä¸€è®¾å¤‡ï¼‰
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu",
                         (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // ğŸ“Š å¼€å§‹æ£€æµ‹æ”¯æŒçš„æ•°æ®ç±»å‹
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    [self logMessage:[NSString stringWithFormat:@"Checking %lu data types for support...", (unsigned long)totalCount]];
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        BOOL isSupported = NO;
        
        // ğŸ†• ç…§ç‰‡ç±»å‹ä½¿ç”¨AFCæ£€æŸ¥ï¼Œå…¶ä»–ç±»å‹ä½¿ç”¨MobileSyncæ£€æŸ¥
        if ([BackupOptionTask isPhotoMediaType:dataType]) {
            // ç…§ç‰‡ç±»å‹ï¼šæ£€æŸ¥AFCè®¿é—®èƒ½åŠ›
            if (_afc || _afc_photos) {
                NSString *testPath = PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM";
                isSupported = [self canAccessPhotoDirectory:testPath error:nil];
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ test (path: %@): %@",
                                 typeName, testPath, isSupported ? @"âœ… Supported" : @"âŒ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ skipped: AFC not available", typeName]];
                isSupported = NO;
            }
        } else {
            // éç…§ç‰‡ç±»å‹ï¼šä½¿ç”¨MobileSyncæ£€æŸ¥ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (_mobilesync) {
                isSupported = [self isDataTypeSupportedStable:dataType];
                [self logMessage:[NSString stringWithFormat:@"Data type %@ test: %@",
                                 typeName, isSupported ? @"âœ… Supported" : @"âŒ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Data type %@ skipped: MobileSync not available", typeName]];
                isSupported = NO;
            }
        }
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
        }
        
        // æ·»åŠ å°å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        if (typeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.05];  // å‡å°‘å»¶è¿Ÿæ—¶é—´
        }
    }
    
    // æ›´æ–°ç¼“å­˜
    if (successCount > 0) {
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cacheTime = [NSDate date];
        
        [self logMessage:[NSString stringWithFormat:@"Detection complete: %lu/%lu data types supported (cached for 5 minutes)",
                         (unsigned long)successCount, (unsigned long)totalCount]];
    } else {
        [self logMessage:@"[WAR] No data types detected as supported"];
    }
    
    return supportedTypes;
}*/

- (BackupDataType)getSupportedDataTypes:(NSError **)error {
    [self logMessage:@"Getting supported data types with capability-based detection"];
    
    if (![self isConnected]) {
        [self logMessage:@"âŒ Device not connected"];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return BackupDataTypeNone;
    }
    
    BackupDataType supportedTypes = BackupDataTypeNone;
    
    // âœ… ä½¿ç”¨ç¼“å­˜æœºåˆ¶é¿å…é‡å¤æ£€æµ‹
    static BackupDataType cachedSupportedTypes = BackupDataTypeNone;
    static NSString *cachedDeviceUDID = nil;
    static NSDate *cacheTime = nil;
    static DeviceConnectionCapability cachedCapability = DeviceConnectionCapabilityNone;
    
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ5åˆ†é’Ÿå†…ä¸”åŒä¸€è®¾å¤‡ä¸”èƒ½åŠ›ç›¸åŒï¼‰
    if (cachedSupportedTypes != BackupDataTypeNone &&
        [cachedDeviceUDID isEqualToString:_deviceUDID] &&
        cachedCapability == _connectionCapability &&
        cacheTime && [[NSDate date] timeIntervalSinceDate:cacheTime] < 300) {
        
        [self logMessage:[NSString stringWithFormat:@"Using cached supported types: %lu", (unsigned long)cachedSupportedTypes]];
        return cachedSupportedTypes;
    }
    
    // ğŸ“Š å¼€å§‹æ£€æµ‹æ”¯æŒçš„æ•°æ®ç±»å‹
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger successCount = 0;
    NSUInteger totalCount = allDataTypes.count;
    
    [self logMessage:[NSString stringWithFormat:@"Checking %lu data types based on connection capability...", (unsigned long)totalCount]];
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        BOOL isSupported = NO;
        
        if ([BackupOptionTask isPhotoMediaType:dataType]) {
            // âœ… ç…§ç‰‡ç±»å‹ï¼šåŸºäºAFCèƒ½åŠ›æ£€æµ‹
            if (_connectionCapability & DeviceConnectionCapabilityAFC) {
                NSString *testPath = PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM";
                isSupported = [self canAccessPhotoDirectory:testPath error:nil];
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ (AFC): %@",
                                 typeName, isSupported ? @"âœ… Supported" : @"âŒ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Photo type %@ (AFC): âŒ Not supported - AFC capability missing", typeName]];
                isSupported = NO;
            }
        } else {
            // âœ… ä¼ ç»Ÿç±»å‹ï¼šåŸºäºMobileSyncèƒ½åŠ›æ£€æµ‹
            if (_connectionCapability & DeviceConnectionCapabilityMobileSync) {
                isSupported = [self isDataTypeSupportedStable:dataType];
                [self logMessage:[NSString stringWithFormat:@"Traditional type %@ (MobileSync): %@",
                                 typeName, isSupported ? @"âœ… Supported" : @"âŒ Not supported"]];
            } else {
                [self logMessage:[NSString stringWithFormat:@"Traditional type %@ (MobileSync): âŒ Not supported - MobileSync capability missing", typeName]];
                isSupported = NO;
            }
        }
        
        if (isSupported) {
            supportedTypes |= dataType;
            successCount++;
        }
        
        // æ·»åŠ å°å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        if (typeNum != allDataTypes.lastObject) {
            [NSThread sleepForTimeInterval:0.05];
        }
    }
    
    // âœ… æ›´æ–°ç¼“å­˜
    if (successCount >= 0) { // å³ä½¿æ˜¯0ä¹Ÿç¼“å­˜ï¼Œé¿å…é‡å¤æ£€æµ‹
        cachedSupportedTypes = supportedTypes;
        cachedDeviceUDID = [_deviceUDID copy];
        cachedCapability = _connectionCapability;
        cacheTime = [NSDate date];
        
        [self logMessage:[NSString stringWithFormat:@"Detection complete: %lu/%lu data types supported (cached for 5 minutes)",
                         (unsigned long)successCount, (unsigned long)totalCount]];
        [self logMessage:[NSString stringWithFormat:@"ğŸ“Š Capability summary: %@", [self getConnectionCapabilityDescription]]];
    }
    
    return supportedTypes;
}

// ğŸ†• æ£€æŸ¥ç…§ç‰‡ç›®å½•è®¿é—®èƒ½åŠ›
- (BOOL)canAccessPhotoDirectory:(NSString *)directory error:(NSError **)error {
    afc_client_t afc_client = _afc_photos ?: _afc;
    if (!afc_client) {
        return NO;
    }
    
    char **dir_list = NULL;
    afc_error_t afc_err = afc_read_directory(afc_client, [directory UTF8String], &dir_list);
    
    if (afc_err == AFC_E_SUCCESS) {
        if (dir_list) {
            afc_dictionary_free(dir_list);
        }
        return YES;
    }
    
    return NO;
}

- (BOOL)isDataTypeSupported:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass || ![self isConnected]) {
        return NO;
    }
    
    // ğŸ†• ç…§ç‰‡ç±»å‹ä½¿ç”¨AFCæ£€æŸ¥
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self canAccessPhotoDirectory:PhotoTypeToPathMap()[@(dataType)] ?: @"/DCIM" error:nil];
    }
    
    @try {
        // ä½¿ç”¨æ­£ç¡®çš„APIåˆ›å»ºanchors
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            return NO;
        }
        
        // å‡†å¤‡æ­£ç¡®çš„å‚æ•°
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        // æ­£ç¡®è°ƒç”¨mobilesync_start
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // å¦‚æœæˆåŠŸå¯åŠ¨ï¼Œéœ€è¦ç»“æŸä¼šè¯
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"Exception checking data type support: %@", exception]];
        return NO;
    }
}

// âœ… æ–°å¢ï¼šç¨³å®šçš„æ•°æ®ç±»å‹æ£€æµ‹æ–¹æ³•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
- (BOOL)isDataTypeSupportedStable:(BackupDataType)dataType {
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) return NO;
    
    // âœ… æ·»åŠ è¿æ¥æ£€æŸ¥
    if (!_mobilesync) {
        [self logMessage:@"MobileSyncæœªè¿æ¥ï¼Œè·³è¿‡æ£€æµ‹"];
        return NO;
    }
    
    @try {
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) return NO;
        
        uint64_t data_class_version = 106;
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        mobilesync_error_t err = mobilesync_start(_mobilesync,
                                                [syncClass UTF8String],
                                                anchors,
                                                data_class_version,
                                                &sync_type,
                                                &device_data_class_version,
                                                &error_description);
        
        BOOL supported = (err == MOBILESYNC_E_SUCCESS);
        
        // âœ… é‡è¦ï¼šç«‹å³ç»“æŸä¼šè¯ï¼Œé¿å…çŠ¶æ€æ®‹ç•™
        if (supported) {
            mobilesync_finish(_mobilesync);
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // âœ… æ¯æ¬¡æ£€æµ‹åä¼‘æ¯ï¼Œé¿å…è®¾å¤‡è¿‡è½½
        [NSThread sleepForTimeInterval:0.2];
        
        return supported;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"æ£€æµ‹å¼‚å¸¸: %@", exception.reason]];
        return NO;
    }
}

// âœ… æ–°å¢ï¼šç¡®ä¿ç¨³å®šè¿æ¥æ–¹æ³•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ä½†é¿å…è¿‡åº¦é‡è¿ï¼‰
- (BOOL)ensureStableConnection:(NSError **)error {
    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Connection lost, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            [self logMessage:@"[ERR] No device UDID for reconnection"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID for reconnection"];
            }
            return NO;
        }
        
        // é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    // âœ… ç®€åŒ–è¿æ¥è´¨é‡æ£€æŸ¥ï¼Œé¿å…ä¸å¿…è¦çš„é‡è¿
    if (_lockdown) {
        // åªåšç®€å•çš„è¿æ¥æµ‹è¯•ï¼Œä¸è¦è¿‡åº¦æ£€æŸ¥
        [self logMessage:@"Connection appears stable"];
        return YES;
    }
    
    [self logMessage:@"[WAR] Connection quality check failed, but not attempting risky reconnection"];
    return YES; // è¿”å›YESé¿å…è§¦å‘é‡è¿å¾ªç¯
}

#pragma mark - æ‰«æè®¾å¤‡æ•°æ®å¢å¼ºç‰ˆ

- (NSDictionary *)scanRealDeviceDataEnhanced {
    NSLog(@"=== ğŸ”§ å¼€å§‹å¢å¼ºç‰ˆè®¾å¤‡çœŸå®æ•°æ®æ‰«æï¼ˆåŒ…å«ç…§ç‰‡ï¼‰===");
    
    NSMutableDictionary *realData = [NSMutableDictionary dictionary];
    
    // âœ… é¦–å…ˆè·å–æ”¯æŒçš„æ•°æ®ç±»å‹
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (error) {
        NSLog(@"[WAR] è·å–æ”¯æŒçš„æ•°æ®ç±»å‹å¤±è´¥: %@", error.localizedDescription);
        return @{};
    }
    
    if (supportedTypes == BackupDataTypeNone) {
        NSLog(@"[WAR] è®¾å¤‡ä¸æ”¯æŒä»»ä½•æ•°æ®ç±»å‹çš„é€‰æ‹©æ€§åŒæ­¥");
        return @{};
    }
    
    NSLog(@"è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : %lu", (unsigned long)supportedTypes);
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    // é€ä¸ªå¤„ç†æ”¯æŒçš„æ•°æ®ç±»å‹
    for (NSNumber *typeNumber in allDataTypes) {
        BackupDataType dataType = [typeNumber unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        
        // åªå¤„ç†è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹
        if (!(supportedTypes & dataType)) {
            NSLog(@"è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: %@", typeName);
            continue;
        }
        
        NSLog(@"æ­£åœ¨è·å– %@ çš„çœŸå®æ•°æ®...", typeName);
        
        // âœ… ä½¿ç”¨æ”¹è¿›çš„æ•°æ®è·å–æ–¹æ³•
        NSDictionary *typeData = [self getRealDataForTypeEnhanced:dataType];
        
        if (typeData) {
            realData[@(dataType)] = typeData;
            
            NSNumber *itemCount = typeData[@"itemCount"];
            BOOL isEmpty = [typeData[@"isEmpty"] boolValue];
            
            if (isEmpty || [itemCount integerValue] == 0) {
                NSLog(@"%@ æ”¯æŒä½†æ— æ•°æ®: %@ é¡¹", typeName, itemCount);
            } else {
                NSLog(@"%@ è·å–æˆåŠŸ: %@ é¡¹", typeName, itemCount);
            }
        } else {
            NSLog(@"[WAR] %@ è·å–å¤±è´¥æˆ–æ— å“åº”", typeName);
        }
        
        // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡åº¦è¯·æ±‚
        [NSThread sleepForTimeInterval:0.3];
    }
    
    NSLog(@"=== ğŸ”§ å¢å¼ºç‰ˆæ•°æ®æ‰«æå®Œæˆï¼Œå…±å¤„ç† %lu ç§æ•°æ®ç±»å‹ï¼ˆåŒ…å«ç…§ç‰‡ï¼‰===",
          (unsigned long)realData.count);
    return [realData copy];
}

// âœ… å¢å¼ºçš„æ•°æ®è·å–æ–¹æ³•
- (NSDictionary *)getRealDataForTypeEnhanced:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    NSLog(@"å¢å¼ºæ–¹æ³•è·å– %@ çš„çœŸå®æ•°æ®", typeName);
    
    // âœ… è¿æ¥çŠ¶æ€æ£€æŸ¥
    if (![self isConnected]) {
        NSLog(@"[WAR] è®¾å¤‡æœªè¿æ¥ï¼Œæ— æ³•è·å– %@ æ•°æ®", typeName);
        return nil;
    }
    
    NSError *error = nil;
    NSArray<SyncDataItem *> *items = nil;
    
    // ğŸ†• æ ¹æ®æ•°æ®ç±»å‹é€‰æ‹©è·å–æ–¹æ³•
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        // ç…§ç‰‡ç±»å‹ï¼šä½¿ç”¨AFCæ–¹æ³•
        items = [self processPhotoDataForType:dataType error:&error];
    } else {
        // éç…§ç‰‡ç±»å‹ï¼šä½¿ç”¨MobileSyncæ–¹æ³•
        int maxAttempts = 3;
        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            if (attempt > 0) {
                NSLog(@"é‡è¯•è·å– %@ æ•°æ® (ç¬¬ %d æ¬¡å°è¯•)", typeName, attempt + 1);
                [NSThread sleepForTimeInterval:0.5];
            }
            
            items = [self getDataItemsForType:dataType error:&error];
            
            if (items && items.count > 0) {
                NSLog(@"ç¬¬ %d æ¬¡å°è¯•æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                      attempt + 1, typeName, (unsigned long)items.count);
                break;
            }
            
            if (error) {
                NSLog(@"[WAR] ç¬¬ %d æ¬¡å°è¯•è·å– %@ æ•°æ®å¤±è´¥: %@",
                      attempt + 1, typeName, error.localizedDescription);
                error = nil; // æ¸…é™¤é”™è¯¯ä»¥ä¾¿ä¸‹æ¬¡å°è¯•
            }
        }
    }
    
    if (items && items.count > 0) {
        return [self createDataDictionary:items forType:dataType];
    }
    
    NSLog(@"[WAR] %@ æœ€ç»ˆæ— æ³•è·å–åˆ°æ•°æ®", typeName);
    return nil;
}

// âœ… æ–°å¢ï¼šæ”¹è¿›çš„æ•°æ®å¤„ç†æ–¹æ³•ï¼Œæ›´å¥½åœ°å¤„ç†ç©ºæ•°æ®æƒ…å†µ
- (NSDictionary *)createDataDictionary:(NSArray<SyncDataItem *> *)items forType:(BackupDataType)dataType {
    NSString *typeName = [BackupOptionTask stringForDataType:dataType];
    
    if (!items || items.count == 0) {
        [self logMessage:[NSString stringWithFormat:@"%@ æ•°æ®ä¸ºç©ºï¼Œåˆ›å»ºç©ºæ•°æ®å­—å…¸", typeName]];
        
        // âœ… å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿåˆ›å»ºä¸€ä¸ªæœ‰æ•ˆçš„å­—å…¸
        return @{
            @"items": @[],
            @"itemCount": @0,
            @"totalRecords": @0,
            @"totalSize": @0,
            @"formattedSize": @"0 B",
            @"isAvailable": @YES,
            @"isRealData": @YES,
            @"isEmpty": @YES,
            @"lastScanned": [NSDate date],
            @"dataType": typeName,
            @"message": [NSString stringWithFormat:@"%@ æ”¯æŒä½†å½“å‰æ— æ•°æ®", typeName]
        };
    }
    
    NSUInteger totalSize = 0;
    NSUInteger totalRecords = 0;
    NSDate *oldestDate = nil;
    NSDate *newestDate = nil;
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    for (SyncDataItem *item in items) {
        totalSize += item.dataSize;
        totalRecords += item.recordCount;
        
        if (!oldestDate || [item.modificationDate compare:oldestDate] == NSOrderedAscending) {
            oldestDate = item.modificationDate;
        }
        if (!newestDate || [item.modificationDate compare:newestDate] == NSOrderedDescending) {
            newestDate = item.modificationDate;
        }
    }
    
    return @{
        @"items": items,
        @"itemCount": @(items.count),
        @"totalRecords": @(totalRecords),
        @"totalSize": @(totalSize),
        @"formattedSize": [self formatFileSize:totalSize],
        @"isAvailable": @YES,
        @"isRealData": @YES,
        @"isEmpty": @NO,
        @"lastScanned": [NSDate date],
        @"oldestDate": oldestDate ?: [NSDate date],
        @"newestDate": newestDate ?: [NSDate date],
        @"dataType": typeName
    };
}

#pragma mark - ğŸ†• æ•°æ®ç±»å‹å·¥å…·æ–¹æ³•å¢å¼º

+ (BOOL)isPhotoMediaType:(BackupDataType)dataType {
    BackupDataType photoTypes = (BackupDataTypePhotos | BackupDataTypeVideos | BackupDataTypeCameraRoll |
                                BackupDataTypePhotoAlbums | BackupDataTypePhotoStream | BackupDataTypeScreenshots |
                                BackupDataTypeSlowMotion | BackupDataTypeTimelapses | BackupDataTypeBurstPhotos |
                                BackupDataTypeLivePhotos);
    return (dataType & photoTypes) != 0;
}

+ (NSString *)stringForDataType:(BackupDataType)dataType {
    switch (dataType) {
        case BackupDataTypeContacts:
            return @"Contacts";
        case BackupDataTypeCalendars:
            return @"Calendars";
        case BackupDataTypeBookmarks:
            return @"Bookmarks";
        case BackupDataTypeMailAccounts:
            return @"MailAccounts";
        case BackupDataTypeNotes:
            return @"Notes";
        case BackupDataTypeReminders:
            return @"Reminders";
        case BackupDataTypeApplications:
            return @"Applications";
        case BackupDataTypeConfiguration:
            return @"Configuration";
        case BackupDataTypeKeychain:
            return @"Keychain";
        case BackupDataTypeVoiceMemos:
            return @"Voice Memos";
        case BackupDataTypeWallpaper:
            return @"Wallpaper";
            
        // ğŸ†• ç…§ç‰‡å’Œåª’ä½“ç±»å‹
        case BackupDataTypePhotos:
            return @"Photos";
        case BackupDataTypeVideos:
            return @"Videos";
        case BackupDataTypeCameraRoll:
            return @"Camera Roll";
        case BackupDataTypePhotoAlbums:
            return @"Photo Albums";
        case BackupDataTypePhotoStream:
            return @"Photo Stream";
        case BackupDataTypeScreenshots:
            return @"Screenshots";
        case BackupDataTypeSlowMotion:
            return @"Slow Motion";
        case BackupDataTypeTimelapses:
            return @"Time-lapses";
        case BackupDataTypeBurstPhotos:
            return @"Burst Photos";
        case BackupDataTypeLivePhotos:
            return @"Live Photos";
            
        case BackupDataTypeAll:
            return @"All Data Types";
        default:
            return @"Unknown";
    }
}

+ (NSString *)localizedStringForDataType:(BackupDataType)dataType {
    // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æœ¬åœ°åŒ–æ”¯æŒ
    // ç›®å‰è¿”å›è‹±æ–‡ç‰ˆæœ¬
    return [self stringForDataType:dataType];
}

+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes {
    NSMutableArray *array = [NSMutableArray array];
    
    if (dataTypes & BackupDataTypeContacts) [array addObject:@(BackupDataTypeContacts)];
    if (dataTypes & BackupDataTypeCalendars) [array addObject:@(BackupDataTypeCalendars)];
    if (dataTypes & BackupDataTypeBookmarks) [array addObject:@(BackupDataTypeBookmarks)];
    if (dataTypes & BackupDataTypeMailAccounts) [array addObject:@(BackupDataTypeMailAccounts)];
    if (dataTypes & BackupDataTypeNotes) [array addObject:@(BackupDataTypeNotes)];
    if (dataTypes & BackupDataTypeReminders) [array addObject:@(BackupDataTypeReminders)];
    if (dataTypes & BackupDataTypeApplications) [array addObject:@(BackupDataTypeApplications)];
    if (dataTypes & BackupDataTypeConfiguration) [array addObject:@(BackupDataTypeConfiguration)];
    if (dataTypes & BackupDataTypeKeychain) [array addObject:@(BackupDataTypeKeychain)];
    if (dataTypes & BackupDataTypeVoiceMemos) [array addObject:@(BackupDataTypeVoiceMemos)];
    if (dataTypes & BackupDataTypeWallpaper) [array addObject:@(BackupDataTypeWallpaper)];
    
    // ğŸ†• ç…§ç‰‡å’Œåª’ä½“ç±»å‹
    if (dataTypes & BackupDataTypePhotos) [array addObject:@(BackupDataTypePhotos)];
    if (dataTypes & BackupDataTypeVideos) [array addObject:@(BackupDataTypeVideos)];
    if (dataTypes & BackupDataTypeCameraRoll) [array addObject:@(BackupDataTypeCameraRoll)];
    if (dataTypes & BackupDataTypePhotoAlbums) [array addObject:@(BackupDataTypePhotoAlbums)];
    if (dataTypes & BackupDataTypePhotoStream) [array addObject:@(BackupDataTypePhotoStream)];
    if (dataTypes & BackupDataTypeScreenshots) [array addObject:@(BackupDataTypeScreenshots)];
    if (dataTypes & BackupDataTypeSlowMotion) [array addObject:@(BackupDataTypeSlowMotion)];
    if (dataTypes & BackupDataTypeTimelapses) [array addObject:@(BackupDataTypeTimelapses)];
    if (dataTypes & BackupDataTypeBurstPhotos) [array addObject:@(BackupDataTypeBurstPhotos)];
    if (dataTypes & BackupDataTypeLivePhotos) [array addObject:@(BackupDataTypeLivePhotos)];
    
    return array;
}

+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray {
    BackupDataType dataTypes = BackupDataTypeNone;
    
    for (NSNumber *typeNum in dataTypeArray) {
        dataTypes |= [typeNum unsignedIntegerValue];
    }
    
    return dataTypes;
}

+ (NSArray<NSNumber *> *)getAllAvailableDataTypes {
    return @[
        // åŸæœ‰æ•°æ®ç±»å‹
        @(BackupDataTypeContacts),
        @(BackupDataTypeCalendars),
        @(BackupDataTypeBookmarks),
        @(BackupDataTypeMailAccounts),
        @(BackupDataTypeNotes),
        @(BackupDataTypeReminders),
        @(BackupDataTypeApplications),
        @(BackupDataTypeConfiguration),
        @(BackupDataTypeKeychain),
        @(BackupDataTypeVoiceMemos),
        @(BackupDataTypeWallpaper),
        
        // ğŸ†• æ–°å¢ç…§ç‰‡å’Œåª’ä½“ç±»å‹
        @(BackupDataTypePhotos),
        @(BackupDataTypeVideos),
        @(BackupDataTypeCameraRoll),
        @(BackupDataTypePhotoAlbums),
        @(BackupDataTypePhotoStream),
        @(BackupDataTypeScreenshots),
        @(BackupDataTypeSlowMotion),
        @(BackupDataTypeTimelapses),
        @(BackupDataTypeBurstPhotos),
        @(BackupDataTypeLivePhotos)
    ];
}

#pragma mark - é€‰æ‹©æ€§åŒæ­¥æ“ä½œ

- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Starting selective sync for types: %lu, direction: %lu",
                     (unsigned long)dataTypes, (unsigned long)direction]];
    
    if (_isOperating) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Another operation is already in progress"];
        }
        return NO;
    }
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return NO;
    }
    
    _isOperating = YES;
    _cancelRequested = NO;
    _currentDataTypes = dataTypes;
    _currentDirection = direction;
    _lastSyncTime = [NSDate date];
    
    [self setInternalStatus:SyncTaskStatusPreparing];
    
    // å¼‚æ­¥æ‰§è¡ŒåŒæ­¥æ“ä½œ
    dispatch_async(_operationQueue, ^{
        BOOL success = [self performSelectiveSyncInternal:dataTypes direction:direction];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            self->_isOperating = NO;
            
            if (success) {
                [self setInternalStatus:SyncTaskStatusCompleted];
            } else if (self->_cancelRequested) {
                [self setInternalStatus:SyncTaskStatusCancelled];
            } else {
                [self setInternalStatus:SyncTaskStatusFailed];
            }
            
            if (self.completionCallback) {
                self.completionCallback(success, dataTypes, self->_lastError);
            }
        });
    });
    
    return YES;
}

- (BOOL)performSelectiveSyncInternal:(BackupDataType)dataTypes direction:(SyncDirection)direction {
    [self logMessage:@"Performing selective sync internally"];
    
    [self setInternalStatus:SyncTaskStatusSyncing];
    [self updateProgress:0.0 operation:@"Starting selective sync" current:0 total:100];
    
    // åˆ†è§£æ•°æ®ç±»å‹ä¸ºå•ç‹¬çš„ç±»å‹
    NSArray<NSNumber *> *individualTypes = [BackupOptionTask arrayFromDataTypes:dataTypes];
    NSUInteger totalTypes = individualTypes.count;
    NSUInteger completedTypes = 0;
    
    _totalItemsToProcess = totalTypes;
    _processedItems = 0;
    
    for (NSNumber *typeNum in individualTypes) {
        if (_cancelRequested) {
            [self logMessage:@"Sync cancelled by user"];
            return NO;
        }
        
        BackupDataType singleType = [typeNum unsignedIntegerValue];
        
        [self updateProgress:(completedTypes * 100.0 / totalTypes)
                   operation:[NSString stringWithFormat:@"Syncing %@", [BackupOptionTask stringForDataType:singleType]]
                     current:completedTypes
                       total:totalTypes];
        
        NSError *typeError = nil;
        BOOL typeSuccess = [self performSyncForDataType:singleType direction:direction error:&typeError];
        
        if (!typeSuccess) {
            [self logMessage:[NSString stringWithFormat:@"Failed to sync data type: %@, error: %@",
                             [BackupOptionTask stringForDataType:singleType], typeError]];
            _lastError = typeError;
            return NO;
        }
        
        completedTypes++;
        _processedItems = completedTypes;
    }
    
    [self updateProgress:100.0 operation:@"Selective sync completed" current:totalTypes total:totalTypes];
    [self logMessage:@"Selective sync completed successfully"];
    return YES;
}

- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Syncing %lu specific items", (unsigned long)items.count]];
    
    if (!items || items.count == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"No items specified for sync"];
        }
        return NO;
    }
    
    // æŒ‰æ•°æ®ç±»å‹åˆ†ç»„
    NSMutableDictionary *itemsByType = [NSMutableDictionary dictionary];
    for (SyncDataItem *item in items) {
        NSNumber *typeKey = @(item.dataType);
        NSMutableArray *typeItems = itemsByType[typeKey];
        if (!typeItems) {
            typeItems = [NSMutableArray array];
            itemsByType[typeKey] = typeItems;
        }
        [typeItems addObject:item];
    }
    
    // å¯¹æ¯ç§æ•°æ®ç±»å‹æ‰§è¡ŒåŒæ­¥
    for (NSNumber *typeKey in itemsByType) {
        BackupDataType dataType = [typeKey unsignedIntegerValue];
        NSArray *typeItems = itemsByType[typeKey];
        
        [self logMessage:[NSString stringWithFormat:@"Syncing %lu items of type: %@",
                         (unsigned long)typeItems.count, [BackupOptionTask stringForDataType:dataType]]];
        
        // è¿™é‡Œå¯ä»¥å®ç°æ›´ç»†ç²’åº¦çš„é¡¹ç›®åŒæ­¥é€»è¾‘
        // ç›®å‰å…ˆä½¿ç”¨æ•°æ®ç±»å‹çº§åˆ«çš„åŒæ­¥
        if (![self performSyncForDataType:dataType direction:direction error:error]) {
            return NO;
        }
    }
    
    return YES;
}

- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up selected data types to: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return NO;
    }
    
    // åˆ›å»ºå¤‡ä»½ç›®å½•
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:backupPath]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:backupPath
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create backup directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionFromDevice error:error];
}

- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring selected data types from: %@", backupPath]];
    
    if (!backupPath || backupPath.length == 0 || ![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    _currentBackupPath = backupPath;
    return [self startSelectiveSync:dataTypes direction:SyncDirectionToDevice error:error];
}

#pragma mark - æ“ä½œæ§åˆ¶

- (void)cancelCurrentOperation {
    [self logMessage:@"Cancelling current operation"];
    _cancelRequested = YES;
}

- (void)pauseCurrentOperation {
    [self logMessage:@"Pausing current operation"];
    _isPaused = YES;
}

- (void)resumeCurrentOperation {
    [self logMessage:@"Resuming current operation"];
    _isPaused = NO;
}

- (float)getCurrentProgress {
    return _progress;
}

#pragma mark - åŒæ­¥æ“ä½œå®ç°

- (BOOL)performSyncForDataType:(BackupDataType)dataType direction:(SyncDirection)direction error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Performing sync for data type: %@, direction: %lu",
                     [BackupOptionTask stringForDataType:dataType], (unsigned long)direction]];
    
    // æ ¹æ®æ–¹å‘æ‰§è¡Œä¸åŒçš„æ“ä½œ
    if (direction == SyncDirectionFromDevice) {
        return [self backupDataType:dataType toPath:_currentBackupPath error:error];
    } else if (direction == SyncDirectionToDevice) {
        return [self restoreDataType:dataType fromPath:_currentBackupPath error:error];
    } else {
        // åŒå‘åŒæ­¥æš‚æ—¶ä¸å®ç°
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Bidirectional sync not yet implemented"];
        }
        return NO;
    }
}

- (BOOL)backupDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡ç±»å‹ï¼Œä½¿ç”¨ä¸åŒçš„å¤‡ä»½æ–¹æ³•
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self backupPhotoDataType:dataType toPath:path error:error];
    }
    
    // è·å–æ•°æ®é¡¹
    NSArray<SyncDataItem *> *items = [self getDataItemsForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // åˆ›å»ºæ•°æ®ç±»å‹ç›®å½•
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // ä¿å­˜æ•°æ®é¡¹ä¿¡æ¯
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"metadata": item.metadata ?: @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save items data"];
        }
        return NO;
    }
    
    // ä¿å­˜å¤‡ä»½å…ƒæ•°æ®
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown"
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu items of type: %@",
                     (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

- (BOOL)restoreDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // ğŸ†• æ£€æŸ¥æ˜¯å¦æ˜¯ç…§ç‰‡ç±»å‹ï¼Œä½¿ç”¨ä¸åŒçš„æ¢å¤æ–¹æ³•
    if ([BackupOptionTask isPhotoMediaType:dataType]) {
        return [self restorePhotoDataType:dataType fromPath:path error:error];
    }
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully restored %lu items of type: %@",
                     (unsigned long)itemsData.count, [BackupOptionTask stringForDataType:dataType]]];
    return YES;
}

#pragma mark - ğŸ†• ç…§ç‰‡ç‰¹å®šçš„å¤‡ä»½å’Œæ¢å¤æ–¹æ³•

- (BOOL)backupPhotoDataType:(BackupDataType)dataType toPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Backing up photo data type: %@ to path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    // è·å–ç…§ç‰‡æ•°æ®é¡¹
    NSArray<SyncDataItem *> *items = [self processPhotoDataForType:dataType error:error];
    if (!items) {
        return NO;
    }
    
    // åˆ›å»ºæ•°æ®ç±»å‹ç›®å½•
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if (![fileManager fileExistsAtPath:dataTypeDir]) {
        NSError *createError = nil;
        if (![fileManager createDirectoryAtPath:dataTypeDir
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&createError]) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:[NSString stringWithFormat:@"Failed to create directory: %@", createError.localizedDescription]];
            }
            return NO;
        }
    }
    
    // åˆ›å»ºç…§ç‰‡å­ç›®å½•
    NSString *photosDir = [dataTypeDir stringByAppendingPathComponent:@"Media"];
    NSString *thumbnailsDir = [dataTypeDir stringByAppendingPathComponent:@"Thumbnails"];
    
    [fileManager createDirectoryAtPath:photosDir withIntermediateDirectories:YES attributes:nil error:nil];
    if (self.enableThumbnailGeneration) {
        [fileManager createDirectoryAtPath:thumbnailsDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    // ä¸‹è½½ç…§ç‰‡æ–‡ä»¶
    NSUInteger successCount = 0;
    NSUInteger totalCount = items.count;
    
    for (NSUInteger i = 0; i < items.count; i++) {
        if (_cancelRequested) {
            break;
        }
        
        SyncDataItem *item = items[i];
        if (!item.isMediaFile || !item.photoInfo) {
            continue;
        }
        
        // æ›´æ–°è¿›åº¦
        [self updateProgress:(i * 100.0 / totalCount)
                   operation:[NSString stringWithFormat:@"Downloading %@", item.photoInfo.filename]
                     current:i
                       total:totalCount];
        
        // ä¸‹è½½åŸå§‹æ–‡ä»¶
        NSString *destPath = [photosDir stringByAppendingPathComponent:item.photoInfo.filename];
        NSError *downloadError = nil;
        BOOL success = [self downloadPhoto:item.photoInfo toDestination:destPath error:&downloadError];
        
        if (success) {
            successCount++;
            item.localPath = destPath;
            
            // ç”Ÿæˆç¼©ç•¥å›¾
            if (self.enableThumbnailGeneration && !item.photoInfo.isVideo) {
                NSString *thumbnailPath = [self generateThumbnailPath:destPath];
                [self createThumbnail:destPath destinationPath:thumbnailPath maxSize:200];
            }
        } else {
            [self logMessage:[NSString stringWithFormat:@"Failed to download %@: %@",
                             item.photoInfo.filename, downloadError.localizedDescription]];
        }
    }
    
    // ä¿å­˜ç…§ç‰‡é¡¹ä¿¡æ¯
    NSMutableArray *itemsData = [NSMutableArray array];
    for (SyncDataItem *item in items) {
        NSDictionary *itemDict = @{
            @"identifier": item.identifier ?: @"",
            @"name": item.name ?: @"",
            @"dataType": @(item.dataType),
            @"modificationDate": item.modificationDate ?: [NSDate date],
            @"recordCount": @(item.recordCount),
            @"dataSize": @(item.dataSize),
            @"isMediaFile": @(item.isMediaFile),
            @"localPath": item.localPath ?: @"",
            @"remotePath": item.remotePath ?: @"",
            @"metadata": item.metadata ?: @{},
            @"photoInfo": item.photoInfo ? @{
                @"filename": item.photoInfo.filename ?: @"",
                @"photoID": item.photoInfo.photoID ?: @"",
                @"format": item.photoInfo.format ?: @"",
                @"fileSize": @(item.photoInfo.fileSize),
                @"width": @(item.photoInfo.width),
                @"height": @(item.photoInfo.height),
                @"isVideo": @(item.photoInfo.isVideo),
                @"isLivePhoto": @(item.photoInfo.isLivePhoto),
                @"isBurst": @(item.photoInfo.isBurst),
                @"isScreenshot": @(item.photoInfo.isScreenshot),
                @"isFavorite": @(item.photoInfo.isFavorite),
                @"dateCreated": item.photoInfo.dateCreated ?: [NSDate date],
                @"dateModified": item.photoInfo.dateModified ?: [NSDate date]
            } : @{}
        };
        [itemsData addObject:itemDict];
    }
    
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    if (![itemsData writeToFile:itemsFile atomically:YES]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Failed to save photo items data"];
        }
        return NO;
    }
    
    // ä¿å­˜å¤‡ä»½å…ƒæ•°æ®
    NSDictionary *metadata = @{
        @"dataType": [BackupOptionTask stringForDataType:dataType],
        @"itemCount": @(items.count),
        @"successCount": @(successCount),
        @"backupDate": [NSDate date],
        @"deviceUDID": _deviceUDID ?: @"unknown",
        @"photoTransferMode": @(self.photoTransferMode),
        @"includeThumbnails": @(self.enableThumbnailGeneration),
        @"preserveOriginalFormat": @(self.preserveOriginalFormat)
    };
    
    NSString *metadataFile = [dataTypeDir stringByAppendingPathComponent:@"metadata.plist"];
    [metadata writeToFile:metadataFile atomically:YES];
    
    [self logMessage:[NSString stringWithFormat:@"Successfully backed up %lu/%lu photos of type: %@",
                     (unsigned long)successCount, (unsigned long)items.count, [BackupOptionTask stringForDataType:dataType]]];
    
    return successCount > 0;
}

- (BOOL)restorePhotoDataType:(BackupDataType)dataType fromPath:(NSString *)path error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Restoring photo data type: %@ from path: %@",
                     [BackupOptionTask stringForDataType:dataType], path]];
    
    NSString *dataTypeDir = [path stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
    NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:@"Photo backup data not found"];
        }
        return NO;
    }
    
    NSArray *itemsData = [NSArray arrayWithContentsOfFile:itemsFile];
    if (!itemsData) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                             description:@"Photo backup data is corrupted"];
        }
        return NO;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Photo restore not yet implemented for %@", [BackupOptionTask stringForDataType:dataType]]];
    
    // TODO: å®ç°ç…§ç‰‡ä¸Šä¼ åˆ°è®¾å¤‡çš„åŠŸèƒ½
    // è¿™éœ€è¦ä½¿ç”¨AFCå†™å…¥æ–‡ä»¶åˆ°è®¾å¤‡çš„/DCIMç›®å½•
    
    return YES;
}

#pragma mark - ä¾¿æ·æ–¹æ³•

- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *contactsPath = [_dataStoragePath stringByAppendingPathComponent:@"Contacts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeContacts
                                     toDirectory:contactsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *calendarsPath = [_dataStoragePath stringByAppendingPathComponent:@"Calendars"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCalendars
                                     toDirectory:calendarsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *bookmarksPath = [_dataStoragePath stringByAppendingPathComponent:@"Bookmarks"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeBookmarks
                                     toDirectory:bookmarksPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *mailAccountsPath = [_dataStoragePath stringByAppendingPathComponent:@"MailAccounts"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeMailAccounts
                                     toDirectory:mailAccountsPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *notesPath = [_dataStoragePath stringByAppendingPathComponent:@"Notes"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeNotes
                                     toDirectory:notesPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion {
    NSString *remindersPath = [_dataStoragePath stringByAppendingPathComponent:@"Reminders"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeReminders
                                     toDirectory:remindersPath
                                           error:&error];
    
    if (completion) {
        completion(success, error);
    }
}

- (void)quickBackupPhotos:(PhotoTransferMode)transferMode
               completion:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *photosPath = [_dataStoragePath stringByAppendingPathComponent:@"Photos"];
    
    // è®¾ç½®ä¼ è¾“æ¨¡å¼
    self.photoTransferMode = transferMode;
    
    // å¼€å§‹å¤‡ä»½
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypePhotos
                                     toDirectory:photosPath
                                           error:&error];
    
    if (completion) {
        // è·å–ç…§ç‰‡æ•°é‡
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypePhotos error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupCameraRoll:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion {
    
    NSString *cameraRollPath = [_dataStoragePath stringByAppendingPathComponent:@"CameraRoll"];
    
    NSError *error = nil;
    BOOL success = [self backupSelectedDataTypes:BackupDataTypeCameraRoll
                                     toDirectory:cameraRollPath
                                           error:&error];
    
    if (completion) {
        NSUInteger photoCount = 0;
        if (success) {
            NSArray<SyncDataItem *> *items = [self getDataItemsForType:BackupDataTypeCameraRoll error:nil];
            photoCount = items.count;
        }
        
        completion(success, photoCount, error);
    }
}

- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion {
    NSError *error = nil;
    BackupDataType supportedTypes = [self getSupportedDataTypes:&error];
    
    if (supportedTypes == BackupDataTypeNone) {
        if (completion) {
            completion(NO, BackupDataTypeNone, error);
        }
        return;
    }
    
    NSString *allDataPath = [_dataStoragePath stringByAppendingPathComponent:@"AllData"];
    
    // è®¾ç½®å®Œæˆå›è°ƒæ¥æ•è·ç»“æœ
    self.completionCallback = ^(BOOL success, BackupDataType completedTypes, NSError *completionError) {
        if (completion) {
            completion(success, completedTypes, completionError);
        }
    };
    
    [self backupSelectedDataTypes:supportedTypes toDirectory:allDataPath error:&error];
}

#pragma mark - æ•°æ®éªŒè¯å’Œæ¢å¤

- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error {
    [self logMessage:[NSString stringWithFormat:@"Verifying backup integrity at: %@", backupPath]];
    
    if (![[NSFileManager defaultManager] fileExistsAtPath:backupPath]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return NO;
    }
    
    NSArray<NSNumber *> *typesToCheck = [BackupOptionTask arrayFromDataTypes:dataTypes];
    
    for (NSNumber *typeNum in typesToCheck) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:[BackupOptionTask stringForDataType:dataType]];
        NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:itemsFile]) {
            [self logMessage:[NSString stringWithFormat:@"Missing data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Missing data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
        
        // å°è¯•è¯»å–æ–‡ä»¶ä»¥éªŒè¯æ ¼å¼
        NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
        if (!items) {
            [self logMessage:[NSString stringWithFormat:@"Corrupted data file for type: %@", [BackupOptionTask stringForDataType:dataType]]];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeDataCorrupted
                                 description:[NSString stringWithFormat:@"Corrupted data for %@", [BackupOptionTask stringForDataType:dataType]]];
            }
            return NO;
        }
    }
    
    [self logMessage:@"Backup integrity verification passed"];
    return YES;
}

- (NSDictionary *)getBackupInfo:(NSString *)backupPath error:(NSError **)error {
    // å‚æ•°éªŒè¯
    if (!backupPath || backupPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path cannot be empty"];
        }
        return nil;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
    BOOL isDirectory = NO;
    if (![fileManager fileExistsAtPath:backupPath isDirectory:&isDirectory]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path does not exist"];
        }
        return nil;
    }
    
    // ç¡®ä¿æ˜¯ç›®å½•è€Œä¸æ˜¯æ–‡ä»¶
    if (!isDirectory) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Backup path is not a directory"];
        }
        return nil;
    }
    
    NSMutableDictionary *backupInfo = [NSMutableDictionary dictionary];
    
    // è·å–åŸºæœ¬ä¿¡æ¯ - æ·»åŠ é”™è¯¯å¤„ç†
    NSError *attributesError = nil;
    NSDictionary *pathAttributes = [fileManager attributesOfItemAtPath:backupPath error:&attributesError];
    if (pathAttributes) {
        if (pathAttributes[NSFileCreationDate]) {
            backupInfo[@"creationDate"] = pathAttributes[NSFileCreationDate];
        }
        if (pathAttributes[NSFileModificationDate]) {
            backupInfo[@"modificationDate"] = pathAttributes[NSFileModificationDate];
        }
    } else {
        [self logMessage:[NSString stringWithFormat:@"Warning: Could not get path attributes: %@", attributesError.localizedDescription]];
        // è®¾ç½®é»˜è®¤å€¼
        backupInfo[@"creationDate"] = [NSDate date];
        backupInfo[@"modificationDate"] = [NSDate date];
    }
    
    backupInfo[@"backupPath"] = backupPath;
    backupInfo[@"deviceUDID"] = _deviceUDID ?: @"unknown";
    
    // æ‰«ææ•°æ®ç±»å‹
    NSMutableArray *availableDataTypes = [NSMutableArray array];
    NSUInteger totalItems = 0;
    NSUInteger totalSize = 0;
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    
    for (NSNumber *typeNum in allDataTypes) {
        @autoreleasepool {  // è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œé¿å…å†…å­˜ç´¯ç§¯
            BackupDataType dataType = [typeNum unsignedIntegerValue];
            NSString *dataTypeStr = [BackupOptionTask stringForDataType:dataType];
            NSString *dataTypeDir = [backupPath stringByAppendingPathComponent:dataTypeStr];
            NSString *itemsFile = [dataTypeDir stringByAppendingPathComponent:@"items.plist"];
            
            // æ£€æŸ¥items.plistæ˜¯å¦å­˜åœ¨
            if ([fileManager fileExistsAtPath:itemsFile]) {
                // å°è¯•è¯»å–itemsæ•°æ®
                NSArray *items = [NSArray arrayWithContentsOfFile:itemsFile];
                if (items && [items isKindOfClass:[NSArray class]]) {
                    // è®¡ç®—è¯¥æ•°æ®ç±»å‹çš„å¤§å°
                    NSUInteger dataTypeSize = [self calculateDirectorySize:dataTypeDir];
                    
                    NSDictionary *dataTypeInfo = @{
                        @"dataType": dataTypeStr,
                        @"itemCount": @(items.count),
                        @"size": @(dataTypeSize),
                        @"formattedSize": [self formatFileSize:dataTypeSize]
                    };
                    
                    [availableDataTypes addObject:dataTypeInfo];
                    totalItems += items.count;
                    totalSize += dataTypeSize;
                    
                    [self logMessage:[NSString stringWithFormat:@"Found %@ with %lu items (%@)",
                                     dataTypeStr, (unsigned long)items.count, [self formatFileSize:dataTypeSize]]];
                } else {
                    [self logMessage:[NSString stringWithFormat:@"Warning: Could not read items.plist for %@", dataTypeStr]];
                }
            }
        }
    }
    
    // è®¾ç½®æ±‡æ€»ä¿¡æ¯
    backupInfo[@"availableDataTypes"] = [availableDataTypes copy];
    backupInfo[@"totalItems"] = @(totalItems);
    backupInfo[@"totalSize"] = @(totalSize);
    backupInfo[@"formattedSize"] = [self formatFileSize:totalSize];
    backupInfo[@"dataTypeCount"] = @(availableDataTypes.count);
    
    // æ·»åŠ å¤‡ä»½ç»Ÿè®¡ä¿¡æ¯
    if (availableDataTypes.count > 0) {
        backupInfo[@"isEmpty"] = @NO;
        backupInfo[@"summary"] = [NSString stringWithFormat:@"%lu data types, %lu items, %@",
                                 (unsigned long)availableDataTypes.count,
                                 (unsigned long)totalItems,
                                 [self formatFileSize:totalSize]];
    } else {
        backupInfo[@"isEmpty"] = @YES;
        backupInfo[@"summary"] = @"Empty backup directory";
    }
    
    [self logMessage:[NSString stringWithFormat:@"Backup info: %@", backupInfo[@"summary"]]];
    
    return [backupInfo copy];
}

#pragma mark - è°ƒè¯•å’Œè¯Šæ–­å·¥å…·

- (void)diagnoseDeviceSyncCapabilities {
    
    if (![self isConnected]) {
        [self logMessage:@"Device not connected"];
        return;
    }
    
    [self logMessage:[NSString stringWithFormat:@"Device UDID: %@", _deviceUDID ?: @"Unknown"]];
    
    NSArray<NSNumber *> *allDataTypes = [BackupOptionTask getAllAvailableDataTypes];
    NSUInteger supportedCount = 0;
    
    for (NSNumber *typeNum in allDataTypes) {
        BackupDataType dataType = [typeNum unsignedIntegerValue];
        NSString *typeName = [BackupOptionTask stringForDataType:dataType];
        NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
        
        BOOL isSupported = [self isDataTypeSupported:dataType];
        NSString *status = isSupported ? @"âœ…" : @"âŒ";
        
        [self logMessage:[NSString stringWithFormat:@"%@ %@ (%@)", status, typeName, syncClass]];
        
        if (isSupported) {
            supportedCount++;
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Total: %lu/%lu data types supported",
                     (unsigned long)supportedCount, (unsigned long)allDataTypes.count]];
}

- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType {
    NSMutableDictionary *info = [NSMutableDictionary dictionary];
    
    info[@"dataType"] = [BackupOptionTask stringForDataType:dataType];
    info[@"syncClass"] = DataTypeToSyncClassMap()[@(dataType)] ?: @"Unknown";
    info[@"isSupported"] = @([self isDataTypeSupported:dataType]);
    info[@"isConnected"] = @([self isConnected]);
    info[@"isPhotoMediaType"] = @([BackupOptionTask isPhotoMediaType:dataType]);
    
    if ([self isConnected] && [self isDataTypeSupported:dataType]) {
        NSError *error = nil;
        NSArray *items = [self getDataItemsForType:dataType error:&error];
        
        info[@"itemCount"] = @(items.count);
        info[@"hasError"] = @(error != nil);
        if (error) {
            info[@"error"] = error.localizedDescription;
        }
        
        if (items.count > 0) {
            SyncDataItem *firstItem = items.firstObject;
            info[@"sampleItem"] = @{
                @"name": firstItem.name ?: @"",
                @"identifier": firstItem.identifier ?: @"",
                @"dataSize": @(firstItem.dataSize),
                @"recordCount": @(firstItem.recordCount),
                @"isMediaFile": @(firstItem.isMediaFile)
            };
        }
    }
    
    return info;
}

- (void)diagnosePhotoLibraryAccess {
    [self logMessage:@"=== Photo Library Access Diagnosis ==="];
    
    if (![self isConnected]) {
        [self logMessage:@"[WAR] Device not connected"];
        return;
    }
    
    // æ£€æŸ¥AFCæœåŠ¡
    if (!_afc) {
        [self logMessage:@"[WAR] AFC service not available"];
    } else {
        [self logMessage:@"AFC service available"];
    }
    
    if (!_afc_photos) {
        [self logMessage:@"[WAR] Photo AFC service not available, using regular AFC"];
    } else if (_afc_photos == _afc) {
        [self logMessage:@"Using regular AFC for photo access"];
    } else {
        [self logMessage:@"Dedicated photo AFC service available"];
    }
    
    // æµ‹è¯•DCIMç›®å½•è®¿é—®
    NSError *error = nil;
    BOOL hasAccess = [self checkPhotoLibraryAccess:&error];
    
    if (hasAccess) {
        [self logMessage:@"Photo library access confirmed"];
        
        // æ‰«æå„ä¸ªç…§ç‰‡ç›®å½•
        NSArray *testPaths = @[@"/DCIM", @"/DCIM/100APPLE", @"/PhotoData"];
        
        for (NSString *path in testPaths) {
            NSArray<PhotoInfo *> *photos = [self scanPhotosInDirectory:path recursive:NO error:nil];
            [self logMessage:[NSString stringWithFormat:@"%@: %lu items", path, (unsigned long)photos.count]];
        }
        
        // è·å–ç»Ÿè®¡ä¿¡æ¯
        NSDictionary *stats = [self getPhotoLibraryStatistics:nil];
        if (stats) {
            [self logMessage:[NSString stringWithFormat:@"Total photos: %@", stats[@"photoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total videos: %@", stats[@"videoCount"]]];
            [self logMessage:[NSString stringWithFormat:@"Total size: %@", stats[@"formattedSize"]]];
        }
        
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] Photo library access failed: %@", error.localizedDescription]];
    }
    
    [self logMessage:@"=== Photo Library Diagnosis Complete ==="];
}

#pragma mark - çœŸå®æ•°æ®å¤„ç†æ–¹æ³•å®ç°

- (NSArray<SyncDataItem *> *)processRealDataForType:(BackupDataType)dataType
                                          dataArray:(plist_t)data_array
                                          syncClass:(NSString *)syncClass {
    
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for %@", syncClass]];
        return @[];
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¤„ç†éæ•°ç»„ç±»å‹çš„æƒ…å†µ
    if (type != PLIST_ARRAY) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ è¿”å›éæ•°ç»„æ•°æ®ï¼Œå¯èƒ½è¡¨ç¤ºç©ºæ•°æ®é›†", syncClass]];
        
        // å¦‚æœæ˜¯å¸ƒå°”ç±»å‹ï¼Œå¯èƒ½è¡¨ç¤ºåŒæ­¥çŠ¶æ€
        if (type == PLIST_BOOLEAN) {
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥çŠ¶æ€: %s",
                             syncClass, bool_val ? "æˆåŠŸ" : "å¤±è´¥"]];
        }
        
        return @[]; // è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯å¤±è´¥
    }
    
    // ç»§ç»­å¤„ç†æ•°ç»„æ•°æ®...
    NSMutableArray<SyncDataItem *> *items = [NSMutableArray array];
    uint32_t count = plist_array_get_size(data_array);
    
    [self logMessage:[NSString stringWithFormat:@"Processing %u real data items for %@", count, syncClass]];
    
    for (uint32_t i = 0; i < count; i++) {
        plist_t item_dict = plist_array_get_item(data_array, i);
        if (plist_get_node_type(item_dict) != PLIST_DICT) continue;
        
        SyncDataItem *syncItem = [self createSyncItemFromPlist:item_dict dataType:dataType index:i];
        if (syncItem) {
            [items addObject:syncItem];
        }
    }
    
    [self logMessage:[NSString stringWithFormat:@"Successfully processed %lu real items for %@",
                     (unsigned long)items.count, syncClass]];
    
    return items;
}

- (SyncDataItem *)createSyncItemFromPlist:(plist_t)item_dict dataType:(BackupDataType)dataType index:(uint32_t)index {
    SyncDataItem *item = [[SyncDataItem alloc] init];
    item.dataType = dataType;
    item.isSelected = NO;
    item.recordCount = 1;
    
    // æå–é€šç”¨å­—æ®µ
    [self extractCommonFieldsFromPlist:item_dict toSyncItem:item];
    
    // æ ¹æ®æ•°æ®ç±»å‹æå–ç‰¹å®šå­—æ®µ
    switch (dataType) {
        case BackupDataTypeContacts:
            [self extractContactSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeCalendars:
            [self extractCalendarSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeBookmarks:
            [self extractBookmarkSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeMailAccounts:
            [self extractMailAccountSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeNotes:
            [self extractNoteSpecificFields:item_dict toSyncItem:item];
            break;
        case BackupDataTypeReminders:
            [self extractReminderSpecificFields:item_dict toSyncItem:item];
            break;
        default:
            [self extractGenericFields:item_dict toSyncItem:item];
            break;
    }
    
    // å¦‚æœæ²¡æœ‰æ ‡è¯†ç¬¦ï¼Œä½¿ç”¨ç´¢å¼•
    if (!item.identifier || item.identifier.length == 0) {
        item.identifier = [NSString stringWithFormat:@"%@_%u",
                          [BackupOptionTask stringForDataType:dataType], index];
    }
    
    // å¦‚æœæ²¡æœ‰åç§°ï¼Œä½¿ç”¨é»˜è®¤åç§°
    if (!item.name || item.name.length == 0) {
        item.name = [NSString stringWithFormat:@"%@ Item %u",
                    [BackupOptionTask stringForDataType:dataType], index + 1];
    }
    
    return item;
}

- (void)extractCommonFieldsFromPlist:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    // æå–è®°å½•ID
    plist_t record_id = plist_dict_get_item(item_dict, "RecordID");
    if (record_id) {
        if (plist_get_node_type(record_id) == PLIST_UINT) {
            uint64_t id_val = 0;
            plist_get_uint_val(record_id, &id_val);
            item.identifier = [NSString stringWithFormat:@"%llu", id_val];
        } else if (plist_get_node_type(record_id) == PLIST_STRING) {
            char *id_str = NULL;
            plist_get_string_val(record_id, &id_str);
            if (id_str) {
                item.identifier = [NSString stringWithUTF8String:id_str];
                free(id_str);
            }
        }
    }
    
    // æå–ä¿®æ”¹æ—¶é—´
    plist_t mod_date = plist_dict_get_item(item_dict, "ModificationDate");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "LastModified");
    if (!mod_date) mod_date = plist_dict_get_item(item_dict, "DateModified");
    
    if (mod_date && plist_get_node_type(mod_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(mod_date, &sec, &usec);
        item.modificationDate = [NSDate dateWithTimeIntervalSince1970:sec];
    } else {
        item.modificationDate = [NSDate date];
    }
    
    // ä¼°ç®—æ•°æ®å¤§å°
    char *xml_str = NULL;
    uint32_t xml_length = 0;
    plist_to_xml(item_dict, &xml_str, &xml_length);
    if (xml_str) {
        item.dataSize = xml_length;
        free(xml_str);
    } else {
        item.dataSize = 100; // é»˜è®¤å¤§å°
    }
}

- (void)extractContactSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å§“åå­—æ®µ
    NSArray *nameFields = @[@"DisplayName", @"FirstName", @"LastName", @"CompositeName"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // ç”µè¯å·ç 
    plist_t phones = plist_dict_get_item(item_dict, "Phone");
    if (phones && plist_get_node_type(phones) == PLIST_ARRAY) {
        metadata[@"phoneCount"] = @(plist_array_get_size(phones));
    }
    
    // é‚®ç®±åœ°å€
    plist_t emails = plist_dict_get_item(item_dict, "Email");
    if (emails && plist_get_node_type(emails) == PLIST_ARRAY) {
        metadata[@"emailCount"] = @(plist_array_get_size(emails));
    }
    
    item.metadata = metadata;
}

- (void)extractCalendarSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æ—¥å†æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    if (!title) title = plist_dict_get_item(item_dict, "CalendarName");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å¼€å§‹æ—¶é—´
    plist_t start_date = plist_dict_get_item(item_dict, "StartDate");
    if (start_date && plist_get_node_type(start_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(start_date, &sec, &usec);
        metadata[@"startDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    // ç»“æŸæ—¶é—´
    plist_t end_date = plist_dict_get_item(item_dict, "EndDate");
    if (end_date && plist_get_node_type(end_date) == PLIST_DATE) {
        int32_t sec, usec;
        plist_get_date_val(end_date, &sec, &usec);
        metadata[@"endDate"] = [NSDate dateWithTimeIntervalSince1970:sec];
    }
    
    item.metadata = metadata;
}

- (void)extractBookmarkSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // ä¹¦ç­¾æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "URLString");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // URL
    plist_t url = plist_dict_get_item(item_dict, "URLString");
    if (!url) url = plist_dict_get_item(item_dict, "URL");
    
    if (url && plist_get_node_type(url) == PLIST_STRING) {
        char *url_str = NULL;
        plist_get_string_val(url, &url_str);
        if (url_str) {
            metadata[@"url"] = [NSString stringWithUTF8String:url_str];
            free(url_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractMailAccountSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // è´¦æˆ·åç§°
    plist_t account_name = plist_dict_get_item(item_dict, "AccountName");
    if (!account_name) account_name = plist_dict_get_item(item_dict, "EmailAddress");
    
    if (account_name && plist_get_node_type(account_name) == PLIST_STRING) {
        char *name_str = NULL;
        plist_get_string_val(account_name, &name_str);
        if (name_str) {
            item.name = [NSString stringWithUTF8String:name_str];
            free(name_str);
        }
    }
    
    // æœåŠ¡å™¨ä¿¡æ¯
    plist_t hostname = plist_dict_get_item(item_dict, "Hostname");
    if (hostname && plist_get_node_type(hostname) == PLIST_STRING) {
        char *host_str = NULL;
        plist_get_string_val(hostname, &host_str);
        if (host_str) {
            metadata[@"hostname"] = [NSString stringWithUTF8String:host_str];
            free(host_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractNoteSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å¤‡å¿˜å½•æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Subject");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å†…å®¹
    plist_t content = plist_dict_get_item(item_dict, "Body");
    if (!content) content = plist_dict_get_item(item_dict, "Content");
    
    if (content && plist_get_node_type(content) == PLIST_STRING) {
        char *content_str = NULL;
        plist_get_string_val(content, &content_str);
        if (content_str) {
            NSUInteger contentLength = strlen(content_str);
            metadata[@"contentLength"] = @(contentLength);
            metadata[@"wordCount"] = @(contentLength / 5); // å¤§æ¦‚ä¼°ç®—
            free(content_str);
        }
    }
    
    item.metadata = metadata;
}

- (void)extractReminderSpecificFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // æé†’äº‹é¡¹æ ‡é¢˜
    plist_t title = plist_dict_get_item(item_dict, "Title");
    if (!title) title = plist_dict_get_item(item_dict, "Summary");
    
    if (title && plist_get_node_type(title) == PLIST_STRING) {
        char *title_str = NULL;
        plist_get_string_val(title, &title_str);
        if (title_str) {
            item.name = [NSString stringWithUTF8String:title_str];
            free(title_str);
        }
    }
    
    // å®ŒæˆçŠ¶æ€
    plist_t completed = plist_dict_get_item(item_dict, "Completed");
    if (completed && plist_get_node_type(completed) == PLIST_BOOLEAN) {
        uint8_t is_completed = 0;
        plist_get_bool_val(completed, &is_completed);
        metadata[@"completed"] = @(is_completed ? YES : NO);
    }
    
    // ä¼˜å…ˆçº§
    plist_t priority = plist_dict_get_item(item_dict, "Priority");
    if (priority && plist_get_node_type(priority) == PLIST_UINT) {
        uint64_t priority_val = 0;
        plist_get_uint_val(priority, &priority_val);
        metadata[@"priority"] = @(priority_val);
    }
    
    item.metadata = metadata;
}

- (void)extractGenericFields:(plist_t)item_dict toSyncItem:(SyncDataItem *)item {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    // å°è¯•å„ç§å¯èƒ½çš„åç§°å­—æ®µ
    NSArray *nameFields = @[@"Name", @"Title", @"DisplayName", @"Label", @"Description"];
    for (NSString *field in nameFields) {
        plist_t name_node = plist_dict_get_item(item_dict, [field UTF8String]);
        if (name_node && plist_get_node_type(name_node) == PLIST_STRING) {
            char *name_str = NULL;
            plist_get_string_val(name_node, &name_str);
            if (name_str) {
                item.name = [NSString stringWithUTF8String:name_str];
                free(name_str);
                break;
            }
        }
    }
    
    // æ·»åŠ ä¸€äº›é€šç”¨å…ƒæ•°æ®
    metadata[@"hasRealData"] = @YES;
    metadata[@"source"] = @"device";
    
    item.metadata = metadata;
}

// getDataItemsSimplified æ–¹æ³•
- (NSArray<SyncDataItem *> *)getDataItemsSimplified:(BackupDataType)dataType
                                           syncClass:(NSString *)syncClass
                                               error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"è·å–ç®€åŒ–æ•°æ®é¡¹ - ç±»å‹: %@, åŒæ­¥ç±»: %@",
                     [BackupOptionTask stringForDataType:dataType], syncClass]];
    
    // éªŒè¯å‚æ•°
    if (!syncClass || syncClass.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"åŒæ­¥ç±»å‚æ•°ä¸èƒ½ä¸ºç©º"];
        }
        return @[];
    }
    
    // ç¡®ä¿è®¾å¤‡è¿æ¥
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"è®¾å¤‡æœªè¿æ¥"];
        }
        return @[];
    }
    
    // âœ… å…³é”®ä¿®å¤ï¼šç§»é™¤é‡å¤çš„æ”¯æŒæ£€æŸ¥
    // ä¸Šå±‚ä»£ç å·²ç»é€šè¿‡ getSupportedDataTypes éªŒè¯è¿‡æ”¯æŒæ€§ï¼Œé¿å…é‡å¤æ£€æŸ¥å¯¼è‡´çŠ¶æ€å†²çª
    [self logMessage:[NSString stringWithFormat:@"è·³è¿‡é‡å¤æ”¯æŒæ£€æŸ¥ï¼Œç›´æ¥è·å– %@ æ•°æ®", syncClass]];
    
    // ç›´æ¥è°ƒç”¨æ•°æ®è·å–æ–¹æ³•
    NSArray<SyncDataItem *> *items = [self getGenericDataViaMobileSync:dataType
                                                             syncClass:syncClass
                                                                 error:error];
    
    if (items && items.count > 0) {
        [self logMessage:[NSString stringWithFormat:@"æˆåŠŸè·å– %@ æ•°æ®: %lu é¡¹",
                         syncClass, (unsigned long)items.count]];
    } else {
        [self logMessage:[NSString stringWithFormat:@"%@ æ•°æ®ä¸ºç©ºæˆ–è·å–å¤±è´¥", syncClass]];
    }
    
    return items ?: @[];
}

- (NSArray<SyncDataItem *> *)getGenericDataViaMobileSync:(BackupDataType)dataType
                                               syncClass:(NSString *)syncClass
                                                   error:(NSError **)error {
    
    [self logMessage:[NSString stringWithFormat:@"ä½¿ç”¨ä¿®å¤ç‰ˆè·å– %@ æ•°æ®", syncClass]];
    
    if (![self isConnected]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                             description:@"Not connected to device"];
        }
        return @[];
    }
    
    // æ·»åŠ è®¾å¤‡å…¼å®¹æ€§æ£€æŸ¥
    [self checkDeviceCompatibilityForSync];
    
    @try {
        // âœ… å…³é”®ä¿®å¤ï¼šæ¯æ¬¡æ•°æ®è·å–å‰éƒ½é‡æ–°å»ºç«‹ MobileSync è¿æ¥
        [self logMessage:@"é‡æ–°å»ºç«‹ MobileSync è¿æ¥ä»¥ç¡®ä¿æ•°æ®è·å–ç¨³å®šæ€§"];
        
        // å¼ºåˆ¶æ–­å¼€å¹¶é‡å»º MobileSync è¿æ¥
        if (_mobilesync) {
            mobilesync_client_free(_mobilesync);
            _mobilesync = NULL;
        }
        
        // çŸ­æš‚ç­‰å¾…ï¼Œè®©è®¾å¤‡é‡ç½®çŠ¶æ€
        [NSThread sleepForTimeInterval:0.5];
        
        // é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡
        NSError *serviceError = nil;
        if (![self startMobileSyncService:&serviceError]) {
            [self logMessage:[NSString stringWithFormat:@"[WAR] é‡æ–°å¯åŠ¨ MobileSync æœåŠ¡å¤±è´¥: %@", serviceError.localizedDescription]];
            if (error) *error = serviceError;
            return @[];
        }
        
        [self logMessage:@"MobileSync è¿æ¥å·²é‡æ–°å»ºç«‹"];
        
        // âœ… å…³é”®ä¿®å¤2ï¼šä½¿ç”¨ä¸æ£€æµ‹æ—¶ç›¸åŒçš„å‚æ•°
        mobilesync_anchors_t anchors = mobilesync_anchors_new("", "");
        if (!anchors) {
            [self logMessage:@"[ERR] åˆ›å»ºanchorså¤±è´¥"];
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                                 description:@"Failed to create mobilesync anchors"];
            }
            return @[];
        }
        
        // âœ… å…³é”®ä¿®å¤3ï¼šä½¿ç”¨æ£€æµ‹æ—¶å®Œå…¨ç›¸åŒçš„å‚æ•°
        uint64_t data_class_version = 106;  // ä¸æ£€æµ‹æ—¶ä¿æŒä¸€è‡´
        mobilesync_sync_type_t sync_type = MOBILESYNC_SYNC_TYPE_FAST;
        uint64_t device_data_class_version = 0;
        char *error_description = NULL;
        
        [self logMessage:[NSString stringWithFormat:@"ä½¿ç”¨å¹²å‡€è¿æ¥å¯åŠ¨åŒæ­¥ä¼šè¯: %@", syncClass]];
        
        // âœ… å…³é”®ä¿®å¤4ï¼šå¯åŠ¨åŒæ­¥ä¼šè¯
        mobilesync_error_t start_err = mobilesync_start(_mobilesync,
                                                      [syncClass UTF8String],
                                                      anchors,
                                                      data_class_version,
                                                      &sync_type,
                                                      &device_data_class_version,
                                                      &error_description);
        
        NSMutableArray<SyncDataItem *> *allItems = [NSMutableArray array];
        
        if (start_err == MOBILESYNC_E_SUCCESS) {
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥ä¼šè¯å¯åŠ¨æˆåŠŸï¼ˆå¹²å‡€è¿æ¥ï¼‰", syncClass]];
            
            // âœ… ä½¿ç”¨æ›´ç¨³å®šçš„æ•°æ®è·å–æ–¹æ³•
            mobilesync_error_t get_all_err = mobilesync_get_all_records_from_device(_mobilesync);
            
            if (get_all_err == MOBILESYNC_E_SUCCESS) {
                [self logMessage:[NSString stringWithFormat:@"æˆåŠŸè¯·æ±‚ %@ çš„æ‰€æœ‰è®°å½•", syncClass]];
                
                // âœ… æ”¹è¿›çš„æ•°æ®æ¥æ”¶é€»è¾‘ - å¤„ç†è¶…æ—¶å’Œå¤šæ‰¹æ¬¡æ•°æ®
                plist_t entities = NULL;
                uint8_t is_last_record = 0;
                plist_t actions = NULL;
                
                int batchCount = 0;
                int maxBatches = 5; // å‡å°‘æœ€å¤§æ‰¹æ¬¡æ•°é‡
                int timeoutCount = 0;
                int maxTimeouts = 2; // å…è®¸çš„æœ€å¤§è¶…æ—¶æ¬¡æ•°
                
                do {
                    mobilesync_error_t receive_err = mobilesync_receive_changes(_mobilesync,
                                                                             &entities,
                                                                             &is_last_record,
                                                                             &actions);
                    
                    [self logMessage:[NSString stringWithFormat:@"mobilesync_receive_changes è¿”å›çŠ¶æ€: %d (æ‰¹æ¬¡ %d)",
                                     receive_err, batchCount + 1]];
                    
                    if (receive_err == MOBILESYNC_E_SUCCESS) {
                        // é‡ç½®è¶…æ—¶è®¡æ•°å™¨
                        timeoutCount = 0;
                        
                        if (entities) {
                            batchCount++;
                            [self logMessage:[NSString stringWithFormat:@"å¤„ç† %@ ç¬¬ %d æ‰¹æ•°æ®",
                                            syncClass, batchCount]];
                            
                            // ğŸ” è¯¦ç»†åˆ†ææ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹
                            plist_type received_type = plist_get_node_type(entities);
                            NSString *typeDescription = [self stringForPlistType:received_type];
                            
                            [self logMessage:[NSString stringWithFormat:@"æ¥æ”¶åˆ°çš„æ•°æ®ç±»å‹: %@ (%d)",
                                             typeDescription, received_type]];
                            
                            // ğŸ”§ æ”¹è¿›çš„æ•°æ®å¤„ç†ï¼šæ”¯æŒå¤šç§æ•°æ®ç±»å‹
                            NSArray<SyncDataItem *> *batchItems = [self processRealDataForType:dataType
                                                                                     dataArray:entities
                                                                                     syncClass:syncClass];
                            
                            if (batchItems && batchItems.count > 0) {
                                [allItems addObjectsFromArray:batchItems];
                                [self logMessage:[NSString stringWithFormat:@"ä»ç¬¬ %d æ‰¹è·å–åˆ° %lu é¡¹æ•°æ®",
                                               batchCount, (unsigned long)batchItems.count]];
                            } else {
                                [self logMessage:[NSString stringWithFormat:@"ç¬¬ %d æ‰¹æ•°æ®ä¸ºç©ºæˆ–å¤„ç†å¤±è´¥", batchCount]];
                            }
                            
                            // æ¸…ç†resources
                            plist_free(entities);
                            entities = NULL;
                        } else {
                            [self logMessage:[NSString stringWithFormat:@"ç¬¬ %d æ‰¹ %@ è¿”å›ç©ºæ•°æ®", batchCount + 1, syncClass]];
                        }
                        
                        if (actions) {
                            plist_free(actions);
                            actions = NULL;
                        }
                        
                    } else if (receive_err == MOBILESYNC_E_RECEIVE_TIMEOUT) {
                        // ğŸ”§ æ”¹è¿›çš„è¶…æ—¶å¤„ç†
                        timeoutCount++;
                        [self logMessage:[NSString stringWithFormat:@"%@ æ¥æ”¶è¶…æ—¶ (ç¬¬ %d æ¬¡ï¼Œå…± %d æ¬¡)",
                                        syncClass, timeoutCount, maxTimeouts]];
                        
                        if (timeoutCount >= maxTimeouts) {
                            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ è¶…æ—¶æ¬¡æ•°è¾¾åˆ°ä¸Šé™ï¼Œåœæ­¢æ¥æ”¶", syncClass]];
                            break;
                        }
                        
                        // å¦‚æœå·²ç»è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸çš„ç»“æŸä¿¡å·
                        if (allItems.count > 0) {
                            [self logMessage:[NSString stringWithFormat:@"%@ å·²è·å–åˆ°æ•°æ®ï¼Œè¶…æ—¶å¯èƒ½æ˜¯æ­£å¸¸ç»“æŸ", syncClass]];
                            break;
                        }
                        
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[ERR] æ¥æ”¶ %@ æ•°æ®æ—¶å‡ºé”™: %d",
                                        syncClass, receive_err]];
                        break;
                    }
                    
                    // é˜²æ­¢æ— é™å¾ªç¯
                    if (batchCount >= maxBatches) {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ è¾¾åˆ°æœ€å¤§æ‰¹æ¬¡é™åˆ¶(%d)ï¼Œåœæ­¢æ¥æ”¶",
                                        syncClass, maxBatches]];
                        break;
                    }
                    
                    // å¦‚æœæ ‡è®°ä¸ºæœ€åä¸€æ¡è®°å½•ï¼Œç›´æ¥é€€å‡º
                    if (is_last_record) {
                        [self logMessage:[NSString stringWithFormat:@"%@ æ¥æ”¶åˆ°æœ€åè®°å½•æ ‡è®°ï¼Œæ­£å¸¸ç»“æŸ", syncClass]];
                        break;
                    }
                    
                    // æ·»åŠ å°å»¶è¿Ÿï¼Œé¿å…è¿‡åº¦è¯·æ±‚
                    [NSThread sleepForTimeInterval:0.1];
                    
                } while (YES); // ä½¿ç”¨å†…éƒ¨é€»è¾‘æ§åˆ¶å¾ªç¯
                
                [self logMessage:[NSString stringWithFormat:@"%@ æ•°æ®æ¥æ”¶å®Œæˆ: %d æ‰¹æ¬¡, %lu é¡¹",
                                syncClass, batchCount, (unsigned long)allItems.count]];
                
            } else {
                [self logMessage:[NSString stringWithFormat:@"[WAR] %@ get_all_recordså¤±è´¥: %d",
                                syncClass, get_all_err]];
            }
            
            // âœ… ç¡®ä¿ä¼šè¯æ­£ç¡®ç»“æŸ
            mobilesync_finish(_mobilesync);
            [self logMessage:[NSString stringWithFormat:@"%@ åŒæ­¥ä¼šè¯å·²ç»“æŸ", syncClass]];
            
        } else {
            [self logMessage:[NSString stringWithFormat:@"[WAR] %@ mobilesync_startå¤±è´¥ï¼ˆå¹²å‡€è¿æ¥åï¼‰: %d",
                            syncClass, start_err]];
            
            if (error_description) {
                [self logMessage:[NSString stringWithFormat:@"é”™è¯¯è¯¦æƒ…: %s", error_description]];
            }
        }
        
        // æ¸…ç†èµ„æº
        if (error_description) {
            free(error_description);
        }
        mobilesync_anchors_free(anchors);
        
        // âœ… å³ä½¿æ²¡æœ‰è·å–åˆ°æ•°æ®ä¹Ÿä¸ç®—é”™è¯¯
        if (allItems.count == 0) {
            [self logMessage:[NSString stringWithFormat:@"%@ æ²¡æœ‰å¯ç”¨æ•°æ®ï¼ˆä½¿ç”¨å¹²å‡€è¿æ¥åç¡®è®¤ï¼‰", syncClass]];
        }
        
        [self logMessage:[NSString stringWithFormat:@"%@ æœ€ç»ˆè·å–åˆ° %lu é¡¹çœŸå®æ•°æ®ï¼ˆå¹²å‡€è¿æ¥ï¼‰",
                         syncClass, (unsigned long)allItems.count]];
        return allItems;
        
    } @catch (NSException *exception) {
        [self logMessage:[NSString stringWithFormat:@"[WAR] %@ æ•°æ®è·å–å¼‚å¸¸: %@", syncClass, exception.reason]];
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeOperationFailed
                             description:[NSString stringWithFormat:@"Exception during %@ sync: %@",
                                        syncClass, exception.reason]];
        }
        return @[];
    }
}

#pragma mark - éªŒè¯å’Œé”™è¯¯å¤„ç†

- (BOOL)validateReceivedData:(plist_t)data_array forDataType:(BackupDataType)dataType {
    if (!data_array) {
        [self logMessage:[NSString stringWithFormat:@"No data received for type: %@",
                         [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    plist_type type = plist_get_node_type(data_array);
    
    // å¢å¼ºçš„ç±»å‹æ£€æŸ¥å’Œæ—¥å¿—
    NSString *typeDescription = [self stringForPlistType:type];
    [self logMessage:[NSString stringWithFormat:@"Received data type: %@ (%d) for: %@",
                     typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
    
    // å¦‚æœä¸æ˜¯æ•°ç»„ï¼Œå°è¯•å¤„ç†å…¶ä»–å¯èƒ½çš„ç±»å‹
    if (type != PLIST_ARRAY) {
        if (type == PLIST_BOOLEAN) {
            // å¯èƒ½è¡¨ç¤ºæ²¡æœ‰æ•°æ®æˆ–æ“ä½œå¤±è´¥
            uint8_t bool_val = 0;
            plist_get_bool_val(data_array, &bool_val);
            [self logMessage:[NSString stringWithFormat:@"Received boolean value: %s for: %@",
                             bool_val ? "true" : "false", [BackupOptionTask stringForDataType:dataType]]];
            return bool_val; // å¦‚æœæ˜¯trueï¼Œå¯èƒ½è¡¨ç¤ºæˆåŠŸä½†æ— æ•°æ®
        }
        
        [self logMessage:[NSString stringWithFormat:@"[WAR] Unexpected data type %@ (%d), expected array for: %@",
                         typeDescription, type, [BackupOptionTask stringForDataType:dataType]]];
        return NO;
    }
    
    uint32_t count = plist_array_get_size(data_array);
    [self logMessage:[NSString stringWithFormat:@"Received %u items for type: %@",
                     count, [BackupOptionTask stringForDataType:dataType]]];
    
    return YES;
}

- (void)handleSyncError:(mobilesync_error_t)error forDataType:(BackupDataType)dataType operation:(NSString *)operation {
    NSString *errorMessage = [NSString stringWithFormat:@"Sync error %d during %@ for %@",
                             error, operation, [BackupOptionTask stringForDataType:dataType]];
    [self logMessage:errorMessage];
    
    // æ ¹æ®é”™è¯¯ç±»å‹é‡‡å–ä¸åŒçš„å¤„ç†ç­–ç•¥
    switch (error) {
        case MOBILESYNC_E_INVALID_ARG:
            [self logMessage:@"Invalid argument - check sync class name and parameters"];
            break;
        case MOBILESYNC_E_PLIST_ERROR:
            [self logMessage:@"Plist parsing error - data format issue"];
            break;
        case MOBILESYNC_E_MUX_ERROR:
            [self logMessage:@"Connection error - device may have disconnected"];
            break;
        case MOBILESYNC_E_SSL_ERROR:
            [self logMessage:@"SSL error - secure connection failed"];
            break;
        case MOBILESYNC_E_RECEIVE_TIMEOUT:
            [self logMessage:@"Receive timeout - device not responding"];
            break;
        case MOBILESYNC_E_BAD_VERSION:
            [self logMessage:@"Version mismatch - sync protocol version not supported"];
            break;
        default:
            [self logMessage:[NSString stringWithFormat:@"Unknown sync error: %d", error]];
            break;
    }
}

- (BOOL)ensureDeviceConnection:(NSError **)error {
    if (![self isConnected]) {
        [self logMessage:@"Device not connected, attempting to reconnect..."];
        
        if (!_deviceUDID || _deviceUDID.length == 0) {
            if (error) {
                *error = [self errorWithCode:BackupOptionTaskErrorCodeConnectionFailed
                                 description:@"No device UDID available for reconnection"];
            }
            return NO;
        }
        
        // å°è¯•é‡æ–°è¿æ¥
        return [self connectToDeviceInternal:_deviceUDID error:error];
    }
    
    return YES;
}

- (BOOL)canSyncDataType:(BackupDataType)dataType error:(NSError **)error {
    if (![self ensureDeviceConnection:error]) {
        return NO;
    }
    
    NSString *syncClass = DataTypeToSyncClassMap()[@(dataType)];
    if (!syncClass) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:[NSString stringWithFormat:@"Unsupported data type: %@",
                                        [BackupOptionTask stringForDataType:dataType]]];
        }
        return NO;
    }
    
    // å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æ”¯æŒæ­¤æ•°æ®ç±»å‹
    return [self isDataTypeSupported:dataType];
}

- (BOOL)validatePhotoFile:(NSString *)photoPath error:(NSError **)error {
    if (!photoPath || photoPath.length == 0) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodeInvalidArg
                             description:@"Photo path cannot be empty"];
        }
        return NO;
    }
    
    NSString *filename = [photoPath lastPathComponent];
    if (![self isPhotoFile:filename] && ![self isVideoFile:filename]) {
        if (error) {
            *error = [self errorWithCode:BackupOptionTaskErrorCodePhotoFormatUnsupported
                             description:[NSString stringWithFormat:@"Unsupported file format: %@", filename]];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - ç§æœ‰æ–¹æ³•å®ç°

- (NSError *)errorWithCode:(BackupOptionTaskErrorCode)code description:(NSString *)description {
    [self logMessage:[NSString stringWithFormat:@"Error: %ld - %@", (long)code, description]];
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description ?: @"Unknown error"
    };
    
    _lastError = [NSError errorWithDomain:kBackupOptionTaskErrorDomain code:code userInfo:userInfo];
    return _lastError;
}

- (void)setInternalStatus:(SyncTaskStatus)status {
    if (_status != status) {
        [self logMessage:[NSString stringWithFormat:@"Status changed: %lu -> %lu", (unsigned long)_status, (unsigned long)status]];
        _status = status;
        
        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.statusCallback) {
                NSString *description = [self stringForStatus:status];
                self.statusCallback(status, description);
            }
        });
    }
}

- (NSString *)stringForStatus:(SyncTaskStatus)status {
    switch (status) {
        case SyncTaskStatusIdle:
            return @"Idle";
        case SyncTaskStatusConnecting:
            return @"Connecting to device";
        case SyncTaskStatusPreparing:
            return @"Preparing sync operation";
        case SyncTaskStatusSyncing:
            return @"Syncing data";
        case SyncTaskStatusCompleted:
            return @"Sync completed";
        case SyncTaskStatusFailed:
            return @"Sync failed";
        case SyncTaskStatusCancelled:
            return @"Sync cancelled";
        case SyncTaskStatusPaused:
            return @"Sync paused";
        case SyncTaskStatusScanningPhotos:
            return @"Scanning photos";
        case SyncTaskStatusDownloadingPhotos:
            return @"Downloading photos";
        case SyncTaskStatusProcessingMetadata:
            return @"Processing metadata";
        case SyncTaskStatusGeneratingThumbnails:
            return @"Generating thumbnails";
    }
    return @"Unknown status";
}

- (void)updateProgress:(float)progress operation:(NSString *)operation current:(NSUInteger)current total:(NSUInteger)total {
    _progress = progress;
    
    [self logMessage:[NSString stringWithFormat:@"Progress: %.2f%% - %@ (%lu/%lu)",
                     progress, operation ?: @"", (unsigned long)current, (unsigned long)total]];
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.progressCallback) {
            self.progressCallback(progress, operation, current, total);
        }
    });
}

#pragma mark - å·¥å…·æ–¹æ³•

- (void)logMessage:(NSString *)message {
    NSString *logMessage = [NSString stringWithFormat:@"%@", message];
    NSLog(@"%@", logMessage);
    
    if (self.logCallback) {
        dispatch_async(dispatch_get_main_queue(), ^{
            self.logCallback(logMessage);
        });
    }
}

- (NSString *)formatFileSize:(NSUInteger)bytes {
    if (bytes == 0) return @"0 B";
    
    NSByteCountFormatter *formatter = [[NSByteCountFormatter alloc] init];
    formatter.countStyle = NSByteCountFormatterCountStyleFile;
    formatter.allowedUnits = NSByteCountFormatterUseAll;
    return [formatter stringFromByteCount:(long long)bytes];
}

- (NSString *)getCurrentTimestamp {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    return [formatter stringFromDate:[NSDate date]];
}

- (NSUInteger)calculateDirectorySize:(NSString *)dirPath {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:dirPath];
    NSUInteger totalSize = 0;
    
    NSString *filePath;
    while ((filePath = [enumerator nextObject])) {
        NSString *fullPath = [dirPath stringByAppendingPathComponent:filePath];
        NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:fullPath error:nil];
        if (fileAttributes) {
            totalSize += [fileAttributes[NSFileSize] unsignedIntegerValue];
        }
    }
    
    return totalSize;
}

- (NSString *)stringForPlistType:(plist_type)type {
    switch (type) {
        case PLIST_BOOLEAN: return @"BOOLEAN";
        case PLIST_UINT: return @"UINT";
        case PLIST_REAL: return @"REAL";
        case PLIST_STRING: return @"STRING";
        case PLIST_ARRAY: return @"ARRAY";
        case PLIST_DICT: return @"DICT";
        case PLIST_DATE: return @"DATE";
        case PLIST_DATA: return @"DATA";
        case PLIST_KEY: return @"KEY";
        case PLIST_UID: return @"UID";
        default: return [NSString stringWithFormat:@"UNKNOWN(%d)", type];
    }
}

- (NSString *)sanitizeFilename:(NSString *)filename {
    NSMutableString *sanitized = [filename mutableCopy];
    NSArray *invalidChars = @[@"/", @"\\", @":", @"*", @"?", @"\"", @"<", @">", @"|"];
    
    for (NSString *invalidChar in invalidChars) {
        [sanitized replaceOccurrencesOfString:invalidChar
                                   withString:@"_"
                                      options:NSLiteralSearch
                                        range:NSMakeRange(0, sanitized.length)];
    }
    
    return [sanitized copy];
}

- (NSString *)generateThumbnailPath:(NSString *)originalPath {
    NSString *directory = [[originalPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"Thumbnails"];
    NSString *filename = [originalPath lastPathComponent];
    NSString *nameWithoutExt = [filename stringByDeletingPathExtension];
    NSString *extension = [filename pathExtension];
    
    NSString *thumbnailFilename = [NSString stringWithFormat:@"%@_thumb.%@", nameWithoutExt, extension];
    return [directory stringByAppendingPathComponent:thumbnailFilename];
}

- (BOOL)createThumbnail:(NSString *)sourcePath destinationPath:(NSString *)destPath maxSize:(NSUInteger)maxSize {
    // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ç¼©ç•¥å›¾ç”Ÿæˆå®ç°
    // åœ¨çœŸå®åº”ç”¨ä¸­ï¼Œä½ éœ€è¦ä½¿ç”¨å›¾åƒå¤„ç†åº“ï¼ˆå¦‚CoreGraphicsã€ImageIOç­‰ï¼‰
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // åˆ›å»ºç›®å½•
    NSString *destDir = [destPath stringByDeletingLastPathComponent];
    [fileManager createDirectoryAtPath:destDir withIntermediateDirectories:YES attributes:nil error:nil];
    
    // ç®€å•çš„æ–‡ä»¶å¤åˆ¶ä½œä¸ºå ä½ç¬¦
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥è¿›è¡Œå›¾åƒç¼©æ”¾
    NSError *error = nil;
    BOOL success = [fileManager copyItemAtPath:sourcePath toPath:destPath error:&error];
    
    if (!success) {
        [self logMessage:[NSString stringWithFormat:@"Failed to create thumbnail: %@", error.localizedDescription]];
    }
    
    return success;
}

// ğŸ†• å®‰å…¨çš„å­—ç¬¦ä¸²è½¬æ— ç¬¦å·é•¿é•¿æ•´å‹æ–¹æ³•
- (unsigned long long)unsignedLongLongValueFromString:(NSString *)string {
    if (!string || string.length == 0) {
        return 0;
    }
    
    // æ–¹æ³•1: ä½¿ç”¨Cå‡½æ•°strtoullï¼ˆæ¨èï¼‰
    const char *cString = [string UTF8String];
    char *endPtr = NULL;
    unsigned long long result = strtoull(cString, &endPtr, 10);
    
    // å¦‚æœè½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
    if (endPtr == cString) {
        // æ–¹æ³•2: ä½¿ç”¨NSScannerä½œä¸ºå¤‡ç”¨
        NSScanner *scanner = [NSScanner scannerWithString:string];
        unsigned long long scannerResult = 0;
        if ([scanner scanUnsignedLongLong:&scannerResult]) {
            return scannerResult;
        }
        
        // æ–¹æ³•3: æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼Œä½¿ç”¨longLongValue
        long long signedValue = [string longLongValue];
        return (unsigned long long)MAX(0, signedValue);
    }
    
    return result;
}

- (void)checkDeviceCompatibilityForSync {
    if (![self isConnected] || !_lockdown) {
        [self logMessage:@"è®¾å¤‡æœªè¿æ¥æˆ–lockdownæœªåˆå§‹åŒ–"];
        return;
    }
    
    // ä¿®å¤1ï¼šæ­£ç¡®è·å–è®¾å¤‡åç§°
    char *device_name = NULL;
    lockdownd_error_t ret = lockdownd_get_device_name(_lockdown, &device_name);
    if (ret == LOCKDOWN_E_SUCCESS && device_name) {
        [self logMessage:[NSString stringWithFormat:@"è®¾å¤‡åç§°: %s", device_name]];
        free(device_name);
    } else {
        [self logMessage:[NSString stringWithFormat:@"è·å–è®¾å¤‡åç§°å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤2ï¼šæ­£ç¡®è·å–iOSç‰ˆæœ¬
    plist_t version_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductVersion", &version_plist);
    if (ret == LOCKDOWN_E_SUCCESS && version_plist) {
        if (plist_get_node_type(version_plist) == PLIST_STRING) {
            char *version_str = NULL;
            plist_get_string_val(version_plist, &version_str);
            if (version_str) {
                [self logMessage:[NSString stringWithFormat:@"iOSç‰ˆæœ¬: %s", version_str]];
                
                NSString *versionStr = [NSString stringWithUTF8String:version_str];
                NSArray *versionComponents = [versionStr componentsSeparatedByString:@"."];
                
                if (versionComponents.count > 0) {
                    NSInteger majorVersion = [versionComponents[0] integerValue];
                    
                    if (majorVersion < 9) {
                        [self logMessage:@"[WAR] iOSç‰ˆæœ¬è¿‡ä½ï¼Œå¯èƒ½ä¸æ”¯æŒé€‰æ‹©æ€§åŒæ­¥"];
                    } else if (majorVersion >= 15) {
                        [self logMessage:@"[WAR] iOS 15+è®¾å¤‡ï¼Œæ•°æ®æ ¼å¼å¯èƒ½æœ‰å˜åŒ–"];
                    } else {
                        [self logMessage:[NSString stringWithFormat:@"[WAR] iOS %ld è®¾å¤‡ï¼Œå…¼å®¹æ€§è‰¯å¥½", (long)majorVersion]];
                    }
                }
                
                free(version_str);
            }
        }
        plist_free(version_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"[WAR] è·å–iOSç‰ˆæœ¬å¤±è´¥: %d", ret]];
    }
    
    // ä¿®å¤3ï¼šæ­£ç¡®è·å–è®¾å¤‡å‹å·
    plist_t type_plist = NULL;
    ret = lockdownd_get_value(_lockdown, NULL, "ProductType", &type_plist);
    if (ret == LOCKDOWN_E_SUCCESS && type_plist) {
        if (plist_get_node_type(type_plist) == PLIST_STRING) {
            char *type_str = NULL;
            plist_get_string_val(type_plist, &type_str);
            if (type_str) {
                [self logMessage:[NSString stringWithFormat:@"è®¾å¤‡å‹å·: %s", type_str]];
                free(type_str);
            }
        }
        plist_free(type_plist);
    } else {
        [self logMessage:[NSString stringWithFormat:@"è·å–è®¾å¤‡å‹å·å¤±è´¥: %d", ret]];
    }
}

@end


//
//  BackupOptionTask.h
//  iOSBackupManager
//
//  Complete Enhanced Version with Photos/Camera Support - 2025.01.27
//  Based on libimobiledevice mobilesync and AFC APIs
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// æ•°æ®ç±»å‹æšä¸¾ - å®Œæ•´ç‰ˆæœ¬ï¼ŒåŒ…å«ç…§ç‰‡å’Œåª’ä½“æ”¯æŒ
typedef NS_OPTIONS(NSUInteger, BackupDataType) {
    BackupDataTypeNone          = 0,
    BackupDataTypeContacts      = 1 << 0,  // è”ç³»äºº
    BackupDataTypeCalendars     = 1 << 1,  // æ—¥å†
    BackupDataTypeBookmarks     = 1 << 2,  // ä¹¦ç­¾
    BackupDataTypeNotes         = 1 << 3,  // å¤‡å¿˜å½•
    BackupDataTypeReminders     = 1 << 4,  // æé†’äº‹é¡¹
    BackupDataTypeApplications  = 1 << 5,  // åº”ç”¨æ•°æ®
    BackupDataTypeConfiguration = 1 << 6,  // ç³»ç»Ÿé…ç½®
    BackupDataTypeKeychain      = 1 << 7,  // é’¥åŒ™ä¸²
    BackupDataTypeVoiceMemos    = 1 << 8,  // è¯­éŸ³å¤‡å¿˜å½•
    BackupDataTypeWallpaper     = 1 << 9,  // å£çº¸è®¾ç½®
    BackupDataTypeMailAccounts  = 1 << 10, // é‚®ç®±è®¾ç½®
    
    // ğŸ†• æ–°å¢ç…§ç‰‡å’Œåª’ä½“ç›¸å…³æ•°æ®ç±»å‹
    BackupDataTypePhotos        = 1 << 11, // ç…§ç‰‡åº“
    BackupDataTypeVideos        = 1 << 12, // è§†é¢‘åº“
    BackupDataTypeCameraRoll    = 1 << 13, // ç›¸æœºèƒ¶å·
    BackupDataTypePhotoAlbums   = 1 << 14, // ç›¸å†Œ
    BackupDataTypePhotoStream   = 1 << 15, // ç…§ç‰‡æµ
    BackupDataTypeScreenshots   = 1 << 16, // æˆªå±
    BackupDataTypeSlowMotion    = 1 << 17, // æ…¢åŠ¨ä½œè§†é¢‘
    BackupDataTypeTimelapses    = 1 << 18, // å»¶æ—¶æ‘„å½±
    BackupDataTypeBurstPhotos   = 1 << 19, // è¿æ‹ç…§ç‰‡
    BackupDataTypeLivePhotos    = 1 << 20, // Live Photos
    
    // ä¾¿æ·ç»„åˆ
    BackupDataTypeAllPhotos     = (BackupDataTypePhotos | BackupDataTypeVideos | BackupDataTypeCameraRoll |
                                  BackupDataTypePhotoAlbums | BackupDataTypePhotoStream | BackupDataTypeScreenshots |
                                  BackupDataTypeSlowMotion | BackupDataTypeTimelapses | BackupDataTypeBurstPhotos |
                                  BackupDataTypeLivePhotos),
    BackupDataTypeAll           = NSUIntegerMax  // æ‰€æœ‰æ”¯æŒçš„æ•°æ®ç±»å‹
};

// åŒæ­¥æ–¹å‘æšä¸¾
typedef NS_ENUM(NSUInteger, SyncDirection) {
    SyncDirectionFromDevice,    // ä»è®¾å¤‡åˆ°è®¡ç®—æœºï¼ˆå¤‡ä»½ï¼‰
    SyncDirectionToDevice,      // ä»è®¡ç®—æœºåˆ°è®¾å¤‡ï¼ˆæ¢å¤ï¼‰
    SyncDirectionBidirectional  // åŒå‘åŒæ­¥
};

// ğŸ†• ç…§ç‰‡ä¼ è¾“æ¨¡å¼æšä¸¾
typedef NS_ENUM(NSUInteger, PhotoTransferMode) {
    PhotoTransferModeOriginal,      // åŸå§‹è´¨é‡
    PhotoTransferModeOptimized,     // ä¼˜åŒ–è´¨é‡ï¼ˆè¾ƒå°æ–‡ä»¶ï¼‰
    PhotoTransferModeThumbnail,     // ä»…ç¼©ç•¥å›¾
    PhotoTransferModeMetadataOnly   // ä»…å…ƒæ•°æ®
};

// é”™è¯¯ä»£ç 
typedef NS_ENUM(NSInteger, BackupOptionTaskErrorCode) {
    BackupOptionTaskErrorCodeSuccess = 0,
    BackupOptionTaskErrorCodeUnknown = -1,
    BackupOptionTaskErrorCodeInvalidArg = -2,
    BackupOptionTaskErrorCodeConnectionFailed = -3,
    BackupOptionTaskErrorCodeOperationFailed = -4,
    BackupOptionTaskErrorCodeDeviceNotFound = -5,
    BackupOptionTaskErrorCodeServiceStartFailed = -6,
    BackupOptionTaskErrorCodeProtocolError = -7,
    BackupOptionTaskErrorCodeUserCancelled = -8,
    BackupOptionTaskErrorCodeDataCorrupted = -9,
    BackupOptionTaskErrorCodePermissionDenied = -10,
    BackupOptionTaskErrorCodeSyncConflict = -11,
    BackupOptionTaskErrorCodeDeviceLocked = -12,
    BackupOptionTaskErrorCodeTimeoutError = -13,
    
    // ğŸ†• ç…§ç‰‡ç›¸å…³é”™è¯¯
    BackupOptionTaskErrorCodePhotoLibraryLocked = -20,
    BackupOptionTaskErrorCodeInsufficientStorage = -21,
    BackupOptionTaskErrorCodePhotoFormatUnsupported = -22,
    BackupOptionTaskErrorCodePhotoCorrupted = -23,
    BackupOptionTaskErrorCodeAFCServiceFailed = -24
};

// åŒæ­¥çŠ¶æ€æšä¸¾
typedef NS_ENUM(NSUInteger, SyncTaskStatus) {
    SyncTaskStatusIdle,
    SyncTaskStatusConnecting,
    SyncTaskStatusPreparing,
    SyncTaskStatusSyncing,
    SyncTaskStatusCompleted,
    SyncTaskStatusFailed,
    SyncTaskStatusCancelled,
    SyncTaskStatusPaused,
    
    // ğŸ†• ç…§ç‰‡ç›¸å…³çŠ¶æ€
    SyncTaskStatusScanningPhotos,
    SyncTaskStatusDownloadingPhotos,
    SyncTaskStatusProcessingMetadata,
    SyncTaskStatusGeneratingThumbnails
};



// æšä¸¾åæ·»åŠ æ–°çš„è¿æ¥èƒ½åŠ›æšä¸¾
typedef NS_ENUM(NSUInteger, DeviceConnectionCapability) {
    DeviceConnectionCapabilityNone = 0,
    DeviceConnectionCapabilityMobileSync = 1 << 0,  // æ”¯æŒä¼ ç»Ÿæ•°æ®(Contacts, Calendars, etc.)
    DeviceConnectionCapabilityAFC = 1 << 1,         // æ”¯æŒç…§ç‰‡æ•°æ®
    DeviceConnectionCapabilityFull = DeviceConnectionCapabilityMobileSync | DeviceConnectionCapabilityAFC
};

// ğŸ†• ç…§ç‰‡ä¿¡æ¯ç»“æ„
@interface PhotoInfo : NSObject
@property (nonatomic, strong) NSString *filename;
@property (nonatomic, strong) NSString *photoID;
@property (nonatomic, strong) NSString *albumName;
@property (nonatomic, strong) NSDate *dateCreated;
@property (nonatomic, strong) NSDate *dateModified;
@property (nonatomic, assign) NSUInteger fileSize;
@property (nonatomic, assign) NSUInteger width;
@property (nonatomic, assign) NSUInteger height;
@property (nonatomic, strong) NSString *format; // HEIF, JPEG, PNG, etc.
@property (nonatomic, assign) BOOL isVideo;
@property (nonatomic, assign) BOOL isLivePhoto;
@property (nonatomic, assign) BOOL isBurst;
@property (nonatomic, assign) BOOL isScreenshot;
@property (nonatomic, assign) BOOL isFavorite;
@property (nonatomic, assign) NSTimeInterval videoDuration; // ä»…è§†é¢‘
@property (nonatomic, strong, nullable) NSDictionary *exifData; // EXIFæ•°æ®
@property (nonatomic, strong, nullable) NSDictionary *locationData; // GPSä½ç½®ä¿¡æ¯
@end

// æ•°æ®é¡¹ä¿¡æ¯ç»“æ„ - å¢å¼ºç‰ˆæœ¬
@interface SyncDataItem : NSObject
@property (nonatomic, strong) NSString *identifier;
@property (nonatomic, strong) NSString *name;
@property (nonatomic, assign) BackupDataType dataType;
@property (nonatomic, strong) NSDate *modificationDate;
@property (nonatomic, assign) NSUInteger recordCount;
@property (nonatomic, assign) NSUInteger dataSize;
@property (nonatomic, assign) BOOL isSelected;
@property (nonatomic, strong, nullable) NSDictionary *metadata; // é¢å¤–çš„å…ƒæ•°æ®

// ğŸ†• ç…§ç‰‡ç›¸å…³å±æ€§
@property (nonatomic, strong, nullable) PhotoInfo *photoInfo;
@property (nonatomic, strong, nullable) NSString *localPath;  // æœ¬åœ°å­˜å‚¨è·¯å¾„
@property (nonatomic, strong, nullable) NSString *remotePath; // è®¾å¤‡ä¸Šçš„è·¯å¾„
@property (nonatomic, assign) BOOL isMediaFile; // æ˜¯å¦ä¸ºåª’ä½“æ–‡ä»¶
@end

// å‰å‘å£°æ˜
@class BackupOptionTask;

// è¿›åº¦å›è°ƒå—å®šä¹‰
typedef void (^SyncProgressCallback)(float progress, NSString *operation, NSUInteger current, NSUInteger total);
typedef void (^SyncStatusCallback)(SyncTaskStatus status, NSString *description);
typedef void (^SyncCompletionCallback)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error);
typedef void (^SyncLogCallback)(NSString *logMessage);
typedef void (^DataItemsCallback)(NSArray<SyncDataItem *> *items, BackupDataType dataType);

// ğŸ†• ç…§ç‰‡ç›¸å…³å›è°ƒ
typedef void (^PhotoScanProgressCallback)(NSUInteger scannedCount, NSUInteger totalCount);
typedef void (^PhotoDownloadProgressCallback)(NSString *filename, NSUInteger downloadedBytes, NSUInteger totalBytes);
typedef void (^PhotoCompletionCallback)(NSArray<PhotoInfo *> *photos, NSError * _Nullable error);

// é€‰æ‹©æ€§å¤‡ä»½ä»»åŠ¡ä¸»ç±» - å®Œæ•´å¢å¼ºç‰ˆæœ¬
@interface BackupOptionTask : NSObject

#pragma mark - å•ä¾‹å’Œåˆå§‹åŒ–
+ (instancetype)sharedInstance;
- (instancetype)initWithDeviceUDID:(NSString * _Nullable)deviceUDID;

#pragma mark - å±æ€§
@property (nonatomic, readonly, strong, nullable) NSString *deviceUDID;
@property (nonatomic, readonly, assign) SyncTaskStatus status;
@property (nonatomic, readonly, assign) float progress;
@property (nonatomic, readonly, strong, nullable) NSError *lastError;
@property (nonatomic, readonly, assign) BOOL isOperating;
@property (nonatomic, readonly, assign) BOOL isPaused;

// æ•°æ®å­˜å‚¨è·¯å¾„
@property (nonatomic, strong) NSString *dataStoragePath;

// ğŸ†• ç…§ç‰‡ç›¸å…³è®¾ç½®
@property (nonatomic, assign) PhotoTransferMode photoTransferMode;
@property (nonatomic, assign) BOOL enableThumbnailGeneration;
@property (nonatomic, assign) NSUInteger maxPhotoResolution; // æœ€å¤§åˆ†è¾¨ç‡ï¼Œ0è¡¨ç¤ºæ— é™åˆ¶
@property (nonatomic, assign) BOOL preserveOriginalFormat;   // ä¿ç•™åŸå§‹æ ¼å¼
@property (nonatomic, assign) BOOL includeHiddenPhotos;      // åŒ…å«éšè—ç…§ç‰‡
@property (nonatomic, assign) BOOL includeLivePhotos;        // åŒ…å«Live Photos
@property (nonatomic, assign) BOOL includeVideoFiles;        // åŒ…å«è§†é¢‘æ–‡ä»¶

// å›è°ƒè®¾ç½®
@property (nonatomic, copy, nullable) SyncProgressCallback progressCallback;
@property (nonatomic, copy, nullable) SyncStatusCallback statusCallback;
@property (nonatomic, copy, nullable) SyncCompletionCallback completionCallback;
@property (nonatomic, copy, nullable) SyncLogCallback logCallback;
@property (nonatomic, copy, nullable) DataItemsCallback dataItemsCallback;

// ğŸ†• ç…§ç‰‡ç›¸å…³å›è°ƒ
@property (nonatomic, copy, nullable) PhotoScanProgressCallback photoScanCallback;
@property (nonatomic, copy, nullable) PhotoDownloadProgressCallback photoDownloadCallback;
@property (nonatomic, copy, nullable) PhotoCompletionCallback photoCompletionCallback;

@property (nonatomic, assign, readonly) DeviceConnectionCapability connectionCapability;


#pragma mark - è®¾å¤‡è¿æ¥å’ŒæŸ¥è¯¢
/**
 * è¿æ¥åˆ°æŒ‡å®šè®¾å¤‡
 * @param deviceUDID è®¾å¤‡UDID
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ˜¯å¦è¿æ¥æˆåŠŸ
 */
- (BOOL)connectToDevice:(NSString *)deviceUDID error:(NSError **)error;

/**
 * ğŸ†• æ‰«æè®¾å¤‡çœŸå®æ•°æ®ï¼ˆåŒ…å«ç…§ç‰‡ï¼‰
 */
- (NSDictionary *)scanRealDeviceDataEnhanced;

/**
 * æ–­å¼€è®¾å¤‡è¿æ¥
 */
- (void)disconnectDevice;

/**
 * æ£€æŸ¥è®¾å¤‡è¿æ¥çŠ¶æ€
 * @return æ˜¯å¦å·²è¿æ¥
 */
- (BOOL)isConnected;

/**
 * è·å–è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç 
 */
- (BackupDataType)getSupportedDataTypes:(NSError **)error;

/**
 * æ£€æŸ¥ç‰¹å®šæ•°æ®ç±»å‹æ˜¯å¦æ”¯æŒ
 * @param dataType æ•°æ®ç±»å‹
 * @return æ˜¯å¦æ”¯æŒ
 */
- (BOOL)isDataTypeSupported:(BackupDataType)dataType;

#pragma mark - ğŸ†• ç…§ç‰‡åº“è®¿é—®åŠŸèƒ½
/**
 * æ£€æŸ¥è®¾å¤‡ç…§ç‰‡åº“è®¿é—®æƒé™
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ˜¯å¦æœ‰è®¿é—®æƒé™
 */
- (BOOL)checkPhotoLibraryAccess:(NSError **)error;

/**
 * æ‰«æè®¾å¤‡ç…§ç‰‡åº“
 * @param albumNames æŒ‡å®šç›¸å†Œåç§°ï¼Œnilè¡¨ç¤ºæ‰«ææ‰€æœ‰
 * @param error é”™è¯¯ä¿¡æ¯
 * @return ç…§ç‰‡ä¿¡æ¯æ•°ç»„
 */
- (NSArray<PhotoInfo *> * _Nullable)scanPhotoLibrary:(NSArray<NSString *> * _Nullable)albumNames error:(NSError **)error;

/**
 * å¼‚æ­¥æ‰«æç…§ç‰‡åº“
 * @param albumNames æŒ‡å®šç›¸å†Œåç§°
 * @param progressCallback è¿›åº¦å›è°ƒ
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)scanPhotoLibraryAsync:(NSArray<NSString *> * _Nullable)albumNames
                     progress:(PhotoScanProgressCallback _Nullable)progressCallback
                   completion:(PhotoCompletionCallback)completion;

/**
 * è·å–ç…§ç‰‡åº“ç»Ÿè®¡ä¿¡æ¯
 * @param error é”™è¯¯ä¿¡æ¯
 * @return ç»Ÿè®¡ä¿¡æ¯å­—å…¸
 */
- (NSDictionary * _Nullable)getPhotoLibraryStatistics:(NSError **)error;

/**
 * ä¸‹è½½æŒ‡å®šç…§ç‰‡åˆ°æœ¬åœ°
 * @param photoInfo ç…§ç‰‡ä¿¡æ¯
 * @param destinationPath ç›®æ ‡è·¯å¾„
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ˜¯å¦ä¸‹è½½æˆåŠŸ
 */
- (BOOL)downloadPhoto:(PhotoInfo *)photoInfo
        toDestination:(NSString *)destinationPath
                error:(NSError **)error;

/**
 * æ‰¹é‡ä¸‹è½½ç…§ç‰‡
 * @param photos ç…§ç‰‡æ•°ç»„
 * @param destinationDir ç›®æ ‡ç›®å½•
 * @param progressCallback è¿›åº¦å›è°ƒ
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)downloadPhotos:(NSArray<PhotoInfo *> *)photos
      toDestinationDir:(NSString *)destinationDir
              progress:(PhotoDownloadProgressCallback _Nullable)progressCallback
            completion:(void (^)(NSUInteger successCount, NSUInteger failedCount, NSError * _Nullable error))completion;

#pragma mark - æ•°æ®æŸ¥è¯¢
/**
 * è·å–æŒ‡å®šæ•°æ®ç±»å‹çš„æ‰€æœ‰æ•°æ®é¡¹
 * @param dataType æ•°æ®ç±»å‹
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ•°æ®é¡¹æ•°ç»„
 */
- (NSArray<SyncDataItem *> * _Nullable)getDataItemsForType:(BackupDataType)dataType error:(NSError **)error;

/**
 * å¼‚æ­¥è·å–æ•°æ®é¡¹ï¼ˆæ¨èç”¨äºå¤§é‡æ•°æ®ï¼‰
 * @param dataType æ•°æ®ç±»å‹
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)getDataItemsForTypeAsync:(BackupDataType)dataType
                      completion:(void (^)(NSArray<SyncDataItem *> * _Nullable items, NSError * _Nullable error))completion;

/**
 * è·å–æ•°æ®ç±»å‹çš„ç»Ÿè®¡ä¿¡æ¯
 * @param dataType æ•°æ®ç±»å‹
 * @param error é”™è¯¯ä¿¡æ¯
 * @return ç»Ÿè®¡ä¿¡æ¯å­—å…¸
 */
- (NSDictionary * _Nullable)getDataTypeStatistics:(BackupDataType)dataType error:(NSError **)error;

#pragma mark - é€‰æ‹©æ€§åŒæ­¥æ“ä½œ
/**
 * å¼€å§‹é€‰æ‹©æ€§åŒæ­¥
 * @param dataTypes è¦åŒæ­¥çš„æ•°æ®ç±»å‹æ©ç 
 * @param direction åŒæ­¥æ–¹å‘
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ˜¯å¦æˆåŠŸå¼€å§‹
 */
- (BOOL)startSelectiveSync:(BackupDataType)dataTypes
                 direction:(SyncDirection)direction
                     error:(NSError **)error;

/**
 * åŒæ­¥ç‰¹å®šæ•°æ®é¡¹
 * @param items è¦åŒæ­¥çš„æ•°æ®é¡¹æ•°ç»„
 * @param direction åŒæ­¥æ–¹å‘
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ˜¯å¦æˆåŠŸå¼€å§‹åŒæ­¥
 */
- (BOOL)syncSpecificItems:(NSArray<SyncDataItem *> *)items
                direction:(SyncDirection)direction
                    error:(NSError **)error;

/**
 * å¤‡ä»½é€‰å®šçš„æ•°æ®ç±»å‹åˆ°æŒ‡å®šè·¯å¾„
 * @param dataTypes æ•°æ®ç±»å‹æ©ç 
 * @param backupPath å¤‡ä»½å­˜å‚¨è·¯å¾„
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ˜¯å¦æˆåŠŸå¼€å§‹å¤‡ä»½
 */
- (BOOL)backupSelectedDataTypes:(BackupDataType)dataTypes
                    toDirectory:(NSString *)backupPath
                          error:(NSError **)error;

/**
 * ä»æŒ‡å®šè·¯å¾„æ¢å¤æ•°æ®åˆ°è®¾å¤‡
 * @param dataTypes æ•°æ®ç±»å‹æ©ç 
 * @param backupPath å¤‡ä»½è·¯å¾„
 * @param error é”™è¯¯ä¿¡æ¯
 * @return æ˜¯å¦æˆåŠŸå¼€å§‹æ¢å¤
 */
- (BOOL)restoreSelectedDataTypes:(BackupDataType)dataTypes
                   fromDirectory:(NSString *)backupPath
                           error:(NSError **)error;


- (BOOL)canSyncTraditionalDataTypes;
- (BOOL)canSyncPhotoDataTypes;
- (NSString *)getConnectionCapabilityDescription;
- (void)diagnoseServiceCapabilities;

#pragma mark - æ“ä½œæ§åˆ¶
/**
 * å–æ¶ˆå½“å‰åŒæ­¥æ“ä½œ
 */
- (void)cancelCurrentOperation;

/**
 * æš‚åœå½“å‰æ“ä½œ
 */
- (void)pauseCurrentOperation;

/**
 * æ¢å¤æš‚åœçš„æ“ä½œ
 */
- (void)resumeCurrentOperation;

/**
 * è·å–å½“å‰æ“ä½œè¿›åº¦
 * @return è¿›åº¦ç™¾åˆ†æ¯” (0.0-100.0)
 */
- (float)getCurrentProgress;

#pragma mark - æ•°æ®ç±»å‹å·¥å…·æ–¹æ³•
/**
 * å°†æ•°æ®ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²æè¿°
 * @param dataType æ•°æ®ç±»å‹
 * @return æè¿°å­—ç¬¦ä¸²
 */
+ (NSString *)stringForDataType:(BackupDataType)dataType;

/**
 * å°†æ•°æ®ç±»å‹è½¬æ¢ä¸ºæœ¬åœ°åŒ–å­—ç¬¦ä¸²
 * @param dataType æ•°æ®ç±»å‹
 * @return æœ¬åœ°åŒ–æè¿°å­—ç¬¦ä¸²
 */
+ (NSString *)localizedStringForDataType:(BackupDataType)dataType;

/**
 * å°†æ•°æ®ç±»å‹æ©ç è½¬æ¢ä¸ºæ•°ç»„
 * @param dataTypes æ•°æ®ç±»å‹æ©ç 
 * @return æ•°æ®ç±»å‹æ•°ç»„
 */
+ (NSArray<NSNumber *> *)arrayFromDataTypes:(BackupDataType)dataTypes;

/**
 * å°†æ•°æ®ç±»å‹æ•°ç»„è½¬æ¢ä¸ºæ©ç 
 * @param dataTypeArray æ•°æ®ç±»å‹æ•°ç»„
 * @return æ•°æ®ç±»å‹æ©ç 
 */
+ (BackupDataType)dataTypesFromArray:(NSArray<NSNumber *> *)dataTypeArray;

/**
 * è·å–æ‰€æœ‰å¯ç”¨çš„æ•°æ®ç±»å‹
 * @return æ‰€æœ‰æ•°æ®ç±»å‹çš„æ•°ç»„
 */
+ (NSArray<NSNumber *> *)getAllAvailableDataTypes;

/**
 * ğŸ†• æ£€æŸ¥æ•°æ®ç±»å‹æ˜¯å¦ä¸ºç…§ç‰‡/åª’ä½“ç±»å‹
 * @param dataType æ•°æ®ç±»å‹
 * @return æ˜¯å¦ä¸ºç…§ç‰‡/åª’ä½“ç±»å‹
 */
+ (BOOL)isPhotoMediaType:(BackupDataType)dataType;

#pragma mark - ä¾¿æ·æ–¹æ³•
/**
 * å¿«é€Ÿå¤‡ä»½è”ç³»äºº
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupContacts:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * å¿«é€Ÿå¤‡ä»½æ—¥å†
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupCalendars:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * å¿«é€Ÿå¤‡ä»½ä¹¦ç­¾
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupBookmarks:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * å¿«é€Ÿå¤‡ä»½é‚®ç®±è´¦æˆ·
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupMailAccounts:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * å¿«é€Ÿå¤‡ä»½å¤‡å¿˜å½•
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupNotes:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * å¿«é€Ÿå¤‡ä»½æé†’äº‹é¡¹
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupReminders:(void (^)(BOOL success, NSError * _Nullable error))completion;

/**
 * ğŸ†• å¿«é€Ÿå¤‡ä»½ç…§ç‰‡åº“
 * @param transferMode ä¼ è¾“æ¨¡å¼
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupPhotos:(PhotoTransferMode)transferMode
               completion:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion;

/**
 * ğŸ†• å¿«é€Ÿå¤‡ä»½ç›¸æœºèƒ¶å·
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupCameraRoll:(void (^)(BOOL success, NSUInteger photoCount, NSError * _Nullable error))completion;

/**
 * å¿«é€Ÿå¤‡ä»½æ‰€æœ‰æ”¯æŒçš„æ•°æ®ç±»å‹
 * @param completion å®Œæˆå›è°ƒ
 */
- (void)quickBackupAllSupportedData:(void (^)(BOOL success, BackupDataType completedTypes, NSError * _Nullable error))completion;

#pragma mark - æ•°æ®éªŒè¯å’Œæ¢å¤
/**
 * éªŒè¯å¤‡ä»½æ•°æ®çš„å®Œæ•´æ€§
 * @param backupPath å¤‡ä»½è·¯å¾„
 * @param dataTypes è¦éªŒè¯çš„æ•°æ®ç±»å‹
 * @param error é”™è¯¯ä¿¡æ¯
 * @return éªŒè¯ç»“æœ
 */
- (BOOL)verifyBackupIntegrity:(NSString *)backupPath
                    dataTypes:(BackupDataType)dataTypes
                        error:(NSError **)error;

/**
 * è·å–å¤‡ä»½æ•°æ®çš„è¯¦ç»†ä¿¡æ¯
 * @param backupPath å¤‡ä»½è·¯å¾„
 * @param error é”™è¯¯ä¿¡æ¯
 * @return å¤‡ä»½ä¿¡æ¯å­—å…¸
 */
- (NSDictionary * _Nullable)getBackupInfo:(NSString *)backupPath error:(NSError **)error;

#pragma mark - è°ƒè¯•å’Œè¯Šæ–­å·¥å…·
/**
 * è¯Šæ–­è®¾å¤‡åŒæ­¥èƒ½åŠ›
 */
- (void)diagnoseDeviceSyncCapabilities;

/**
 * è·å–è¯¦ç»†çš„æ•°æ®ç±»å‹ä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
 * @param dataType æ•°æ®ç±»å‹
 * @return æ•°æ®ç±»å‹è¯¦ç»†ä¿¡æ¯
 */
- (NSDictionary *)getDetailedDataTypeInfo:(BackupDataType)dataType;

/**
 * ğŸ†• è¯Šæ–­è®¾å¤‡ç…§ç‰‡åº“è®¿é—®èƒ½åŠ›
 */
- (void)diagnosePhotoLibraryAccess;

@end

NS_ASSUME_NONNULL_END


-----------------------------

V2çš„æ—¥å¿—ï¼š

2025-05-29 13:28:36.208865+0800 MFCTOOL.bin[73786:14262979] DeviceBackupRestore: ğŸ”§ å¯åŠ¨ä¿®å¤ç‰ˆé€‰æ‹©æ€§å¤‡ä»½
2025-05-29 13:28:36.209168+0800 MFCTOOL.bin[73786:14262979] Internal disconnecting device...
2025-05-29 13:28:36.209336+0800 MFCTOOL.bin[73786:14262979] Device disconnection completed, capability reset to None
2025-05-29 13:28:36.209440+0800 MFCTOOL.bin[73786:14262979] Device disconnection completed
2025-05-29 13:28:37.210627+0800 MFCTOOL.bin[73786:14262979] Connecting to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.210933+0800 MFCTOOL.bin[73786:14262979] Status changed: 0 -> 1
2025-05-29 13:28:37.212404+0800 MFCTOOL.bin[73786:14262979] Device connection established
2025-05-29 13:28:37.267719+0800 MFCTOOL.bin[73786:14262979] Lockdown connection established
2025-05-29 13:28:37.267965+0800 MFCTOOL.bin[73786:14262979] Starting MobileSync service...
2025-05-29 13:28:37.274956+0800 MFCTOOL.bin[73786:14262979] MobileSync service start attempt 1: lockdownd_start_service returned 0
2025-05-29 13:28:37.275056+0800 MFCTOOL.bin[73786:14262979] MobileSync service descriptor created successfully (port: 50543)
2025-05-29 13:28:37.367266+0800 MFCTOOL.bin[73786:14262979] mobilesync_client_new returned 0
2025-05-29 13:28:37.367496+0800 MFCTOOL.bin[73786:14262979] MobileSync client created successfully
2025-05-29 13:28:37.367573+0800 MFCTOOL.bin[73786:14262979] âœ… MobileSync service available - Traditional data types (Contacts, Calendars, etc.) supported
2025-05-29 13:28:37.371461+0800 MFCTOOL.bin[73786:14262979] AFC service started successfully
2025-05-29 13:28:37.371550+0800 MFCTOOL.bin[73786:14262979] âœ… AFC service available - Photo data types supported
2025-05-29 13:28:37.383061+0800 MFCTOOL.bin[73786:14262979] AFC2 service not available, using regular AFC for photos
2025-05-29 13:28:37.383152+0800 MFCTOOL.bin[73786:14262979] âœ… Photo AFC service started successfully
2025-05-29 13:28:37.383201+0800 MFCTOOL.bin[73786:14262979] âœ… Successfully connected to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.383290+0800 MFCTOOL.bin[73786:14262979] ğŸ“Š Connection capability: Full capability (Traditional data + Photos) - Both MobileSync and AFC available
2025-05-29 13:28:37.383342+0800 MFCTOOL.bin[73786:14262979] Status changed: 1 -> 0
2025-05-29 13:28:37.383449+0800 MFCTOOL.bin[73786:14263179] Connecting to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.383530+0800 MFCTOOL.bin[73786:14263179] Already connected to device: 00008030-0008352034B9802E (MobileSync: Yes, AFC: Yes)
2025-05-29 13:28:37.392975+0800 MFCTOOL.bin[73786:14263179] === ç¡®ä¿è®¾å¤‡è¿æ¥å’Œåˆå§‹åŒ– ===
2025-05-29 13:28:37.393018+0800 MFCTOOL.bin[73786:14262979] é€‰æ‹©æ€§å¤‡ä»½çŠ¶æ€æ›´æ–°: Connecting to device
2025-05-29 13:28:37.393095+0800 MFCTOOL.bin[73786:14263179] Internal disconnecting device...
2025-05-29 13:28:37.393123+0800 MFCTOOL.bin[73786:14262979] é€‰æ‹©æ€§å¤‡ä»½çŠ¶æ€æ›´æ–°: Idle
2025-05-29 13:28:37.393179+0800 MFCTOOL.bin[73786:14263179] AFC client freed
2025-05-29 13:28:37.393457+0800 MFCTOOL.bin[73786:14263179] MobileSync client freed
2025-05-29 13:28:37.394628+0800 MFCTOOL.bin[73786:14263179] Lockdown client freed
2025-05-29 13:28:37.394685+0800 MFCTOOL.bin[73786:14263179] Device connection freed
2025-05-29 13:28:37.394719+0800 MFCTOOL.bin[73786:14263179] Device disconnection completed, capability reset to None
2025-05-29 13:28:37.394751+0800 MFCTOOL.bin[73786:14263179] Device disconnection completed
2025-05-29 13:28:37.899877+0800 MFCTOOL.bin[73786:14263179] Connecting to device: 00008030-0008352034B9802E
2025-05-29 13:28:37.900136+0800 MFCTOOL.bin[73786:14263179] Status changed: 0 -> 1
2025-05-29 13:28:37.901844+0800 MFCTOOL.bin[73786:14263179] Device connection established
2025-05-29 13:28:37.907407+0800 MFCTOOL.bin[73786:14262979] é€‰æ‹©æ€§å¤‡ä»½çŠ¶æ€æ›´æ–°: Connecting to device
2025-05-29 13:28:37.953409+0800 MFCTOOL.bin[73786:14263179] Lockdown connection established
2025-05-29 13:28:37.953627+0800 MFCTOOL.bin[73786:14263179] Starting MobileSync service...
2025-05-29 13:28:37.960253+0800 MFCTOOL.bin[73786:14263179] MobileSync service start attempt 1: lockdownd_start_service returned 0
2025-05-29 13:28:37.960382+0800 MFCTOOL.bin[73786:14263179] MobileSync service descriptor created successfully (port: 50548)
2025-05-29 13:29:18.037318+0800 MFCTOOL.bin[73786:14263179] mobilesync_client_new returned -5
2025-05-29 13:29:18.037682+0800 MFCTOOL.bin[73786:14263179] [ERR] MobileSync client creation failed (attempt 1): -5
2025-05-29 13:29:18.037795+0800 MFCTOOL.bin[73786:14263179] [WAR] Retrying MobileSync in 1 seconds...
2025-05-29 13:29:19.061107+0800 MFCTOOL.bin[73786:14263179] MobileSync service start attempt 2: lockdownd_start_service returned 0
2025-05-29 13:29:19.061318+0800 MFCTOOL.bin[73786:14263179] MobileSync service descriptor created successfully (port: 50580)
2025-05-29 13:29:19.097476+0800 MFCTOOL.bin[73786:14263179] mobilesync_client_new returned 0
2025-05-29 13:29:19.097627+0800 MFCTOOL.bin[73786:14263179] MobileSync client created successfully
2025-05-29 13:29:19.097691+0800 MFCTOOL.bin[73786:14263179] âœ… MobileSync service available - Traditional data types (Contacts, Calendars, etc.) supported
2025-05-29 13:29:19.101355+0800 MFCTOOL.bin[73786:14263179] AFC service started successfully
2025-05-29 13:29:19.101466+0800 MFCTOOL.bin[73786:14263179] âœ… AFC service available - Photo data types supported
2025-05-29 13:29:19.105710+0800 MFCTOOL.bin[73786:14263179] AFC2 service not available, using regular AFC for photos
2025-05-29 13:29:19.105783+0800 MFCTOOL.bin[73786:14263179] âœ… Photo AFC service started successfully
2025-05-29 13:29:19.105826+0800 MFCTOOL.bin[73786:14263179] âœ… Successfully connected to device: 00008030-0008352034B9802E
2025-05-29 13:29:19.105867+0800 MFCTOOL.bin[73786:14263179] ğŸ“Š Connection capability: Full capability (Traditional data + Photos) - Both MobileSync and AFC available
2025-05-29 13:29:19.105907+0800 MFCTOOL.bin[73786:14263179] Status changed: 1 -> 0
2025-05-29 13:29:19.105949+0800 MFCTOOL.bin[73786:14263179] âœ… è®¾å¤‡è¿æ¥æˆåŠŸ
2025-05-29 13:29:19.106029+0800 MFCTOOL.bin[73786:14263179] Device UDID: 00008030-0008352034B9802E
2025-05-29 13:29:19.106202+0800 MFCTOOL.bin[73786:14262979] é€‰æ‹©æ€§å¤‡ä»½çŠ¶æ€æ›´æ–°: Idle
2025-05-29 13:29:19.146898+0800 MFCTOOL.bin[73786:14263179] âœ… Contacts (com.apple.Contacts)
2025-05-29 13:29:19.205766+0800 MFCTOOL.bin[73786:14263179] âœ… Calendars (com.apple.Calendars)
2025-05-29 13:29:19.232658+0800 MFCTOOL.bin[73786:14263179] âœ… Bookmarks (com.apple.Bookmarks)
2025-05-29 13:29:19.244533+0800 MFCTOOL.bin[73786:14263179] âœ… MailAccounts (com.apple.MailAccounts)
2025-05-29 13:29:19.247338+0800 MFCTOOL.bin[73786:14263179] âŒ Notes (com.apple.Notes)
2025-05-29 13:29:19.247410+0800 MFCTOOL.bin[73786:14263179] âŒ Reminders (com.apple.Reminders)
2025-05-29 13:29:19.247457+0800 MFCTOOL.bin[73786:14263179] âŒ Applications (com.apple.MobileApplication)
2025-05-29 13:29:19.247496+0800 MFCTOOL.bin[73786:14263179] âŒ Configuration (com.apple.SystemConfiguration)
2025-05-29 13:29:19.247547+0800 MFCTOOL.bin[73786:14263179] âŒ Keychain (com.apple.Keychain)
2025-05-29 13:29:19.247582+0800 MFCTOOL.bin[73786:14263179] âŒ Voice Memos (com.apple.VoiceMemos)
2025-05-29 13:29:19.247616+0800 MFCTOOL.bin[73786:14263179] âŒ Wallpaper (com.apple.Wallpaper)
2025-05-29 13:29:19.249034+0800 MFCTOOL.bin[73786:14263179] âœ… Photos (com.apple.Photos)
2025-05-29 13:29:19.249860+0800 MFCTOOL.bin[73786:14263179] âœ… Videos (com.apple.MediaAssets)
2025-05-29 13:29:19.250704+0800 MFCTOOL.bin[73786:14263179] âœ… Camera Roll (com.apple.CameraRoll)
2025-05-29 13:29:19.251506+0800 MFCTOOL.bin[73786:14263179] âŒ Photo Albums (com.apple.PhotoAlbums)
2025-05-29 13:29:19.252128+0800 MFCTOOL.bin[73786:14263179] âŒ Photo Stream (com.apple.PhotoStream)
2025-05-29 13:29:19.252584+0800 MFCTOOL.bin[73786:14263179] âŒ Screenshots (com.apple.Screenshots)
2025-05-29 13:29:19.253196+0800 MFCTOOL.bin[73786:14263179] âŒ Slow Motion (com.apple.SlowMotion)
2025-05-29 13:29:19.254098+0800 MFCTOOL.bin[73786:14263179] âŒ Time-lapses (com.apple.Timelapses)
2025-05-29 13:29:19.254965+0800 MFCTOOL.bin[73786:14263179] âŒ Burst Photos (com.apple.BurstPhotos)
2025-05-29 13:29:19.256148+0800 MFCTOOL.bin[73786:14263179] âŒ Live Photos (com.apple.LivePhotos)
2025-05-29 13:29:19.256200+0800 MFCTOOL.bin[73786:14263179] Total: 7/21 data types supported
2025-05-29 13:29:19.256240+0800 MFCTOOL.bin[73786:14263179] âœ… è®¾å¤‡è¿æ¥å’Œåˆå§‹åŒ–å®Œæˆ
2025-05-29 13:29:19.256278+0800 MFCTOOL.bin[73786:14263179] === ğŸ”§ å¼€å§‹å¢å¼ºç‰ˆè®¾å¤‡çœŸå®æ•°æ®æ‰«æï¼ˆåŒ…å«ç…§ç‰‡ï¼‰===
2025-05-29 13:29:19.256322+0800 MFCTOOL.bin[73786:14263179] Getting supported data types with capability-based detection
2025-05-29 13:29:19.256365+0800 MFCTOOL.bin[73786:14263179] Checking 21 data types based on connection capability...
2025-05-29 13:29:19.461503+0800 MFCTOOL.bin[73786:14263179] Traditional type Contacts (MobileSync): âŒ Not supported
2025-05-29 13:29:19.718282+0800 MFCTOOL.bin[73786:14263179] Traditional type Calendars (MobileSync): âŒ Not supported
2025-05-29 13:29:19.975068+0800 MFCTOOL.bin[73786:14263179] Traditional type Bookmarks (MobileSync): âŒ Not supported
2025-05-29 13:29:20.234082+0800 MFCTOOL.bin[73786:14263179] Traditional type MailAccounts (MobileSync): âŒ Not supported
2025-05-29 13:29:20.494481+0800 MFCTOOL.bin[73786:14263179] Traditional type Notes (MobileSync): âŒ Not supported
2025-05-29 13:29:20.754897+0800 MFCTOOL.bin[73786:14263179] Traditional type Reminders (MobileSync): âŒ Not supported
2025-05-29 13:29:21.015058+0800 MFCTOOL.bin[73786:14263179] Traditional type Applications (MobileSync): âŒ Not supported
2025-05-29 13:29:21.272970+0800 MFCTOOL.bin[73786:14263179] Traditional type Configuration (MobileSync): âŒ Not supported
2025-05-29 13:29:21.533149+0800 MFCTOOL.bin[73786:14263179] Traditional type Keychain (MobileSync): âŒ Not supported
2025-05-29 13:29:21.791707+0800 MFCTOOL.bin[73786:14263179] Traditional type Voice Memos (MobileSync): âŒ Not supported
2025-05-29 13:29:22.047414+0800 MFCTOOL.bin[73786:14263179] Traditional type Wallpaper (MobileSync): âŒ Not supported
2025-05-29 13:29:22.101301+0800 MFCTOOL.bin[73786:14263179] Photo type Photos (AFC): âœ… Supported
2025-05-29 13:29:22.155478+0800 MFCTOOL.bin[73786:14263179] Photo type Videos (AFC): âœ… Supported
2025-05-29 13:29:22.209910+0800 MFCTOOL.bin[73786:14263179] Photo type Camera Roll (AFC): âœ… Supported
2025-05-29 13:29:22.266844+0800 MFCTOOL.bin[73786:14263179] Photo type Photo Albums (AFC): âŒ Not supported
2025-05-29 13:29:22.323087+0800 MFCTOOL.bin[73786:14263179] Photo type Photo Stream (AFC): âŒ Not supported
2025-05-29 13:29:22.376133+0800 MFCTOOL.bin[73786:14263179] Photo type Screenshots (AFC): âŒ Not supported
2025-05-29 13:29:22.432756+0800 MFCTOOL.bin[73786:14263179] Photo type Slow Motion (AFC): âŒ Not supported
2025-05-29 13:29:22.490063+0800 MFCTOOL.bin[73786:14263179] Photo type Time-lapses (AFC): âŒ Not supported
2025-05-29 13:29:22.544290+0800 MFCTOOL.bin[73786:14263179] Photo type Burst Photos (AFC): âŒ Not supported
2025-05-29 13:29:22.601710+0800 MFCTOOL.bin[73786:14263179] Photo type Live Photos (AFC): âŒ Not supported
2025-05-29 13:29:22.602005+0800 MFCTOOL.bin[73786:14263179] Detection complete: 3/21 data types supported (cached for 5 minutes)
2025-05-29 13:29:22.602110+0800 MFCTOOL.bin[73786:14263179] ğŸ“Š Capability summary: Full capability (Traditional data + Photos) - Both MobileSync and AFC available
2025-05-29 13:29:22.602199+0800 MFCTOOL.bin[73786:14263179] è®¾å¤‡æ”¯æŒçš„æ•°æ®ç±»å‹æ©ç : 14336
2025-05-29 13:29:22.602284+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Contacts
2025-05-29 13:29:22.602355+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Calendars
2025-05-29 13:29:22.602423+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Bookmarks
2025-05-29 13:29:22.602490+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: MailAccounts
2025-05-29 13:29:22.602586+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Notes
2025-05-29 13:29:22.602758+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Reminders
2025-05-29 13:29:22.602996+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Applications
2025-05-29 13:29:22.603195+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Configuration
2025-05-29 13:29:22.603409+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Keychain
2025-05-29 13:29:22.603533+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Voice Memos
2025-05-29 13:29:22.603656+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Wallpaper
2025-05-29 13:29:22.603827+0800 MFCTOOL.bin[73786:14263179] æ­£åœ¨è·å– Photos çš„çœŸå®æ•°æ®...
2025-05-29 13:29:22.603990+0800 MFCTOOL.bin[73786:14263179] å¢å¼ºæ–¹æ³•è·å– Photos çš„çœŸå®æ•°æ®
2025-05-29 13:29:22.604074+0800 MFCTOOL.bin[73786:14263179] Processing photo data for type: Photos
2025-05-29 13:29:22.618887+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM/100APPLE
2025-05-29 13:29:22.619005+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM
2025-05-29 13:29:22.619290+0800 MFCTOOL.bin[73786:14263179] Processed 1 photo items for type: Photos
2025-05-29 13:29:22.619393+0800 MFCTOOL.bin[73786:14263179] Photos è·å–æˆåŠŸ: 1 é¡¹
2025-05-29 13:29:22.924510+0800 MFCTOOL.bin[73786:14263179] æ­£åœ¨è·å– Videos çš„çœŸå®æ•°æ®...
2025-05-29 13:29:22.924754+0800 MFCTOOL.bin[73786:14263179] å¢å¼ºæ–¹æ³•è·å– Videos çš„çœŸå®æ•°æ®
2025-05-29 13:29:22.924857+0800 MFCTOOL.bin[73786:14263179] Processing photo data for type: Videos
2025-05-29 13:29:22.938520+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM/100APPLE
2025-05-29 13:29:22.938636+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM
2025-05-29 13:29:22.938824+0800 MFCTOOL.bin[73786:14263179] Processed 1 photo items for type: Videos
2025-05-29 13:29:22.938935+0800 MFCTOOL.bin[73786:14263179] Videos è·å–æˆåŠŸ: 1 é¡¹
2025-05-29 13:29:23.244067+0800 MFCTOOL.bin[73786:14263179] æ­£åœ¨è·å– Camera Roll çš„çœŸå®æ•°æ®...
2025-05-29 13:29:23.244331+0800 MFCTOOL.bin[73786:14263179] å¢å¼ºæ–¹æ³•è·å– Camera Roll çš„çœŸå®æ•°æ®
2025-05-29 13:29:23.244441+0800 MFCTOOL.bin[73786:14263179] Processing photo data for type: Camera Roll
2025-05-29 13:29:23.253467+0800 MFCTOOL.bin[73786:14263179] Found 2 photos in directory: /DCIM/100APPLE
2025-05-29 13:29:23.253660+0800 MFCTOOL.bin[73786:14263179] Processed 2 photo items for type: Camera Roll
2025-05-29 13:29:23.253778+0800 MFCTOOL.bin[73786:14263179] Camera Roll è·å–æˆåŠŸ: 2 é¡¹
2025-05-29 13:29:23.558902+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Photo Albums
2025-05-29 13:29:23.559145+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Photo Stream
2025-05-29 13:29:23.559227+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Screenshots
2025-05-29 13:29:23.559302+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Slow Motion
2025-05-29 13:29:23.559372+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Time-lapses
2025-05-29 13:29:23.559442+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Burst Photos
2025-05-29 13:29:23.559509+0800 MFCTOOL.bin[73786:14263179] è·³è¿‡ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: Live Photos
2025-05-29 13:29:23.559581+0800 MFCTOOL.bin[73786:14263179] === ğŸ”§ å¢å¼ºç‰ˆæ•°æ®æ‰«æå®Œæˆï¼Œå…±å¤„ç† 3 ç§æ•°æ®ç±»å‹ï¼ˆåŒ…å«ç…§ç‰‡ï¼‰===
2025-05-29 13:29:23.559717+0800 MFCTOOL.bin[73786:14262979] === çœŸå®è®¾å¤‡æ•°æ®è·å–ç»“æœ ===
2025-05-29 13:29:23.559945+0800 MFCTOOL.bin[73786:14262979] === ç»“æœè®°å½•å®Œæˆ ===
2025-05-29 13:29:23.560030+0800 MFCTOOL.bin[73786:14262979] DeviceBackupRestore: åˆ›å»ºå¢å¼ºçš„é€‰æ‹©æ€§å¤‡ä»½çª—å£
2025-05-29 13:29:23.586689+0800 MFCTOOL.bin[73786:14262979] DeviceBackupRestore: å¢å¼ºçš„é€‰æ‹©æ€§å¤‡ä»½çª—å£å·²æ˜¾ç¤º
